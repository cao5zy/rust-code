/* automatically generated by rust-bindgen 0.59.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub const __WORDSIZE: u32 = 64;
    pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
    pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
    pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
    pub const __DARWIN_UNIX03: u32 = 1;
    pub const __DARWIN_64_BIT_INO_T: u32 = 1;
    pub const __DARWIN_VERS_1050: u32 = 1;
    pub const __DARWIN_NON_CANCELABLE: u32 = 0;
    pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
    pub const __DARWIN_C_ANSI: u32 = 4096;
    pub const __DARWIN_C_FULL: u32 = 900000;
    pub const __DARWIN_C_LEVEL: u32 = 900000;
    pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
    pub const __DARWIN_NO_LONG_LONG: u32 = 0;
    pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
    pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
    pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
    pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
    pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
    pub const __PTHREAD_SIZE__: u32 = 8176;
    pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
    pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
    pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
    pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
    pub const __PTHREAD_COND_SIZE__: u32 = 40;
    pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
    pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
    pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
    pub const INT8_MAX: u32 = 127;
    pub const INT16_MAX: u32 = 32767;
    pub const INT32_MAX: u32 = 2147483647;
    pub const INT64_MAX: u64 = 9223372036854775807;
    pub const INT8_MIN: i32 = -128;
    pub const INT16_MIN: i32 = -32768;
    pub const INT32_MIN: i32 = -2147483648;
    pub const INT64_MIN: i64 = -9223372036854775808;
    pub const UINT8_MAX: u32 = 255;
    pub const UINT16_MAX: u32 = 65535;
    pub const UINT32_MAX: u32 = 4294967295;
    pub const UINT64_MAX: i32 = -1;
    pub const INT_LEAST8_MIN: i32 = -128;
    pub const INT_LEAST16_MIN: i32 = -32768;
    pub const INT_LEAST32_MIN: i32 = -2147483648;
    pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
    pub const INT_LEAST8_MAX: u32 = 127;
    pub const INT_LEAST16_MAX: u32 = 32767;
    pub const INT_LEAST32_MAX: u32 = 2147483647;
    pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
    pub const UINT_LEAST8_MAX: u32 = 255;
    pub const UINT_LEAST16_MAX: u32 = 65535;
    pub const UINT_LEAST32_MAX: u32 = 4294967295;
    pub const UINT_LEAST64_MAX: i32 = -1;
    pub const INT_FAST8_MIN: i32 = -128;
    pub const INT_FAST16_MIN: i32 = -32768;
    pub const INT_FAST32_MIN: i32 = -2147483648;
    pub const INT_FAST64_MIN: i64 = -9223372036854775808;
    pub const INT_FAST8_MAX: u32 = 127;
    pub const INT_FAST16_MAX: u32 = 32767;
    pub const INT_FAST32_MAX: u32 = 2147483647;
    pub const INT_FAST64_MAX: u64 = 9223372036854775807;
    pub const UINT_FAST8_MAX: u32 = 255;
    pub const UINT_FAST16_MAX: u32 = 65535;
    pub const UINT_FAST32_MAX: u32 = 4294967295;
    pub const UINT_FAST64_MAX: i32 = -1;
    pub const INTPTR_MAX: u64 = 9223372036854775807;
    pub const INTPTR_MIN: i64 = -9223372036854775808;
    pub const UINTPTR_MAX: i32 = -1;
    pub const SIZE_MAX: i32 = -1;
    pub const RSIZE_MAX: i32 = -1;
    pub const WINT_MIN: i32 = -2147483648;
    pub const WINT_MAX: u32 = 2147483647;
    pub const SIG_ATOMIC_MIN: i32 = -2147483648;
    pub const SIG_ATOMIC_MAX: u32 = 2147483647;
    pub const AV_BUFFER_FLAG_READONLY: u32 = 1;
    pub const FF_LAMBDA_SHIFT: u32 = 7;
    pub const FF_LAMBDA_SCALE: u32 = 128;
    pub const FF_QP2LAMBDA: u32 = 118;
    pub const FF_LAMBDA_MAX: u32 = 32767;
    pub const FF_QUALITY_SCALE: u32 = 128;
    pub const AV_TIME_BASE: u32 = 1000000;
    pub const EPERM: u32 = 1;
    pub const ENOENT: u32 = 2;
    pub const ESRCH: u32 = 3;
    pub const EINTR: u32 = 4;
    pub const EIO: u32 = 5;
    pub const ENXIO: u32 = 6;
    pub const E2BIG: u32 = 7;
    pub const ENOEXEC: u32 = 8;
    pub const EBADF: u32 = 9;
    pub const ECHILD: u32 = 10;
    pub const EDEADLK: u32 = 11;
    pub const ENOMEM: u32 = 12;
    pub const EACCES: u32 = 13;
    pub const EFAULT: u32 = 14;
    pub const ENOTBLK: u32 = 15;
    pub const EBUSY: u32 = 16;
    pub const EEXIST: u32 = 17;
    pub const EXDEV: u32 = 18;
    pub const ENODEV: u32 = 19;
    pub const ENOTDIR: u32 = 20;
    pub const EISDIR: u32 = 21;
    pub const EINVAL: u32 = 22;
    pub const ENFILE: u32 = 23;
    pub const EMFILE: u32 = 24;
    pub const ENOTTY: u32 = 25;
    pub const ETXTBSY: u32 = 26;
    pub const EFBIG: u32 = 27;
    pub const ENOSPC: u32 = 28;
    pub const ESPIPE: u32 = 29;
    pub const EROFS: u32 = 30;
    pub const EMLINK: u32 = 31;
    pub const EPIPE: u32 = 32;
    pub const EDOM: u32 = 33;
    pub const ERANGE: u32 = 34;
    pub const EAGAIN: u32 = 35;
    pub const EWOULDBLOCK: u32 = 35;
    pub const EINPROGRESS: u32 = 36;
    pub const EALREADY: u32 = 37;
    pub const ENOTSOCK: u32 = 38;
    pub const EDESTADDRREQ: u32 = 39;
    pub const EMSGSIZE: u32 = 40;
    pub const EPROTOTYPE: u32 = 41;
    pub const ENOPROTOOPT: u32 = 42;
    pub const EPROTONOSUPPORT: u32 = 43;
    pub const ESOCKTNOSUPPORT: u32 = 44;
    pub const ENOTSUP: u32 = 45;
    pub const EPFNOSUPPORT: u32 = 46;
    pub const EAFNOSUPPORT: u32 = 47;
    pub const EADDRINUSE: u32 = 48;
    pub const EADDRNOTAVAIL: u32 = 49;
    pub const ENETDOWN: u32 = 50;
    pub const ENETUNREACH: u32 = 51;
    pub const ENETRESET: u32 = 52;
    pub const ECONNABORTED: u32 = 53;
    pub const ECONNRESET: u32 = 54;
    pub const ENOBUFS: u32 = 55;
    pub const EISCONN: u32 = 56;
    pub const ENOTCONN: u32 = 57;
    pub const ESHUTDOWN: u32 = 58;
    pub const ETOOMANYREFS: u32 = 59;
    pub const ETIMEDOUT: u32 = 60;
    pub const ECONNREFUSED: u32 = 61;
    pub const ELOOP: u32 = 62;
    pub const ENAMETOOLONG: u32 = 63;
    pub const EHOSTDOWN: u32 = 64;
    pub const EHOSTUNREACH: u32 = 65;
    pub const ENOTEMPTY: u32 = 66;
    pub const EPROCLIM: u32 = 67;
    pub const EUSERS: u32 = 68;
    pub const EDQUOT: u32 = 69;
    pub const ESTALE: u32 = 70;
    pub const EREMOTE: u32 = 71;
    pub const EBADRPC: u32 = 72;
    pub const ERPCMISMATCH: u32 = 73;
    pub const EPROGUNAVAIL: u32 = 74;
    pub const EPROGMISMATCH: u32 = 75;
    pub const EPROCUNAVAIL: u32 = 76;
    pub const ENOLCK: u32 = 77;
    pub const ENOSYS: u32 = 78;
    pub const EFTYPE: u32 = 79;
    pub const EAUTH: u32 = 80;
    pub const ENEEDAUTH: u32 = 81;
    pub const EPWROFF: u32 = 82;
    pub const EDEVERR: u32 = 83;
    pub const EOVERFLOW: u32 = 84;
    pub const EBADEXEC: u32 = 85;
    pub const EBADARCH: u32 = 86;
    pub const ESHLIBVERS: u32 = 87;
    pub const EBADMACHO: u32 = 88;
    pub const ECANCELED: u32 = 89;
    pub const EIDRM: u32 = 90;
    pub const ENOMSG: u32 = 91;
    pub const EILSEQ: u32 = 92;
    pub const ENOATTR: u32 = 93;
    pub const EBADMSG: u32 = 94;
    pub const EMULTIHOP: u32 = 95;
    pub const ENODATA: u32 = 96;
    pub const ENOLINK: u32 = 97;
    pub const ENOSR: u32 = 98;
    pub const ENOSTR: u32 = 99;
    pub const EPROTO: u32 = 100;
    pub const ETIME: u32 = 101;
    pub const EOPNOTSUPP: u32 = 102;
    pub const ENOPOLICY: u32 = 103;
    pub const ENOTRECOVERABLE: u32 = 104;
    pub const EOWNERDEAD: u32 = 105;
    pub const EQFULL: u32 = 106;
    pub const ELAST: u32 = 106;
    pub const __PRI_8_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"hh\0";
    pub const __PRI_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
    pub const __SCN_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
    pub const __PRI_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
    pub const __SCN_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
    pub const PRId8: &'static [u8; 4usize] = b"hhd\0";
    pub const PRIi8: &'static [u8; 4usize] = b"hhi\0";
    pub const PRIo8: &'static [u8; 4usize] = b"hho\0";
    pub const PRIu8: &'static [u8; 4usize] = b"hhu\0";
    pub const PRIx8: &'static [u8; 4usize] = b"hhx\0";
    pub const PRIX8: &'static [u8; 4usize] = b"hhX\0";
    pub const PRId16: &'static [u8; 3usize] = b"hd\0";
    pub const PRIi16: &'static [u8; 3usize] = b"hi\0";
    pub const PRIo16: &'static [u8; 3usize] = b"ho\0";
    pub const PRIu16: &'static [u8; 3usize] = b"hu\0";
    pub const PRIx16: &'static [u8; 3usize] = b"hx\0";
    pub const PRIX16: &'static [u8; 3usize] = b"hX\0";
    pub const PRId32: &'static [u8; 2usize] = b"d\0";
    pub const PRIi32: &'static [u8; 2usize] = b"i\0";
    pub const PRIo32: &'static [u8; 2usize] = b"o\0";
    pub const PRIu32: &'static [u8; 2usize] = b"u\0";
    pub const PRIx32: &'static [u8; 2usize] = b"x\0";
    pub const PRIX32: &'static [u8; 2usize] = b"X\0";
    pub const PRId64: &'static [u8; 4usize] = b"lld\0";
    pub const PRIi64: &'static [u8; 4usize] = b"lli\0";
    pub const PRIo64: &'static [u8; 4usize] = b"llo\0";
    pub const PRIu64: &'static [u8; 4usize] = b"llu\0";
    pub const PRIx64: &'static [u8; 4usize] = b"llx\0";
    pub const PRIX64: &'static [u8; 4usize] = b"llX\0";
    pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\0";
    pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\0";
    pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\0";
    pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\0";
    pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\0";
    pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\0";
    pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\0";
    pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\0";
    pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\0";
    pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\0";
    pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\0";
    pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\0";
    pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
    pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
    pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
    pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
    pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
    pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
    pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\0";
    pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\0";
    pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\0";
    pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\0";
    pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\0";
    pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\0";
    pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\0";
    pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\0";
    pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\0";
    pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\0";
    pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\0";
    pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\0";
    pub const PRIdFAST16: &'static [u8; 3usize] = b"hd\0";
    pub const PRIiFAST16: &'static [u8; 3usize] = b"hi\0";
    pub const PRIoFAST16: &'static [u8; 3usize] = b"ho\0";
    pub const PRIuFAST16: &'static [u8; 3usize] = b"hu\0";
    pub const PRIxFAST16: &'static [u8; 3usize] = b"hx\0";
    pub const PRIXFAST16: &'static [u8; 3usize] = b"hX\0";
    pub const PRIdFAST32: &'static [u8; 2usize] = b"d\0";
    pub const PRIiFAST32: &'static [u8; 2usize] = b"i\0";
    pub const PRIoFAST32: &'static [u8; 2usize] = b"o\0";
    pub const PRIuFAST32: &'static [u8; 2usize] = b"u\0";
    pub const PRIxFAST32: &'static [u8; 2usize] = b"x\0";
    pub const PRIXFAST32: &'static [u8; 2usize] = b"X\0";
    pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\0";
    pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\0";
    pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\0";
    pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\0";
    pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\0";
    pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\0";
    pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
    pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
    pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
    pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
    pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
    pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
    pub const PRIdMAX: &'static [u8; 3usize] = b"jd\0";
    pub const PRIiMAX: &'static [u8; 3usize] = b"ji\0";
    pub const PRIoMAX: &'static [u8; 3usize] = b"jo\0";
    pub const PRIuMAX: &'static [u8; 3usize] = b"ju\0";
    pub const PRIxMAX: &'static [u8; 3usize] = b"jx\0";
    pub const PRIXMAX: &'static [u8; 3usize] = b"jX\0";
    pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
    pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
    pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
    pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
    pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
    pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
    pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
    pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
    pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
    pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
    pub const SCNd32: &'static [u8; 2usize] = b"d\0";
    pub const SCNi32: &'static [u8; 2usize] = b"i\0";
    pub const SCNo32: &'static [u8; 2usize] = b"o\0";
    pub const SCNu32: &'static [u8; 2usize] = b"u\0";
    pub const SCNx32: &'static [u8; 2usize] = b"x\0";
    pub const SCNd64: &'static [u8; 4usize] = b"lld\0";
    pub const SCNi64: &'static [u8; 4usize] = b"lli\0";
    pub const SCNo64: &'static [u8; 4usize] = b"llo\0";
    pub const SCNu64: &'static [u8; 4usize] = b"llu\0";
    pub const SCNx64: &'static [u8; 4usize] = b"llx\0";
    pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
    pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
    pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
    pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
    pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
    pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
    pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
    pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
    pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
    pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
    pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
    pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
    pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
    pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
    pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
    pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\0";
    pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\0";
    pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\0";
    pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\0";
    pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\0";
    pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
    pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
    pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
    pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
    pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
    pub const SCNdFAST16: &'static [u8; 3usize] = b"hd\0";
    pub const SCNiFAST16: &'static [u8; 3usize] = b"hi\0";
    pub const SCNoFAST16: &'static [u8; 3usize] = b"ho\0";
    pub const SCNuFAST16: &'static [u8; 3usize] = b"hu\0";
    pub const SCNxFAST16: &'static [u8; 3usize] = b"hx\0";
    pub const SCNdFAST32: &'static [u8; 2usize] = b"d\0";
    pub const SCNiFAST32: &'static [u8; 2usize] = b"i\0";
    pub const SCNoFAST32: &'static [u8; 2usize] = b"o\0";
    pub const SCNuFAST32: &'static [u8; 2usize] = b"u\0";
    pub const SCNxFAST32: &'static [u8; 2usize] = b"x\0";
    pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\0";
    pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\0";
    pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\0";
    pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\0";
    pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\0";
    pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
    pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
    pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
    pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
    pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
    pub const SCNdMAX: &'static [u8; 3usize] = b"jd\0";
    pub const SCNiMAX: &'static [u8; 3usize] = b"ji\0";
    pub const SCNoMAX: &'static [u8; 3usize] = b"jo\0";
    pub const SCNuMAX: &'static [u8; 3usize] = b"ju\0";
    pub const SCNxMAX: &'static [u8; 3usize] = b"jx\0";
    pub const __API_TO_BE_DEPRECATED: u32 = 100000;
    pub const __MAC_10_0: u32 = 1000;
    pub const __MAC_10_1: u32 = 1010;
    pub const __MAC_10_2: u32 = 1020;
    pub const __MAC_10_3: u32 = 1030;
    pub const __MAC_10_4: u32 = 1040;
    pub const __MAC_10_5: u32 = 1050;
    pub const __MAC_10_6: u32 = 1060;
    pub const __MAC_10_7: u32 = 1070;
    pub const __MAC_10_8: u32 = 1080;
    pub const __MAC_10_9: u32 = 1090;
    pub const __MAC_10_10: u32 = 101000;
    pub const __MAC_10_10_2: u32 = 101002;
    pub const __MAC_10_10_3: u32 = 101003;
    pub const __MAC_10_11: u32 = 101100;
    pub const __MAC_10_11_2: u32 = 101102;
    pub const __MAC_10_11_3: u32 = 101103;
    pub const __MAC_10_11_4: u32 = 101104;
    pub const __MAC_10_12: u32 = 101200;
    pub const __MAC_10_12_1: u32 = 101201;
    pub const __MAC_10_12_2: u32 = 101202;
    pub const __MAC_10_12_4: u32 = 101204;
    pub const __MAC_10_13: u32 = 101300;
    pub const __MAC_10_13_1: u32 = 101301;
    pub const __MAC_10_13_2: u32 = 101302;
    pub const __MAC_10_13_4: u32 = 101304;
    pub const __MAC_10_14: u32 = 101400;
    pub const __MAC_10_14_1: u32 = 101401;
    pub const __MAC_10_14_4: u32 = 101404;
    pub const __MAC_10_14_6: u32 = 101406;
    pub const __MAC_10_15: u32 = 101500;
    pub const __MAC_10_15_1: u32 = 101501;
    pub const __MAC_10_15_4: u32 = 101504;
    pub const __MAC_10_16: u32 = 101600;
    pub const __MAC_11_0: u32 = 110000;
    pub const __MAC_11_1: u32 = 110100;
    pub const __MAC_11_3: u32 = 110300;
    pub const __MAC_11_4: u32 = 110400;
    pub const __MAC_11_5: u32 = 110500;
    pub const __MAC_12_0: u32 = 120000;
    pub const __IPHONE_2_0: u32 = 20000;
    pub const __IPHONE_2_1: u32 = 20100;
    pub const __IPHONE_2_2: u32 = 20200;
    pub const __IPHONE_3_0: u32 = 30000;
    pub const __IPHONE_3_1: u32 = 30100;
    pub const __IPHONE_3_2: u32 = 30200;
    pub const __IPHONE_4_0: u32 = 40000;
    pub const __IPHONE_4_1: u32 = 40100;
    pub const __IPHONE_4_2: u32 = 40200;
    pub const __IPHONE_4_3: u32 = 40300;
    pub const __IPHONE_5_0: u32 = 50000;
    pub const __IPHONE_5_1: u32 = 50100;
    pub const __IPHONE_6_0: u32 = 60000;
    pub const __IPHONE_6_1: u32 = 60100;
    pub const __IPHONE_7_0: u32 = 70000;
    pub const __IPHONE_7_1: u32 = 70100;
    pub const __IPHONE_8_0: u32 = 80000;
    pub const __IPHONE_8_1: u32 = 80100;
    pub const __IPHONE_8_2: u32 = 80200;
    pub const __IPHONE_8_3: u32 = 80300;
    pub const __IPHONE_8_4: u32 = 80400;
    pub const __IPHONE_9_0: u32 = 90000;
    pub const __IPHONE_9_1: u32 = 90100;
    pub const __IPHONE_9_2: u32 = 90200;
    pub const __IPHONE_9_3: u32 = 90300;
    pub const __IPHONE_10_0: u32 = 100000;
    pub const __IPHONE_10_1: u32 = 100100;
    pub const __IPHONE_10_2: u32 = 100200;
    pub const __IPHONE_10_3: u32 = 100300;
    pub const __IPHONE_11_0: u32 = 110000;
    pub const __IPHONE_11_1: u32 = 110100;
    pub const __IPHONE_11_2: u32 = 110200;
    pub const __IPHONE_11_3: u32 = 110300;
    pub const __IPHONE_11_4: u32 = 110400;
    pub const __IPHONE_12_0: u32 = 120000;
    pub const __IPHONE_12_1: u32 = 120100;
    pub const __IPHONE_12_2: u32 = 120200;
    pub const __IPHONE_12_3: u32 = 120300;
    pub const __IPHONE_12_4: u32 = 120400;
    pub const __IPHONE_13_0: u32 = 130000;
    pub const __IPHONE_13_1: u32 = 130100;
    pub const __IPHONE_13_2: u32 = 130200;
    pub const __IPHONE_13_3: u32 = 130300;
    pub const __IPHONE_13_4: u32 = 130400;
    pub const __IPHONE_13_5: u32 = 130500;
    pub const __IPHONE_13_6: u32 = 130600;
    pub const __IPHONE_13_7: u32 = 130700;
    pub const __IPHONE_14_0: u32 = 140000;
    pub const __IPHONE_14_1: u32 = 140100;
    pub const __IPHONE_14_2: u32 = 140200;
    pub const __IPHONE_14_3: u32 = 140300;
    pub const __IPHONE_14_5: u32 = 140500;
    pub const __IPHONE_14_6: u32 = 140600;
    pub const __IPHONE_14_7: u32 = 140700;
    pub const __IPHONE_14_8: u32 = 140800;
    pub const __IPHONE_15_0: u32 = 150000;
    pub const __TVOS_9_0: u32 = 90000;
    pub const __TVOS_9_1: u32 = 90100;
    pub const __TVOS_9_2: u32 = 90200;
    pub const __TVOS_10_0: u32 = 100000;
    pub const __TVOS_10_0_1: u32 = 100001;
    pub const __TVOS_10_1: u32 = 100100;
    pub const __TVOS_10_2: u32 = 100200;
    pub const __TVOS_11_0: u32 = 110000;
    pub const __TVOS_11_1: u32 = 110100;
    pub const __TVOS_11_2: u32 = 110200;
    pub const __TVOS_11_3: u32 = 110300;
    pub const __TVOS_11_4: u32 = 110400;
    pub const __TVOS_12_0: u32 = 120000;
    pub const __TVOS_12_1: u32 = 120100;
    pub const __TVOS_12_2: u32 = 120200;
    pub const __TVOS_12_3: u32 = 120300;
    pub const __TVOS_12_4: u32 = 120400;
    pub const __TVOS_13_0: u32 = 130000;
    pub const __TVOS_13_2: u32 = 130200;
    pub const __TVOS_13_3: u32 = 130300;
    pub const __TVOS_13_4: u32 = 130400;
    pub const __TVOS_14_0: u32 = 140000;
    pub const __TVOS_14_1: u32 = 140100;
    pub const __TVOS_14_2: u32 = 140200;
    pub const __TVOS_14_3: u32 = 140300;
    pub const __TVOS_14_5: u32 = 140500;
    pub const __TVOS_14_6: u32 = 140600;
    pub const __TVOS_14_7: u32 = 140700;
    pub const __TVOS_15_0: u32 = 150000;
    pub const __WATCHOS_1_0: u32 = 10000;
    pub const __WATCHOS_2_0: u32 = 20000;
    pub const __WATCHOS_2_1: u32 = 20100;
    pub const __WATCHOS_2_2: u32 = 20200;
    pub const __WATCHOS_3_0: u32 = 30000;
    pub const __WATCHOS_3_1: u32 = 30100;
    pub const __WATCHOS_3_1_1: u32 = 30101;
    pub const __WATCHOS_3_2: u32 = 30200;
    pub const __WATCHOS_4_0: u32 = 40000;
    pub const __WATCHOS_4_1: u32 = 40100;
    pub const __WATCHOS_4_2: u32 = 40200;
    pub const __WATCHOS_4_3: u32 = 40300;
    pub const __WATCHOS_5_0: u32 = 50000;
    pub const __WATCHOS_5_1: u32 = 50100;
    pub const __WATCHOS_5_2: u32 = 50200;
    pub const __WATCHOS_5_3: u32 = 50300;
    pub const __WATCHOS_6_0: u32 = 60000;
    pub const __WATCHOS_6_1: u32 = 60100;
    pub const __WATCHOS_6_2: u32 = 60200;
    pub const __WATCHOS_7_0: u32 = 70000;
    pub const __WATCHOS_7_1: u32 = 70100;
    pub const __WATCHOS_7_2: u32 = 70200;
    pub const __WATCHOS_7_3: u32 = 70300;
    pub const __WATCHOS_7_4: u32 = 70400;
    pub const __WATCHOS_7_5: u32 = 70500;
    pub const __WATCHOS_7_6: u32 = 70600;
    pub const __WATCHOS_8_0: u32 = 80000;
    pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
    pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
    pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
    pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
    pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
    pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
    pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
    pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
    pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
    pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
    pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
    pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
    pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
    pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
    pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
    pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
    pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
    pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
    pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
    pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
    pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
    pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
    pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
    pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
    pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
    pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
    pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
    pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
    pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
    pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
    pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
    pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
    pub const MAC_OS_VERSION_11_0: u32 = 110000;
    pub const MAC_OS_VERSION_12_0: u32 = 120000;
    pub const __DRIVERKIT_19_0: u32 = 190000;
    pub const __DRIVERKIT_20_0: u32 = 200000;
    pub const __DRIVERKIT_21_0: u32 = 210000;
    pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120000;
    pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
    pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
    pub const _FORTIFY_SOURCE: u32 = 2;
    pub const __DARWIN_CLK_TCK: u32 = 100;
    pub const CHAR_BIT: u32 = 8;
    pub const MB_LEN_MAX: u32 = 6;
    pub const CLK_TCK: u32 = 100;
    pub const SCHAR_MAX: u32 = 127;
    pub const SCHAR_MIN: i32 = -128;
    pub const UCHAR_MAX: u32 = 255;
    pub const CHAR_MAX: u32 = 127;
    pub const CHAR_MIN: i32 = -128;
    pub const USHRT_MAX: u32 = 65535;
    pub const SHRT_MAX: u32 = 32767;
    pub const SHRT_MIN: i32 = -32768;
    pub const UINT_MAX: u32 = 4294967295;
    pub const INT_MAX: u32 = 2147483647;
    pub const INT_MIN: i32 = -2147483648;
    pub const ULONG_MAX: i32 = -1;
    pub const LONG_MAX: u64 = 9223372036854775807;
    pub const LONG_MIN: i64 = -9223372036854775808;
    pub const ULLONG_MAX: i32 = -1;
    pub const LLONG_MAX: u64 = 9223372036854775807;
    pub const LLONG_MIN: i64 = -9223372036854775808;
    pub const LONG_BIT: u32 = 64;
    pub const SSIZE_MAX: u64 = 9223372036854775807;
    pub const WORD_BIT: u32 = 32;
    pub const SIZE_T_MAX: i32 = -1;
    pub const UQUAD_MAX: i32 = -1;
    pub const QUAD_MAX: u64 = 9223372036854775807;
    pub const QUAD_MIN: i64 = -9223372036854775808;
    pub const ARG_MAX: u32 = 1048576;
    pub const CHILD_MAX: u32 = 266;
    pub const GID_MAX: u32 = 2147483647;
    pub const LINK_MAX: u32 = 32767;
    pub const MAX_CANON: u32 = 1024;
    pub const MAX_INPUT: u32 = 1024;
    pub const NAME_MAX: u32 = 255;
    pub const NGROUPS_MAX: u32 = 16;
    pub const UID_MAX: u32 = 2147483647;
    pub const OPEN_MAX: u32 = 10240;
    pub const PATH_MAX: u32 = 1024;
    pub const PIPE_BUF: u32 = 512;
    pub const BC_BASE_MAX: u32 = 99;
    pub const BC_DIM_MAX: u32 = 2048;
    pub const BC_SCALE_MAX: u32 = 99;
    pub const BC_STRING_MAX: u32 = 1000;
    pub const CHARCLASS_NAME_MAX: u32 = 14;
    pub const COLL_WEIGHTS_MAX: u32 = 2;
    pub const EQUIV_CLASS_MAX: u32 = 2;
    pub const EXPR_NEST_MAX: u32 = 32;
    pub const LINE_MAX: u32 = 2048;
    pub const RE_DUP_MAX: u32 = 255;
    pub const NZERO: u32 = 20;
    pub const _POSIX_ARG_MAX: u32 = 4096;
    pub const _POSIX_CHILD_MAX: u32 = 25;
    pub const _POSIX_LINK_MAX: u32 = 8;
    pub const _POSIX_MAX_CANON: u32 = 255;
    pub const _POSIX_MAX_INPUT: u32 = 255;
    pub const _POSIX_NAME_MAX: u32 = 14;
    pub const _POSIX_NGROUPS_MAX: u32 = 8;
    pub const _POSIX_OPEN_MAX: u32 = 20;
    pub const _POSIX_PATH_MAX: u32 = 256;
    pub const _POSIX_PIPE_BUF: u32 = 512;
    pub const _POSIX_SSIZE_MAX: u32 = 32767;
    pub const _POSIX_STREAM_MAX: u32 = 8;
    pub const _POSIX_TZNAME_MAX: u32 = 6;
    pub const _POSIX2_BC_BASE_MAX: u32 = 99;
    pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
    pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
    pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
    pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
    pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
    pub const _POSIX2_LINE_MAX: u32 = 2048;
    pub const _POSIX2_RE_DUP_MAX: u32 = 255;
    pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
    pub const _POSIX_AIO_MAX: u32 = 1;
    pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
    pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
    pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
    pub const _POSIX_RTSIG_MAX: u32 = 8;
    pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
    pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
    pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
    pub const _POSIX_TIMER_MAX: u32 = 32;
    pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
    pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
    pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
    pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
    pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
    pub const PTHREAD_KEYS_MAX: u32 = 512;
    pub const PTHREAD_STACK_MIN: u32 = 16384;
    pub const _POSIX_HOST_NAME_MAX: u32 = 255;
    pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
    pub const _POSIX_SS_REPL_MAX: u32 = 4;
    pub const _POSIX_SYMLINK_MAX: u32 = 255;
    pub const _POSIX_SYMLOOP_MAX: u32 = 8;
    pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
    pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
    pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
    pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
    pub const _POSIX_TTY_NAME_MAX: u32 = 9;
    pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
    pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
    pub const _POSIX_RE_DUP_MAX: u32 = 255;
    pub const OFF_MIN: i64 = -9223372036854775808;
    pub const OFF_MAX: u64 = 9223372036854775807;
    pub const PASS_MAX: u32 = 128;
    pub const NL_ARGMAX: u32 = 9;
    pub const NL_LANGMAX: u32 = 14;
    pub const NL_MSGMAX: u32 = 32767;
    pub const NL_NMAX: u32 = 1;
    pub const NL_SETMAX: u32 = 255;
    pub const NL_TEXTMAX: u32 = 2048;
    pub const _XOPEN_IOV_MAX: u32 = 16;
    pub const IOV_MAX: u32 = 1024;
    pub const _XOPEN_NAME_MAX: u32 = 255;
    pub const _XOPEN_PATH_MAX: u32 = 1024;
    pub const FP_SUPERNORMAL: u32 = 6;
    pub const FP_FAST_FMA: u32 = 1;
    pub const FP_FAST_FMAF: u32 = 1;
    pub const FP_FAST_FMAL: u32 = 1;
    pub const FP_ILOGB0: i32 = -2147483648;
    pub const FP_ILOGBNAN: i32 = -2147483648;
    pub const MATH_ERRNO: u32 = 1;
    pub const MATH_ERREXCEPT: u32 = 2;
    pub const M_E: f64 = 2.718281828459045;
    pub const M_LOG2E: f64 = 1.4426950408889634;
    pub const M_LOG10E: f64 = 0.4342944819032518;
    pub const M_LN2: f64 = 0.6931471805599453;
    pub const M_LN10: f64 = 2.302585092994046;
    pub const M_PI: f64 = 3.141592653589793;
    pub const M_PI_2: f64 = 1.5707963267948966;
    pub const M_PI_4: f64 = 0.7853981633974483;
    pub const M_1_PI: f64 = 0.3183098861837907;
    pub const M_2_PI: f64 = 0.6366197723675814;
    pub const M_2_SQRTPI: f64 = 1.1283791670955126;
    pub const M_SQRT2: f64 = 1.4142135623730951;
    pub const M_SQRT1_2: f64 = 0.7071067811865476;
    pub const DOMAIN: u32 = 1;
    pub const SING: u32 = 2;
    pub const OVERFLOW: u32 = 3;
    pub const UNDERFLOW: u32 = 4;
    pub const TLOSS: u32 = 5;
    pub const PLOSS: u32 = 6;
    pub const RENAME_SECLUDE: u32 = 1;
    pub const RENAME_SWAP: u32 = 2;
    pub const RENAME_EXCL: u32 = 4;
    pub const __SLBF: u32 = 1;
    pub const __SNBF: u32 = 2;
    pub const __SRD: u32 = 4;
    pub const __SWR: u32 = 8;
    pub const __SRW: u32 = 16;
    pub const __SEOF: u32 = 32;
    pub const __SERR: u32 = 64;
    pub const __SMBF: u32 = 128;
    pub const __SAPP: u32 = 256;
    pub const __SSTR: u32 = 512;
    pub const __SOPT: u32 = 1024;
    pub const __SNPT: u32 = 2048;
    pub const __SOFF: u32 = 4096;
    pub const __SMOD: u32 = 8192;
    pub const __SALC: u32 = 16384;
    pub const __SIGN: u32 = 32768;
    pub const _IOFBF: u32 = 0;
    pub const _IOLBF: u32 = 1;
    pub const _IONBF: u32 = 2;
    pub const BUFSIZ: u32 = 1024;
    pub const EOF: i32 = -1;
    pub const FOPEN_MAX: u32 = 20;
    pub const FILENAME_MAX: u32 = 1024;
    pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
    pub const L_tmpnam: u32 = 1024;
    pub const TMP_MAX: u32 = 308915776;
    pub const SEEK_SET: u32 = 0;
    pub const SEEK_CUR: u32 = 1;
    pub const SEEK_END: u32 = 2;
    pub const L_ctermid: u32 = 1024;
    pub const _USE_FORTIFY_LEVEL: u32 = 2;
    pub const __DARWIN_NSIG: u32 = 32;
    pub const NSIG: u32 = 32;
    pub const _ARM_SIGNAL_: u32 = 1;
    pub const SIGHUP: u32 = 1;
    pub const SIGINT: u32 = 2;
    pub const SIGQUIT: u32 = 3;
    pub const SIGILL: u32 = 4;
    pub const SIGTRAP: u32 = 5;
    pub const SIGABRT: u32 = 6;
    pub const SIGIOT: u32 = 6;
    pub const SIGEMT: u32 = 7;
    pub const SIGFPE: u32 = 8;
    pub const SIGKILL: u32 = 9;
    pub const SIGBUS: u32 = 10;
    pub const SIGSEGV: u32 = 11;
    pub const SIGSYS: u32 = 12;
    pub const SIGPIPE: u32 = 13;
    pub const SIGALRM: u32 = 14;
    pub const SIGTERM: u32 = 15;
    pub const SIGURG: u32 = 16;
    pub const SIGSTOP: u32 = 17;
    pub const SIGTSTP: u32 = 18;
    pub const SIGCONT: u32 = 19;
    pub const SIGCHLD: u32 = 20;
    pub const SIGTTIN: u32 = 21;
    pub const SIGTTOU: u32 = 22;
    pub const SIGIO: u32 = 23;
    pub const SIGXCPU: u32 = 24;
    pub const SIGXFSZ: u32 = 25;
    pub const SIGVTALRM: u32 = 26;
    pub const SIGPROF: u32 = 27;
    pub const SIGWINCH: u32 = 28;
    pub const SIGINFO: u32 = 29;
    pub const SIGUSR1: u32 = 30;
    pub const SIGUSR2: u32 = 31;
    pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
    pub const SIGEV_NONE: u32 = 0;
    pub const SIGEV_SIGNAL: u32 = 1;
    pub const SIGEV_THREAD: u32 = 3;
    pub const ILL_NOOP: u32 = 0;
    pub const ILL_ILLOPC: u32 = 1;
    pub const ILL_ILLTRP: u32 = 2;
    pub const ILL_PRVOPC: u32 = 3;
    pub const ILL_ILLOPN: u32 = 4;
    pub const ILL_ILLADR: u32 = 5;
    pub const ILL_PRVREG: u32 = 6;
    pub const ILL_COPROC: u32 = 7;
    pub const ILL_BADSTK: u32 = 8;
    pub const FPE_NOOP: u32 = 0;
    pub const FPE_FLTDIV: u32 = 1;
    pub const FPE_FLTOVF: u32 = 2;
    pub const FPE_FLTUND: u32 = 3;
    pub const FPE_FLTRES: u32 = 4;
    pub const FPE_FLTINV: u32 = 5;
    pub const FPE_FLTSUB: u32 = 6;
    pub const FPE_INTDIV: u32 = 7;
    pub const FPE_INTOVF: u32 = 8;
    pub const SEGV_NOOP: u32 = 0;
    pub const SEGV_MAPERR: u32 = 1;
    pub const SEGV_ACCERR: u32 = 2;
    pub const BUS_NOOP: u32 = 0;
    pub const BUS_ADRALN: u32 = 1;
    pub const BUS_ADRERR: u32 = 2;
    pub const BUS_OBJERR: u32 = 3;
    pub const TRAP_BRKPT: u32 = 1;
    pub const TRAP_TRACE: u32 = 2;
    pub const CLD_NOOP: u32 = 0;
    pub const CLD_EXITED: u32 = 1;
    pub const CLD_KILLED: u32 = 2;
    pub const CLD_DUMPED: u32 = 3;
    pub const CLD_TRAPPED: u32 = 4;
    pub const CLD_STOPPED: u32 = 5;
    pub const CLD_CONTINUED: u32 = 6;
    pub const POLL_IN: u32 = 1;
    pub const POLL_OUT: u32 = 2;
    pub const POLL_MSG: u32 = 3;
    pub const POLL_ERR: u32 = 4;
    pub const POLL_PRI: u32 = 5;
    pub const POLL_HUP: u32 = 6;
    pub const SA_ONSTACK: u32 = 1;
    pub const SA_RESTART: u32 = 2;
    pub const SA_RESETHAND: u32 = 4;
    pub const SA_NOCLDSTOP: u32 = 8;
    pub const SA_NODEFER: u32 = 16;
    pub const SA_NOCLDWAIT: u32 = 32;
    pub const SA_SIGINFO: u32 = 64;
    pub const SA_USERTRAMP: u32 = 256;
    pub const SA_64REGSET: u32 = 512;
    pub const SA_USERSPACE_MASK: u32 = 127;
    pub const SIG_BLOCK: u32 = 1;
    pub const SIG_UNBLOCK: u32 = 2;
    pub const SIG_SETMASK: u32 = 3;
    pub const SI_USER: u32 = 65537;
    pub const SI_QUEUE: u32 = 65538;
    pub const SI_TIMER: u32 = 65539;
    pub const SI_ASYNCIO: u32 = 65540;
    pub const SI_MESGQ: u32 = 65541;
    pub const SS_ONSTACK: u32 = 1;
    pub const SS_DISABLE: u32 = 4;
    pub const MINSIGSTKSZ: u32 = 32768;
    pub const SIGSTKSZ: u32 = 131072;
    pub const SV_ONSTACK: u32 = 1;
    pub const SV_INTERRUPT: u32 = 2;
    pub const SV_RESETHAND: u32 = 4;
    pub const SV_NODEFER: u32 = 16;
    pub const SV_NOCLDSTOP: u32 = 8;
    pub const SV_SIGINFO: u32 = 64;
    pub const PRIO_PROCESS: u32 = 0;
    pub const PRIO_PGRP: u32 = 1;
    pub const PRIO_USER: u32 = 2;
    pub const PRIO_DARWIN_THREAD: u32 = 3;
    pub const PRIO_DARWIN_PROCESS: u32 = 4;
    pub const PRIO_MIN: i32 = -20;
    pub const PRIO_MAX: u32 = 20;
    pub const PRIO_DARWIN_BG: u32 = 4096;
    pub const PRIO_DARWIN_NONUI: u32 = 4097;
    pub const RUSAGE_SELF: u32 = 0;
    pub const RUSAGE_CHILDREN: i32 = -1;
    pub const RUSAGE_INFO_V0: u32 = 0;
    pub const RUSAGE_INFO_V1: u32 = 1;
    pub const RUSAGE_INFO_V2: u32 = 2;
    pub const RUSAGE_INFO_V3: u32 = 3;
    pub const RUSAGE_INFO_V4: u32 = 4;
    pub const RUSAGE_INFO_V5: u32 = 5;
    pub const RUSAGE_INFO_CURRENT: u32 = 5;
    pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
    pub const RLIMIT_CPU: u32 = 0;
    pub const RLIMIT_FSIZE: u32 = 1;
    pub const RLIMIT_DATA: u32 = 2;
    pub const RLIMIT_STACK: u32 = 3;
    pub const RLIMIT_CORE: u32 = 4;
    pub const RLIMIT_AS: u32 = 5;
    pub const RLIMIT_RSS: u32 = 5;
    pub const RLIMIT_MEMLOCK: u32 = 6;
    pub const RLIMIT_NPROC: u32 = 7;
    pub const RLIMIT_NOFILE: u32 = 8;
    pub const RLIM_NLIMITS: u32 = 9;
    pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
    pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
    pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
    pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
    pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
    pub const WAKEMON_ENABLE: u32 = 1;
    pub const WAKEMON_DISABLE: u32 = 2;
    pub const WAKEMON_GET_PARAMS: u32 = 4;
    pub const WAKEMON_SET_DEFAULTS: u32 = 8;
    pub const WAKEMON_MAKE_FATAL: u32 = 16;
    pub const CPUMON_MAKE_FATAL: u32 = 4096;
    pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
    pub const IOPOL_TYPE_DISK: u32 = 0;
    pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
    pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
    pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
    pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
    pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
    pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
    pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
    pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
    pub const IOPOL_SCOPE_PROCESS: u32 = 0;
    pub const IOPOL_SCOPE_THREAD: u32 = 1;
    pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
    pub const IOPOL_DEFAULT: u32 = 0;
    pub const IOPOL_IMPORTANT: u32 = 1;
    pub const IOPOL_PASSIVE: u32 = 2;
    pub const IOPOL_THROTTLE: u32 = 3;
    pub const IOPOL_UTILITY: u32 = 4;
    pub const IOPOL_STANDARD: u32 = 5;
    pub const IOPOL_APPLICATION: u32 = 5;
    pub const IOPOL_NORMAL: u32 = 1;
    pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
    pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
    pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
    pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
    pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
    pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
    pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
    pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
    pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
    pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
    pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
    pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
    pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
    pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
    pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
    pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
    pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
    pub const WNOHANG: u32 = 1;
    pub const WUNTRACED: u32 = 2;
    pub const WCOREFLAG: u32 = 128;
    pub const _WSTOPPED: u32 = 127;
    pub const WEXITED: u32 = 4;
    pub const WSTOPPED: u32 = 8;
    pub const WCONTINUED: u32 = 16;
    pub const WNOWAIT: u32 = 32;
    pub const WAIT_ANY: i32 = -1;
    pub const WAIT_MYPGRP: u32 = 0;
    pub const _QUAD_HIGHWORD: u32 = 1;
    pub const _QUAD_LOWWORD: u32 = 0;
    pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
    pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
    pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
    pub const __DARWIN_BYTE_ORDER: u32 = 1234;
    pub const LITTLE_ENDIAN: u32 = 1234;
    pub const BIG_ENDIAN: u32 = 4321;
    pub const PDP_ENDIAN: u32 = 3412;
    pub const BYTE_ORDER: u32 = 1234;
    pub const EXIT_FAILURE: u32 = 1;
    pub const EXIT_SUCCESS: u32 = 0;
    pub const RAND_MAX: u32 = 2147483647;
    pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
    pub const AV_HAVE_BIGENDIAN: u32 = 0;
    pub const AV_HAVE_FAST_UNALIGNED: u32 = 0;
    pub const LIBAVUTIL_VERSION_MAJOR: u32 = 57;
    pub const LIBAVUTIL_VERSION_MINOR: u32 = 7;
    pub const LIBAVUTIL_VERSION_MICRO: u32 = 100;
    pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
    pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
    pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
    pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
    pub const M_LOG2_10: f64 = 3.321928094887362;
    pub const M_PHI: f64 = 1.618033988749895;
    pub const __GNUC_VA_LIST: u32 = 1;
    pub const AV_LOG_QUIET: i32 = -8;
    pub const AV_LOG_PANIC: u32 = 0;
    pub const AV_LOG_FATAL: u32 = 8;
    pub const AV_LOG_ERROR: u32 = 16;
    pub const AV_LOG_WARNING: u32 = 24;
    pub const AV_LOG_INFO: u32 = 32;
    pub const AV_LOG_VERBOSE: u32 = 40;
    pub const AV_LOG_DEBUG: u32 = 48;
    pub const AV_LOG_TRACE: u32 = 56;
    pub const AV_LOG_MAX_OFFSET: u32 = 64;
    pub const AV_LOG_SKIP_REPEATED: u32 = 1;
    pub const AV_LOG_PRINT_LEVEL: u32 = 2;
    pub const AVPALETTE_SIZE: u32 = 1024;
    pub const AVPALETTE_COUNT: u32 = 256;
    pub const AV_FOURCC_MAX_STRING_SIZE: u32 = 32;
    pub const AV_DICT_MATCH_CASE: u32 = 1;
    pub const AV_DICT_IGNORE_SUFFIX: u32 = 2;
    pub const AV_DICT_DONT_STRDUP_KEY: u32 = 4;
    pub const AV_DICT_DONT_STRDUP_VAL: u32 = 8;
    pub const AV_DICT_DONT_OVERWRITE: u32 = 16;
    pub const AV_DICT_APPEND: u32 = 32;
    pub const AV_DICT_MULTIKEY: u32 = 64;
    pub const AV_NUM_DATA_POINTERS: u32 = 8;
    pub const AV_FRAME_FLAG_CORRUPT: u32 = 1;
    pub const AV_FRAME_FLAG_DISCARD: u32 = 4;
    pub const FF_DECODE_ERROR_INVALID_BITSTREAM: u32 = 1;
    pub const FF_DECODE_ERROR_MISSING_REFERENCE: u32 = 2;
    pub const FF_DECODE_ERROR_CONCEALMENT_ACTIVE: u32 = 4;
    pub const FF_DECODE_ERROR_DECODE_SLICES: u32 = 8;
    pub const AV_DETECTION_BBOX_LABEL_NAME_MAX_SIZE: u32 = 64;
    pub const AV_NUM_DETECTION_BBOX_CLASSIFY: u32 = 4;
    pub const AV_BF_ROUNDS: u32 = 16;
    pub const AV_STEREO3D_FLAG_INVERT: u32 = 1;
    pub const AV_PIX_FMT_FLAG_BE: u32 = 1;
    pub const AV_PIX_FMT_FLAG_PAL: u32 = 2;
    pub const AV_PIX_FMT_FLAG_BITSTREAM: u32 = 4;
    pub const AV_PIX_FMT_FLAG_HWACCEL: u32 = 8;
    pub const AV_PIX_FMT_FLAG_PLANAR: u32 = 16;
    pub const AV_PIX_FMT_FLAG_RGB: u32 = 32;
    pub const AV_PIX_FMT_FLAG_ALPHA: u32 = 128;
    pub const AV_PIX_FMT_FLAG_BAYER: u32 = 256;
    pub const AV_PIX_FMT_FLAG_FLOAT: u32 = 512;
    pub const FF_LOSS_RESOLUTION: u32 = 1;
    pub const FF_LOSS_DEPTH: u32 = 2;
    pub const FF_LOSS_COLORSPACE: u32 = 4;
    pub const FF_LOSS_ALPHA: u32 = 8;
    pub const FF_LOSS_COLORQUANT: u32 = 16;
    pub const FF_LOSS_CHROMA: u32 = 32;
    pub const FFMPEG_VERSION: &'static [u8; 21usize] = b"N-104486-g45dc668aea\0";
    pub const AV_TIMECODE_STR_SIZE: u32 = 23;
    pub const AV_OPT_FLAG_ENCODING_PARAM: u32 = 1;
    pub const AV_OPT_FLAG_DECODING_PARAM: u32 = 2;
    pub const AV_OPT_FLAG_AUDIO_PARAM: u32 = 8;
    pub const AV_OPT_FLAG_VIDEO_PARAM: u32 = 16;
    pub const AV_OPT_FLAG_SUBTITLE_PARAM: u32 = 32;
    pub const AV_OPT_FLAG_EXPORT: u32 = 64;
    pub const AV_OPT_FLAG_READONLY: u32 = 128;
    pub const AV_OPT_FLAG_BSF_PARAM: u32 = 256;
    pub const AV_OPT_FLAG_RUNTIME_PARAM: u32 = 32768;
    pub const AV_OPT_FLAG_FILTERING_PARAM: u32 = 65536;
    pub const AV_OPT_FLAG_DEPRECATED: u32 = 131072;
    pub const AV_OPT_FLAG_CHILD_CONSTS: u32 = 262144;
    pub const AV_OPT_SEARCH_CHILDREN: u32 = 1;
    pub const AV_OPT_SEARCH_FAKE_OBJ: u32 = 2;
    pub const AV_OPT_ALLOW_NULL: u32 = 4;
    pub const AV_OPT_MULTI_COMPONENT_RANGE: u32 = 4096;
    pub const AV_OPT_SERIALIZE_SKIP_DEFAULTS: u32 = 1;
    pub const AV_OPT_SERIALIZE_OPT_FLAGS_EXACT: u32 = 2;
    pub const AV_CPU_FLAG_FORCE: u32 = 2147483648;
    pub const AV_CPU_FLAG_MMX: u32 = 1;
    pub const AV_CPU_FLAG_MMXEXT: u32 = 2;
    pub const AV_CPU_FLAG_MMX2: u32 = 2;
    pub const AV_CPU_FLAG_3DNOW: u32 = 4;
    pub const AV_CPU_FLAG_SSE: u32 = 8;
    pub const AV_CPU_FLAG_SSE2: u32 = 16;
    pub const AV_CPU_FLAG_SSE2SLOW: u32 = 1073741824;
    pub const AV_CPU_FLAG_3DNOWEXT: u32 = 32;
    pub const AV_CPU_FLAG_SSE3: u32 = 64;
    pub const AV_CPU_FLAG_SSE3SLOW: u32 = 536870912;
    pub const AV_CPU_FLAG_SSSE3: u32 = 128;
    pub const AV_CPU_FLAG_SSSE3SLOW: u32 = 67108864;
    pub const AV_CPU_FLAG_ATOM: u32 = 268435456;
    pub const AV_CPU_FLAG_SSE4: u32 = 256;
    pub const AV_CPU_FLAG_SSE42: u32 = 512;
    pub const AV_CPU_FLAG_AESNI: u32 = 524288;
    pub const AV_CPU_FLAG_AVX: u32 = 16384;
    pub const AV_CPU_FLAG_AVXSLOW: u32 = 134217728;
    pub const AV_CPU_FLAG_XOP: u32 = 1024;
    pub const AV_CPU_FLAG_FMA4: u32 = 2048;
    pub const AV_CPU_FLAG_CMOV: u32 = 4096;
    pub const AV_CPU_FLAG_AVX2: u32 = 32768;
    pub const AV_CPU_FLAG_FMA3: u32 = 65536;
    pub const AV_CPU_FLAG_BMI1: u32 = 131072;
    pub const AV_CPU_FLAG_BMI2: u32 = 262144;
    pub const AV_CPU_FLAG_AVX512: u32 = 1048576;
    pub const AV_CPU_FLAG_ALTIVEC: u32 = 1;
    pub const AV_CPU_FLAG_VSX: u32 = 2;
    pub const AV_CPU_FLAG_POWER8: u32 = 4;
    pub const AV_CPU_FLAG_ARMV5TE: u32 = 1;
    pub const AV_CPU_FLAG_ARMV6: u32 = 2;
    pub const AV_CPU_FLAG_ARMV6T2: u32 = 4;
    pub const AV_CPU_FLAG_VFP: u32 = 8;
    pub const AV_CPU_FLAG_VFPV3: u32 = 16;
    pub const AV_CPU_FLAG_NEON: u32 = 32;
    pub const AV_CPU_FLAG_ARMV8: u32 = 64;
    pub const AV_CPU_FLAG_VFP_VM: u32 = 128;
    pub const AV_CPU_FLAG_SETEND: u32 = 65536;
    pub const AV_CPU_FLAG_MMI: u32 = 1;
    pub const AV_CPU_FLAG_MSA: u32 = 2;
    pub const AV_CH_FRONT_LEFT: u32 = 1;
    pub const AV_CH_FRONT_RIGHT: u32 = 2;
    pub const AV_CH_FRONT_CENTER: u32 = 4;
    pub const AV_CH_LOW_FREQUENCY: u32 = 8;
    pub const AV_CH_BACK_LEFT: u32 = 16;
    pub const AV_CH_BACK_RIGHT: u32 = 32;
    pub const AV_CH_FRONT_LEFT_OF_CENTER: u32 = 64;
    pub const AV_CH_FRONT_RIGHT_OF_CENTER: u32 = 128;
    pub const AV_CH_BACK_CENTER: u32 = 256;
    pub const AV_CH_SIDE_LEFT: u32 = 512;
    pub const AV_CH_SIDE_RIGHT: u32 = 1024;
    pub const AV_CH_TOP_CENTER: u32 = 2048;
    pub const AV_CH_TOP_FRONT_LEFT: u32 = 4096;
    pub const AV_CH_TOP_FRONT_CENTER: u32 = 8192;
    pub const AV_CH_TOP_FRONT_RIGHT: u32 = 16384;
    pub const AV_CH_TOP_BACK_LEFT: u32 = 32768;
    pub const AV_CH_TOP_BACK_CENTER: u32 = 65536;
    pub const AV_CH_TOP_BACK_RIGHT: u32 = 131072;
    pub const AV_CH_STEREO_LEFT: u32 = 536870912;
    pub const AV_CH_STEREO_RIGHT: u32 = 1073741824;
    pub const AV_CH_WIDE_LEFT: u32 = 2147483648;
    pub const AV_CH_WIDE_RIGHT: u64 = 4294967296;
    pub const AV_CH_SURROUND_DIRECT_LEFT: u64 = 8589934592;
    pub const AV_CH_SURROUND_DIRECT_RIGHT: u64 = 17179869184;
    pub const AV_CH_LOW_FREQUENCY_2: u64 = 34359738368;
    pub const AV_CH_TOP_SIDE_LEFT: u64 = 68719476736;
    pub const AV_CH_TOP_SIDE_RIGHT: u64 = 137438953472;
    pub const AV_CH_BOTTOM_FRONT_CENTER: u64 = 274877906944;
    pub const AV_CH_BOTTOM_FRONT_LEFT: u64 = 549755813888;
    pub const AV_CH_BOTTOM_FRONT_RIGHT: u64 = 1099511627776;
    pub const AV_CH_LAYOUT_NATIVE: i64 = -9223372036854775808;
    pub const AV_CH_LAYOUT_MONO: u32 = 4;
    pub const AV_CH_LAYOUT_STEREO: u32 = 3;
    pub const AV_CH_LAYOUT_2POINT1: u32 = 11;
    pub const AV_CH_LAYOUT_2_1: u32 = 259;
    pub const AV_CH_LAYOUT_SURROUND: u32 = 7;
    pub const AV_CH_LAYOUT_3POINT1: u32 = 15;
    pub const AV_CH_LAYOUT_4POINT0: u32 = 263;
    pub const AV_CH_LAYOUT_4POINT1: u32 = 271;
    pub const AV_CH_LAYOUT_2_2: u32 = 1539;
    pub const AV_CH_LAYOUT_QUAD: u32 = 51;
    pub const AV_CH_LAYOUT_5POINT0: u32 = 1543;
    pub const AV_CH_LAYOUT_5POINT1: u32 = 1551;
    pub const AV_CH_LAYOUT_5POINT0_BACK: u32 = 55;
    pub const AV_CH_LAYOUT_5POINT1_BACK: u32 = 63;
    pub const AV_CH_LAYOUT_6POINT0: u32 = 1799;
    pub const AV_CH_LAYOUT_6POINT0_FRONT: u32 = 1731;
    pub const AV_CH_LAYOUT_HEXAGONAL: u32 = 311;
    pub const AV_CH_LAYOUT_6POINT1: u32 = 1807;
    pub const AV_CH_LAYOUT_6POINT1_BACK: u32 = 319;
    pub const AV_CH_LAYOUT_6POINT1_FRONT: u32 = 1739;
    pub const AV_CH_LAYOUT_7POINT0: u32 = 1591;
    pub const AV_CH_LAYOUT_7POINT0_FRONT: u32 = 1735;
    pub const AV_CH_LAYOUT_7POINT1: u32 = 1599;
    pub const AV_CH_LAYOUT_7POINT1_WIDE: u32 = 1743;
    pub const AV_CH_LAYOUT_7POINT1_WIDE_BACK: u32 = 255;
    pub const AV_CH_LAYOUT_OCTAGONAL: u32 = 1847;
    pub const AV_CH_LAYOUT_HEXADECAGONAL: u64 = 6442710839;
    pub const AV_CH_LAYOUT_STEREO_DOWNMIX: u32 = 1610612736;
    pub const AV_CH_LAYOUT_22POINT2: u64 = 2164663779327;
    pub const CLOCKS_PER_SEC: u32 = 1000000;
    pub const TIME_UTC: u32 = 1;
    pub const AV_ESCAPE_FLAG_WHITESPACE: u32 = 1;
    pub const AV_ESCAPE_FLAG_STRICT: u32 = 2;
    pub const AV_ESCAPE_FLAG_XML_SINGLE_QUOTES: u32 = 4;
    pub const AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES: u32 = 8;
    pub const AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES: u32 = 1;
    pub const AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS: u32 = 2;
    pub const AV_UTF8_FLAG_ACCEPT_SURROGATES: u32 = 4;
    pub const AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES: u32 = 8;
    pub const AV_UTF8_FLAG_ACCEPT_ALL: u32 = 7;
    pub const AV_BPRINT_SIZE_AUTOMATIC: u32 = 1;
    pub const AV_BPRINT_SIZE_COUNT_ONLY: u32 = 0;
    pub const AES_CTR_KEY_SIZE: u32 = 16;
    pub const AES_CTR_IV_SIZE: u32 = 8;
    pub const AV_TS_MAX_STRING_SIZE: u32 = 32;
    pub const AV_HASH_MAX_SIZE: u32 = 64;
    pub type size_t = ::std::os::raw::c_ulong;
    pub type wchar_t = ::std::os::raw::c_int;
    pub type max_align_t = f64;
    pub type int_least8_t = i8;
    pub type int_least16_t = i16;
    pub type int_least32_t = i32;
    pub type int_least64_t = i64;
    pub type uint_least8_t = u8;
    pub type uint_least16_t = u16;
    pub type uint_least32_t = u32;
    pub type uint_least64_t = u64;
    pub type int_fast8_t = i8;
    pub type int_fast16_t = i16;
    pub type int_fast32_t = i32;
    pub type int_fast64_t = i64;
    pub type uint_fast8_t = u8;
    pub type uint_fast16_t = u16;
    pub type uint_fast32_t = u32;
    pub type uint_fast64_t = u64;
    pub type __int8_t = ::std::os::raw::c_schar;
    pub type __uint8_t = ::std::os::raw::c_uchar;
    pub type __int16_t = ::std::os::raw::c_short;
    pub type __uint16_t = ::std::os::raw::c_ushort;
    pub type __int32_t = ::std::os::raw::c_int;
    pub type __uint32_t = ::std::os::raw::c_uint;
    pub type __int64_t = ::std::os::raw::c_longlong;
    pub type __uint64_t = ::std::os::raw::c_ulonglong;
    pub type __darwin_intptr_t = ::std::os::raw::c_long;
    pub type __darwin_natural_t = ::std::os::raw::c_uint;
    pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t {
        pub __mbstate8: [::std::os::raw::c_char; 128usize],
        pub _mbstateL: ::std::os::raw::c_longlong,
    }
    impl Default for __mbstate_t {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    pub type __darwin_mbstate_t = root::__mbstate_t;
    pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
    pub type __darwin_size_t = ::std::os::raw::c_ulong;
    pub type __darwin_va_list = root::__builtin_va_list;
    pub type __darwin_wchar_t = ::std::os::raw::c_int;
    pub type __darwin_rune_t = root::__darwin_wchar_t;
    pub type __darwin_wint_t = ::std::os::raw::c_int;
    pub type __darwin_clock_t = ::std::os::raw::c_ulong;
    pub type __darwin_socklen_t = root::__uint32_t;
    pub type __darwin_ssize_t = ::std::os::raw::c_long;
    pub type __darwin_time_t = ::std::os::raw::c_long;
    pub type __darwin_blkcnt_t = root::__int64_t;
    pub type __darwin_blksize_t = root::__int32_t;
    pub type __darwin_dev_t = root::__int32_t;
    pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
    pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
    pub type __darwin_gid_t = root::__uint32_t;
    pub type __darwin_id_t = root::__uint32_t;
    pub type __darwin_ino64_t = root::__uint64_t;
    pub type __darwin_ino_t = root::__darwin_ino64_t;
    pub type __darwin_mach_port_name_t = root::__darwin_natural_t;
    pub type __darwin_mach_port_t = root::__darwin_mach_port_name_t;
    pub type __darwin_mode_t = root::__uint16_t;
    pub type __darwin_off_t = root::__int64_t;
    pub type __darwin_pid_t = root::__int32_t;
    pub type __darwin_sigset_t = root::__uint32_t;
    pub type __darwin_suseconds_t = root::__int32_t;
    pub type __darwin_uid_t = root::__uint32_t;
    pub type __darwin_useconds_t = root::__uint32_t;
    pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
    pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __darwin_pthread_handler_rec {
        pub __routine:
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        pub __arg: *mut ::std::os::raw::c_void,
        pub __next: *mut root::__darwin_pthread_handler_rec,
    }
    impl Default for __darwin_pthread_handler_rec {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_attr_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 56usize],
    }
    impl Default for _opaque_pthread_attr_t {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_cond_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 40usize],
    }
    impl Default for _opaque_pthread_cond_t {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct _opaque_pthread_condattr_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 8usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_mutex_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 56usize],
    }
    impl Default for _opaque_pthread_mutex_t {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct _opaque_pthread_mutexattr_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 8usize],
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct _opaque_pthread_once_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 8usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_rwlock_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 192usize],
    }
    impl Default for _opaque_pthread_rwlock_t {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct _opaque_pthread_rwlockattr_t {
        pub __sig: ::std::os::raw::c_long,
        pub __opaque: [::std::os::raw::c_char; 16usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_t {
        pub __sig: ::std::os::raw::c_long,
        pub __cleanup_stack: *mut root::__darwin_pthread_handler_rec,
        pub __opaque: [::std::os::raw::c_char; 8176usize],
    }
    impl Default for _opaque_pthread_t {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    pub type __darwin_pthread_attr_t = root::_opaque_pthread_attr_t;
    pub type __darwin_pthread_cond_t = root::_opaque_pthread_cond_t;
    pub type __darwin_pthread_condattr_t = root::_opaque_pthread_condattr_t;
    pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
    pub type __darwin_pthread_mutex_t = root::_opaque_pthread_mutex_t;
    pub type __darwin_pthread_mutexattr_t = root::_opaque_pthread_mutexattr_t;
    pub type __darwin_pthread_once_t = root::_opaque_pthread_once_t;
    pub type __darwin_pthread_rwlock_t = root::_opaque_pthread_rwlock_t;
    pub type __darwin_pthread_rwlockattr_t = root::_opaque_pthread_rwlockattr_t;
    pub type __darwin_pthread_t = *mut root::_opaque_pthread_t;
    pub type u_int8_t = ::std::os::raw::c_uchar;
    pub type u_int16_t = ::std::os::raw::c_ushort;
    pub type u_int32_t = ::std::os::raw::c_uint;
    pub type u_int64_t = ::std::os::raw::c_ulonglong;
    pub type register_t = i64;
    pub type user_addr_t = root::u_int64_t;
    pub type user_size_t = root::u_int64_t;
    pub type user_ssize_t = i64;
    pub type user_long_t = i64;
    pub type user_ulong_t = root::u_int64_t;
    pub type user_time_t = i64;
    pub type user_off_t = i64;
    pub type syscall_arg_t = root::u_int64_t;
    pub type intmax_t = ::std::os::raw::c_long;
    pub type uintmax_t = ::std::os::raw::c_ulong;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVBuffer {
        _unused: [u8; 0],
    }
    #[doc = " A reference to a data buffer."]
    #[doc = ""]
    #[doc = " The size of this struct is not a part of the public ABI and it is not meant"]
    #[doc = " to be allocated directly."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVBufferRef {
        pub buffer: *mut root::AVBuffer,
        #[doc = " The data buffer. It is considered writable if and only if"]
        #[doc = " this is the only reference to the buffer, in which case"]
        #[doc = " av_buffer_is_writable() returns 1."]
        pub data: *mut u8,
        #[doc = " Size of data in bytes."]
        pub size: root::size_t,
    }
    impl Default for AVBufferRef {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Allocate an AVBuffer of the given size using av_malloc()."]
        #[doc = ""]
        #[doc = " @return an AVBufferRef of given size or NULL when out of memory"]
        pub fn av_buffer_alloc(size: root::size_t) -> *mut root::AVBufferRef;
    }
    extern "C" {
        #[doc = " Same as av_buffer_alloc(), except the returned buffer will be initialized"]
        #[doc = " to zero."]
        pub fn av_buffer_allocz(size: root::size_t) -> *mut root::AVBufferRef;
    }
    extern "C" {
        #[doc = " Create an AVBuffer from an existing array."]
        #[doc = ""]
        #[doc = " If this function is successful, data is owned by the AVBuffer. The caller may"]
        #[doc = " only access data through the returned AVBufferRef and references derived from"]
        #[doc = " it."]
        #[doc = " If this function fails, data is left untouched."]
        #[doc = " @param data   data array"]
        #[doc = " @param size   size of data in bytes"]
        #[doc = " @param free   a callback for freeing this buffer's data"]
        #[doc = " @param opaque parameter to be got for processing or passed to free"]
        #[doc = " @param flags  a combination of AV_BUFFER_FLAG_*"]
        #[doc = ""]
        #[doc = " @return an AVBufferRef referring to data on success, NULL on failure."]
        pub fn av_buffer_create(
            data: *mut u8,
            size: root::size_t,
            free: ::std::option::Option<
                unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, data: *mut u8),
            >,
            opaque: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> *mut root::AVBufferRef;
    }
    extern "C" {
        #[doc = " Default free callback, which calls av_free() on the buffer data."]
        #[doc = " This function is meant to be passed to av_buffer_create(), not called"]
        #[doc = " directly."]
        pub fn av_buffer_default_free(opaque: *mut ::std::os::raw::c_void, data: *mut u8);
    }
    extern "C" {
        #[doc = " Create a new reference to an AVBuffer."]
        #[doc = ""]
        #[doc = " @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on"]
        #[doc = " failure."]
        pub fn av_buffer_ref(buf: *const root::AVBufferRef) -> *mut root::AVBufferRef;
    }
    extern "C" {
        #[doc = " Free a given reference and automatically free the buffer if there are no more"]
        #[doc = " references to it."]
        #[doc = ""]
        #[doc = " @param buf the reference to be freed. The pointer is set to NULL on return."]
        pub fn av_buffer_unref(buf: *mut *mut root::AVBufferRef);
    }
    extern "C" {
        #[doc = " @return 1 if the caller may write to the data referred to by buf (which is"]
        #[doc = " true if and only if buf is the only reference to the underlying AVBuffer)."]
        #[doc = " Return 0 otherwise."]
        #[doc = " A positive answer is valid until av_buffer_ref() is called on buf."]
        pub fn av_buffer_is_writable(buf: *const root::AVBufferRef) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @return the opaque parameter set by av_buffer_create."]
        pub fn av_buffer_get_opaque(buf: *const root::AVBufferRef) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn av_buffer_get_ref_count(buf: *const root::AVBufferRef) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Create a writable reference from a given buffer reference, avoiding data copy"]
        #[doc = " if possible."]
        #[doc = ""]
        #[doc = " @param buf buffer reference to make writable. On success, buf is either left"]
        #[doc = "            untouched, or it is unreferenced and a new writable AVBufferRef is"]
        #[doc = "            written in its place. On failure, buf is left untouched."]
        #[doc = " @return 0 on success, a negative AVERROR on failure."]
        pub fn av_buffer_make_writable(buf: *mut *mut root::AVBufferRef) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Reallocate a given buffer."]
        #[doc = ""]
        #[doc = " @param buf  a buffer reference to reallocate. On success, buf will be"]
        #[doc = "             unreferenced and a new reference with the required size will be"]
        #[doc = "             written in its place. On failure buf will be left untouched. *buf"]
        #[doc = "             may be NULL, then a new buffer is allocated."]
        #[doc = " @param size required new buffer size."]
        #[doc = " @return 0 on success, a negative AVERROR on failure."]
        #[doc = ""]
        #[doc = " @note the buffer is actually reallocated with av_realloc() only if it was"]
        #[doc = " initially allocated through av_buffer_realloc(NULL) and there is only one"]
        #[doc = " reference to it (i.e. the one passed to this function). In all other cases"]
        #[doc = " a new buffer is allocated and the data is copied."]
        pub fn av_buffer_realloc(
            buf: *mut *mut root::AVBufferRef,
            size: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Ensure dst refers to the same data as src."]
        #[doc = ""]
        #[doc = " When *dst is already equivalent to src, do nothing. Otherwise unreference dst"]
        #[doc = " and replace it with a new reference to src."]
        #[doc = ""]
        #[doc = " @param dst Pointer to either a valid buffer reference or NULL. On success,"]
        #[doc = "            this will point to a buffer reference equivalent to src. On"]
        #[doc = "            failure, dst will be left untouched."]
        #[doc = " @param src A buffer reference to replace dst with. May be NULL, then this"]
        #[doc = "            function is equivalent to av_buffer_unref(dst)."]
        #[doc = " @return 0 on success"]
        #[doc = "         AVERROR(ENOMEM) on memory allocation failure."]
        pub fn av_buffer_replace(
            dst: *mut *mut root::AVBufferRef,
            src: *const root::AVBufferRef,
        ) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVBufferPool {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate and initialize a buffer pool."]
        #[doc = ""]
        #[doc = " @param size size of each buffer in this pool"]
        #[doc = " @param alloc a function that will be used to allocate new buffers when the"]
        #[doc = " pool is empty. May be NULL, then the default allocator will be used"]
        #[doc = " (av_buffer_alloc())."]
        #[doc = " @return newly created buffer pool on success, NULL on error."]
        pub fn av_buffer_pool_init(
            size: root::size_t,
            alloc: ::std::option::Option<
                unsafe extern "C" fn(size: root::size_t) -> *mut root::AVBufferRef,
            >,
        ) -> *mut root::AVBufferPool;
    }
    extern "C" {
        #[doc = " Allocate and initialize a buffer pool with a more complex allocator."]
        #[doc = ""]
        #[doc = " @param size size of each buffer in this pool"]
        #[doc = " @param opaque arbitrary user data used by the allocator"]
        #[doc = " @param alloc a function that will be used to allocate new buffers when the"]
        #[doc = "              pool is empty. May be NULL, then the default allocator will be"]
        #[doc = "              used (av_buffer_alloc())."]
        #[doc = " @param pool_free a function that will be called immediately before the pool"]
        #[doc = "                  is freed. I.e. after av_buffer_pool_uninit() is called"]
        #[doc = "                  by the caller and all the frames are returned to the pool"]
        #[doc = "                  and freed. It is intended to uninitialize the user opaque"]
        #[doc = "                  data. May be NULL."]
        #[doc = " @return newly created buffer pool on success, NULL on error."]
        pub fn av_buffer_pool_init2(
            size: root::size_t,
            opaque: *mut ::std::os::raw::c_void,
            alloc: ::std::option::Option<
                unsafe extern "C" fn(
                    opaque: *mut ::std::os::raw::c_void,
                    size: root::size_t,
                ) -> *mut root::AVBufferRef,
            >,
            pool_free: ::std::option::Option<
                unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void),
            >,
        ) -> *mut root::AVBufferPool;
    }
    extern "C" {
        #[doc = " Mark the pool as being available for freeing. It will actually be freed only"]
        #[doc = " once all the allocated buffers associated with the pool are released. Thus it"]
        #[doc = " is safe to call this function while some of the allocated buffers are still"]
        #[doc = " in use."]
        #[doc = ""]
        #[doc = " @param pool pointer to the pool to be freed. It will be set to NULL."]
        pub fn av_buffer_pool_uninit(pool: *mut *mut root::AVBufferPool);
    }
    extern "C" {
        #[doc = " Allocate a new AVBuffer, reusing an old buffer from the pool when available."]
        #[doc = " This function may be called simultaneously from multiple threads."]
        #[doc = ""]
        #[doc = " @return a reference to the new buffer on success, NULL on error."]
        pub fn av_buffer_pool_get(pool: *mut root::AVBufferPool) -> *mut root::AVBufferRef;
    }
    extern "C" {
        #[doc = " Query the original opaque parameter of an allocated buffer in the pool."]
        #[doc = ""]
        #[doc = " @param ref a buffer reference to a buffer returned by av_buffer_pool_get."]
        #[doc = " @return the opaque parameter set by the buffer allocator function of the"]
        #[doc = "         buffer pool."]
        #[doc = ""]
        #[doc = " @note the opaque parameter of ref is used by the buffer pool implementation,"]
        #[doc = " therefore you have to use this function to access the original opaque"]
        #[doc = " parameter of an allocated buffer."]
        pub fn av_buffer_pool_buffer_get_opaque(
            ref_: *const root::AVBufferRef,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Return the LIBAVUTIL_VERSION_INT constant."]
        pub fn avutil_version() -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[doc = " Return an informative version string. This usually is the actual release"]
        #[doc = " version number or a git commit description. This string has no fixed format"]
        #[doc = " and can change any time. It should never be parsed by code."]
        pub fn av_version_info() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Return the libavutil build-time configuration."]
        pub fn avutil_configuration() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Return the libavutil license."]
        pub fn avutil_license() -> *const ::std::os::raw::c_char;
    }
    #[doc = "< Usually treated as AVMEDIA_TYPE_DATA"]
    pub const AVMediaType_AVMEDIA_TYPE_UNKNOWN: root::AVMediaType = -1;
    pub const AVMediaType_AVMEDIA_TYPE_VIDEO: root::AVMediaType = 0;
    pub const AVMediaType_AVMEDIA_TYPE_AUDIO: root::AVMediaType = 1;
    #[doc = "< Opaque data information usually continuous"]
    pub const AVMediaType_AVMEDIA_TYPE_DATA: root::AVMediaType = 2;
    pub const AVMediaType_AVMEDIA_TYPE_SUBTITLE: root::AVMediaType = 3;
    #[doc = "< Opaque data information usually sparse"]
    pub const AVMediaType_AVMEDIA_TYPE_ATTACHMENT: root::AVMediaType = 4;
    pub const AVMediaType_AVMEDIA_TYPE_NB: root::AVMediaType = 5;
    #[doc = " @addtogroup lavu_media Media Type"]
    #[doc = " @brief Media Type"]
    pub type AVMediaType = ::std::os::raw::c_int;
    extern "C" {
        #[doc = " Return a string describing the media_type enum, NULL if media_type"]
        #[doc = " is unknown."]
        pub fn av_get_media_type_string(
            media_type: root::AVMediaType,
        ) -> *const ::std::os::raw::c_char;
    }
    #[doc = "< Undefined"]
    pub const AVPictureType_AV_PICTURE_TYPE_NONE: root::AVPictureType = 0;
    #[doc = "< Intra"]
    pub const AVPictureType_AV_PICTURE_TYPE_I: root::AVPictureType = 1;
    #[doc = "< Predicted"]
    pub const AVPictureType_AV_PICTURE_TYPE_P: root::AVPictureType = 2;
    #[doc = "< Bi-dir predicted"]
    pub const AVPictureType_AV_PICTURE_TYPE_B: root::AVPictureType = 3;
    #[doc = "< S(GMC)-VOP MPEG-4"]
    pub const AVPictureType_AV_PICTURE_TYPE_S: root::AVPictureType = 4;
    #[doc = "< Switching Intra"]
    pub const AVPictureType_AV_PICTURE_TYPE_SI: root::AVPictureType = 5;
    #[doc = "< Switching Predicted"]
    pub const AVPictureType_AV_PICTURE_TYPE_SP: root::AVPictureType = 6;
    #[doc = "< BI type"]
    pub const AVPictureType_AV_PICTURE_TYPE_BI: root::AVPictureType = 7;
    #[doc = " @}"]
    #[doc = " @}"]
    #[doc = " @defgroup lavu_picture Image related"]
    #[doc = ""]
    #[doc = " AVPicture types, pixel formats and basic image planes manipulation."]
    #[doc = ""]
    #[doc = " @{"]
    pub type AVPictureType = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Return a single letter to describe the given picture type"]
        #[doc = " pict_type."]
        #[doc = ""]
        #[doc = " @param[in] pict_type the picture type @return a single character"]
        #[doc = " representing the picture type, '?' if pict_type is unknown"]
        pub fn av_get_picture_type_char(pict_type: root::AVPictureType) -> ::std::os::raw::c_char;
    }
    pub type errno_t = ::std::os::raw::c_int;
    extern "C" {
        pub fn __error() -> *mut ::std::os::raw::c_int;
    }
    pub type __darwin_nl_item = ::std::os::raw::c_int;
    pub type __darwin_wctrans_t = ::std::os::raw::c_int;
    pub type __darwin_wctype_t = root::__uint32_t;
    extern "C" {
        pub fn imaxabs(j: root::intmax_t) -> root::intmax_t;
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct imaxdiv_t {
        pub quot: root::intmax_t,
        pub rem: root::intmax_t,
    }
    extern "C" {
        pub fn imaxdiv(__numer: root::intmax_t, __denom: root::intmax_t) -> root::imaxdiv_t;
    }
    extern "C" {
        pub fn strtoimax(
            __nptr: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> root::intmax_t;
    }
    extern "C" {
        pub fn strtoumax(
            __nptr: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> root::uintmax_t;
    }
    extern "C" {
        pub fn wcstoimax(
            __nptr: *const root::wchar_t,
            __endptr: *mut *mut root::wchar_t,
            __base: ::std::os::raw::c_int,
        ) -> root::intmax_t;
    }
    extern "C" {
        pub fn wcstoumax(
            __nptr: *const root::wchar_t,
            __endptr: *mut *mut root::wchar_t,
            __base: ::std::os::raw::c_int,
        ) -> root::uintmax_t;
    }
    pub type float_t = f32;
    pub type double_t = f64;
    extern "C" {
        pub fn __math_errhandling() -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isfinitef(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isfinited(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isfinitel(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isinff(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isinfd(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isinfl(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isnanf(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isnand(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isnanl(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isnormalf(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isnormald(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_isnormall(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_signbitf(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_signbitd(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __inline_signbitl(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn acosf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn acos(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn acosl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn asinf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn asin(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn asinl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn atanf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn atan(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn atanl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn atan2f(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn atan2(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn atan2l(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn cosf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn cos(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn cosl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn sinf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn sin(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn sinl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn tanf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn tan(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn tanl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn acoshf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn acosh(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn acoshl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn asinhf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn asinh(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn asinhl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn atanhf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn atanh(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn atanhl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn coshf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn cosh(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn coshl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn sinhf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn sinh(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn sinhl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn tanhf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn tanh(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn tanhl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn expf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn exp(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn expl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn exp2f(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn exp2(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn exp2l(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn expm1f(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn expm1(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn expm1l(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn logf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn log(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn logl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn log10f(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn log10(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn log10l(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn log2f(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn log2(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn log2l(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn log1pf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn log1p(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn log1pl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn logbf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn logb(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn logbl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
    }
    extern "C" {
        pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
    }
    extern "C" {
        pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
    }
    extern "C" {
        pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
    }
    extern "C" {
        pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
    }
    extern "C" {
        pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
    }
    extern "C" {
        pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
    }
    extern "C" {
        pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
    }
    extern "C" {
        pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
    }
    extern "C" {
        pub fn fabsf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn fabs(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn fabsl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn cbrtf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn cbrt(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn cbrtl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn hypotf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn hypot(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn hypotl(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn powf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn pow(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn powl(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn sqrtf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn sqrt(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn sqrtl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn erff(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn erf(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn erfl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn erfcf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn erfc(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn erfcl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn lgammaf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn lgamma(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn lgammal(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn tgammaf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn tgamma(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn tgammal(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn ceilf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn ceil(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn ceill(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn floorf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn floor(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn floorl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn nearbyintf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn nearbyint(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn nearbyintl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn rintf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn rint(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn rintl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn roundf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn round(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn roundl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn truncf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn trunc(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn truncl(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn fmodf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn fmod(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn fmodl(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn remainderf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn remainder(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn remainderl(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
    }
    extern "C" {
        pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn copysignf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn copysign(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn copysignl(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
    }
    extern "C" {
        pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
    }
    extern "C" {
        pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
    }
    extern "C" {
        pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn nextafter(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
    }
    extern "C" {
        pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn fdimf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn fdim(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn fdiml(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn fmax(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn fminf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn fmin(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn fminl(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
    }
    extern "C" {
        pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
    }
    extern "C" {
        pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
    }
    extern "C" {
        pub fn __exp10f(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn __exp10(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn __sincosf(__x: f32, __sinp: *mut f32, __cosp: *mut f32);
    }
    extern "C" {
        pub fn __sincos(__x: f64, __sinp: *mut f64, __cosp: *mut f64);
    }
    extern "C" {
        pub fn __cospif(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn __cospi(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn __sinpif(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn __sinpi(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn __tanpif(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn __tanpi(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn __sincospif(__x: f32, __sinp: *mut f32, __cosp: *mut f32);
    }
    extern "C" {
        pub fn __sincospi(__x: f64, __sinp: *mut f64, __cosp: *mut f64);
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __float2 {
        pub __sinval: f32,
        pub __cosval: f32,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __double2 {
        pub __sinval: f64,
        pub __cosval: f64,
    }
    extern "C" {
        pub fn __sincosf_stret(arg1: f32) -> root::__float2;
    }
    extern "C" {
        pub fn __sincos_stret(arg1: f64) -> root::__double2;
    }
    extern "C" {
        pub fn __sincospif_stret(arg1: f32) -> root::__float2;
    }
    extern "C" {
        pub fn __sincospi_stret(arg1: f64) -> root::__double2;
    }
    extern "C" {
        pub fn j0(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn j1(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn y0(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn y1(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn scalb(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub static mut signgam: ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct exception {
        pub type_: ::std::os::raw::c_int,
        pub name: *mut ::std::os::raw::c_char,
        pub arg1: f64,
        pub arg2: f64,
        pub retval: f64,
    }
    impl Default for exception {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    pub type va_list = root::__darwin_va_list;
    extern "C" {
        pub fn renameat(
            arg1: ::std::os::raw::c_int,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn renamex_np(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn renameatx_np(
            arg1: ::std::os::raw::c_int,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *const ::std::os::raw::c_char,
            arg5: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    pub type fpos_t = root::__darwin_off_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sbuf {
        pub _base: *mut ::std::os::raw::c_uchar,
        pub _size: ::std::os::raw::c_int,
    }
    impl Default for __sbuf {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sFILEX {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sFILE {
        pub _p: *mut ::std::os::raw::c_uchar,
        pub _r: ::std::os::raw::c_int,
        pub _w: ::std::os::raw::c_int,
        pub _flags: ::std::os::raw::c_short,
        pub _file: ::std::os::raw::c_short,
        pub _bf: root::__sbuf,
        pub _lbfsize: ::std::os::raw::c_int,
        pub _cookie: *mut ::std::os::raw::c_void,
        pub _close: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        pub _read: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        pub _seek: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: root::fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> root::fpos_t,
        >,
        pub _write: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        pub _ub: root::__sbuf,
        pub _extra: *mut root::__sFILEX,
        pub _ur: ::std::os::raw::c_int,
        pub _ubuf: [::std::os::raw::c_uchar; 3usize],
        pub _nbuf: [::std::os::raw::c_uchar; 1usize],
        pub _lb: root::__sbuf,
        pub _blksize: ::std::os::raw::c_int,
        pub _offset: root::fpos_t,
    }
    impl Default for __sFILE {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    pub type FILE = root::__sFILE;
    extern "C" {
        pub static mut __stdinp: *mut root::FILE;
    }
    extern "C" {
        pub static mut __stdoutp: *mut root::FILE;
    }
    extern "C" {
        pub static mut __stderrp: *mut root::FILE;
    }
    extern "C" {
        pub fn clearerr(arg1: *mut root::FILE);
    }
    extern "C" {
        pub fn fclose(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn feof(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ferror(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fflush(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fgetc(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fgetpos(arg1: *mut root::FILE, arg2: *mut root::fpos_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fgets(
            arg1: *mut ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
            arg3: *mut root::FILE,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn fopen(
            __filename: *const ::std::os::raw::c_char,
            __mode: *const ::std::os::raw::c_char,
        ) -> *mut root::FILE;
    }
    extern "C" {
        pub fn fprintf(
            arg1: *mut root::FILE,
            arg2: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fputs(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut root::FILE,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fread(
            __ptr: *mut ::std::os::raw::c_void,
            __size: ::std::os::raw::c_ulong,
            __nitems: ::std::os::raw::c_ulong,
            __stream: *mut root::FILE,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn freopen(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut root::FILE,
        ) -> *mut root::FILE;
    }
    extern "C" {
        pub fn fscanf(
            arg1: *mut root::FILE,
            arg2: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fseek(
            arg1: *mut root::FILE,
            arg2: ::std::os::raw::c_long,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fsetpos(arg1: *mut root::FILE, arg2: *const root::fpos_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ftell(arg1: *mut root::FILE) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn fwrite(
            __ptr: *const ::std::os::raw::c_void,
            __size: ::std::os::raw::c_ulong,
            __nitems: ::std::os::raw::c_ulong,
            __stream: *mut root::FILE,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn getc(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn getchar() -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn perror(arg1: *const ::std::os::raw::c_char);
    }
    extern "C" {
        pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn rename(
            __old: *const ::std::os::raw::c_char,
            __new: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn rewind(arg1: *mut root::FILE);
    }
    extern "C" {
        pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn setbuf(arg1: *mut root::FILE, arg2: *mut ::std::os::raw::c_char);
    }
    extern "C" {
        pub fn setvbuf(
            arg1: *mut root::FILE,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn sprintf(
            arg1: *mut ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn sscanf(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn tmpfile() -> *mut root::FILE;
    }
    extern "C" {
        pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn vfprintf(
            arg1: *mut root::FILE,
            arg2: *const ::std::os::raw::c_char,
            arg3: root::__builtin_va_list,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn vprintf(
            arg1: *const ::std::os::raw::c_char,
            arg2: root::__builtin_va_list,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn vsprintf(
            arg1: *mut ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: root::__builtin_va_list,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn fdopen(
            arg1: ::std::os::raw::c_int,
            arg2: *const ::std::os::raw::c_char,
        ) -> *mut root::FILE;
    }
    extern "C" {
        pub fn fileno(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn pclose(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn popen(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> *mut root::FILE;
    }
    extern "C" {
        pub fn __srget(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __svfscanf(
            arg1: *mut root::FILE,
            arg2: *const ::std::os::raw::c_char,
            arg3: root::va_list,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut root::FILE)
            -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __sputc(_c: ::std::os::raw::c_int, _p: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn flockfile(arg1: *mut root::FILE);
    }
    extern "C" {
        pub fn ftrylockfile(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn funlockfile(arg1: *mut root::FILE);
    }
    extern "C" {
        pub fn getc_unlocked(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn getchar_unlocked() -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn putc_unlocked(
            arg1: ::std::os::raw::c_int,
            arg2: *mut root::FILE,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn getw(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn tempnam(
            __dir: *const ::std::os::raw::c_char,
            __prefix: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    pub type off_t = root::__darwin_off_t;
    extern "C" {
        pub fn fseeko(
            __stream: *mut root::FILE,
            __offset: root::off_t,
            __whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ftello(__stream: *mut root::FILE) -> root::off_t;
    }
    extern "C" {
        pub fn snprintf(
            __str: *mut ::std::os::raw::c_char,
            __size: ::std::os::raw::c_ulong,
            __format: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn vfscanf(
            __stream: *mut root::FILE,
            __format: *const ::std::os::raw::c_char,
            arg1: root::__builtin_va_list,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn vscanf(
            __format: *const ::std::os::raw::c_char,
            arg1: root::__builtin_va_list,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn vsnprintf(
            __str: *mut ::std::os::raw::c_char,
            __size: ::std::os::raw::c_ulong,
            __format: *const ::std::os::raw::c_char,
            arg1: root::__builtin_va_list,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn vsscanf(
            __str: *const ::std::os::raw::c_char,
            __format: *const ::std::os::raw::c_char,
            arg1: root::__builtin_va_list,
        ) -> ::std::os::raw::c_int;
    }
    pub type ssize_t = root::__darwin_ssize_t;
    extern "C" {
        pub fn dprintf(
            arg1: ::std::os::raw::c_int,
            arg2: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn vdprintf(
            arg1: ::std::os::raw::c_int,
            arg2: *const ::std::os::raw::c_char,
            arg3: root::va_list,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn getdelim(
            __linep: *mut *mut ::std::os::raw::c_char,
            __linecapp: *mut root::size_t,
            __delimiter: ::std::os::raw::c_int,
            __stream: *mut root::FILE,
        ) -> root::ssize_t;
    }
    extern "C" {
        pub fn getline(
            __linep: *mut *mut ::std::os::raw::c_char,
            __linecapp: *mut root::size_t,
            __stream: *mut root::FILE,
        ) -> root::ssize_t;
    }
    extern "C" {
        pub fn fmemopen(
            __buf: *mut ::std::os::raw::c_void,
            __size: root::size_t,
            __mode: *const ::std::os::raw::c_char,
        ) -> *mut root::FILE;
    }
    extern "C" {
        pub fn open_memstream(
            __bufp: *mut *mut ::std::os::raw::c_char,
            __sizep: *mut root::size_t,
        ) -> *mut root::FILE;
    }
    extern "C" {
        pub static sys_nerr: ::std::os::raw::c_int;
    }
    extern "C" {
        pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
    }
    extern "C" {
        pub fn asprintf(
            arg1: *mut *mut ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn fgetln(
            arg1: *mut root::FILE,
            arg2: *mut root::size_t,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn fmtcheck(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn fpurge(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn setbuffer(
            arg1: *mut root::FILE,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn setlinebuf(arg1: *mut root::FILE) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn vasprintf(
            arg1: *mut *mut ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: root::va_list,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn funopen(
            arg1: *const ::std::os::raw::c_void,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *mut ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
            arg3: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
            arg4: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: root::fpos_t,
                    arg3: ::std::os::raw::c_int,
                ) -> root::fpos_t,
            >,
            arg5: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
            >,
        ) -> *mut root::FILE;
    }
    extern "C" {
        pub fn __sprintf_chk(
            arg1: *mut ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
            arg3: root::size_t,
            arg4: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __snprintf_chk(
            arg1: *mut ::std::os::raw::c_char,
            arg2: root::size_t,
            arg3: ::std::os::raw::c_int,
            arg4: root::size_t,
            arg5: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __vsprintf_chk(
            arg1: *mut ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
            arg3: root::size_t,
            arg4: *const ::std::os::raw::c_char,
            arg5: root::va_list,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __vsnprintf_chk(
            arg1: *mut ::std::os::raw::c_char,
            arg2: root::size_t,
            arg3: ::std::os::raw::c_int,
            arg4: root::size_t,
            arg5: *const ::std::os::raw::c_char,
            arg6: root::va_list,
        ) -> ::std::os::raw::c_int;
    }
    pub const idtype_t_P_ALL: root::idtype_t = 0;
    pub const idtype_t_P_PID: root::idtype_t = 1;
    pub const idtype_t_P_PGID: root::idtype_t = 2;
    pub type idtype_t = ::std::os::raw::c_uint;
    pub type pid_t = root::__darwin_pid_t;
    pub type id_t = root::__darwin_id_t;
    pub type sig_atomic_t = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __darwin_arm_exception_state {
        pub __exception: root::__uint32_t,
        pub __fsr: root::__uint32_t,
        pub __far: root::__uint32_t,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __darwin_arm_exception_state64 {
        pub __far: root::__uint64_t,
        pub __esr: root::__uint32_t,
        pub __exception: root::__uint32_t,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __darwin_arm_thread_state {
        pub __r: [root::__uint32_t; 13usize],
        pub __sp: root::__uint32_t,
        pub __lr: root::__uint32_t,
        pub __pc: root::__uint32_t,
        pub __cpsr: root::__uint32_t,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __darwin_arm_thread_state64 {
        pub __x: [root::__uint64_t; 29usize],
        pub __fp: root::__uint64_t,
        pub __lr: root::__uint64_t,
        pub __sp: root::__uint64_t,
        pub __pc: root::__uint64_t,
        pub __cpsr: root::__uint32_t,
        pub __pad: root::__uint32_t,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __darwin_arm_vfp_state {
        pub __r: [root::__uint32_t; 64usize],
        pub __fpscr: root::__uint32_t,
    }
    impl Default for __darwin_arm_vfp_state {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __darwin_arm_neon_state64 {
        pub __v: [root::__uint128_t; 32usize],
        pub __fpsr: root::__uint32_t,
        pub __fpcr: root::__uint32_t,
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __darwin_arm_neon_state {
        pub __v: [root::__uint128_t; 16usize],
        pub __fpsr: root::__uint32_t,
        pub __fpcr: root::__uint32_t,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __arm_pagein_state {
        pub __pagein_error: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __arm_legacy_debug_state {
        pub __bvr: [root::__uint32_t; 16usize],
        pub __bcr: [root::__uint32_t; 16usize],
        pub __wvr: [root::__uint32_t; 16usize],
        pub __wcr: [root::__uint32_t; 16usize],
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __darwin_arm_debug_state32 {
        pub __bvr: [root::__uint32_t; 16usize],
        pub __bcr: [root::__uint32_t; 16usize],
        pub __wvr: [root::__uint32_t; 16usize],
        pub __wcr: [root::__uint32_t; 16usize],
        pub __mdscr_el1: root::__uint64_t,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __darwin_arm_debug_state64 {
        pub __bvr: [root::__uint64_t; 16usize],
        pub __bcr: [root::__uint64_t; 16usize],
        pub __wvr: [root::__uint64_t; 16usize],
        pub __wcr: [root::__uint64_t; 16usize],
        pub __mdscr_el1: root::__uint64_t,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __darwin_arm_cpmu_state64 {
        pub __ctrs: [root::__uint64_t; 16usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __darwin_mcontext32 {
        pub __es: root::__darwin_arm_exception_state,
        pub __ss: root::__darwin_arm_thread_state,
        pub __fs: root::__darwin_arm_vfp_state,
    }
    impl Default for __darwin_mcontext32 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct __darwin_mcontext64 {
        pub __es: root::__darwin_arm_exception_state64,
        pub __ss: root::__darwin_arm_thread_state64,
        pub __ns: root::__darwin_arm_neon_state64,
    }
    pub type mcontext_t = *mut root::__darwin_mcontext64;
    pub type pthread_attr_t = root::__darwin_pthread_attr_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __darwin_sigaltstack {
        pub ss_sp: *mut ::std::os::raw::c_void,
        pub ss_size: root::__darwin_size_t,
        pub ss_flags: ::std::os::raw::c_int,
    }
    impl Default for __darwin_sigaltstack {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    pub type stack_t = root::__darwin_sigaltstack;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __darwin_ucontext {
        pub uc_onstack: ::std::os::raw::c_int,
        pub uc_sigmask: root::__darwin_sigset_t,
        pub uc_stack: root::__darwin_sigaltstack,
        pub uc_link: *mut root::__darwin_ucontext,
        pub uc_mcsize: root::__darwin_size_t,
        pub uc_mcontext: *mut root::__darwin_mcontext64,
    }
    impl Default for __darwin_ucontext {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    pub type ucontext_t = root::__darwin_ucontext;
    pub type sigset_t = root::__darwin_sigset_t;
    pub type uid_t = root::__darwin_uid_t;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sigval {
        pub sival_int: ::std::os::raw::c_int,
        pub sival_ptr: *mut ::std::os::raw::c_void,
    }
    impl Default for sigval {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct sigevent {
        pub sigev_notify: ::std::os::raw::c_int,
        pub sigev_signo: ::std::os::raw::c_int,
        pub sigev_value: root::sigval,
        pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: root::sigval)>,
        pub sigev_notify_attributes: *mut root::pthread_attr_t,
    }
    impl Default for sigevent {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __siginfo {
        pub si_signo: ::std::os::raw::c_int,
        pub si_errno: ::std::os::raw::c_int,
        pub si_code: ::std::os::raw::c_int,
        pub si_pid: root::pid_t,
        pub si_uid: root::uid_t,
        pub si_status: ::std::os::raw::c_int,
        pub si_addr: *mut ::std::os::raw::c_void,
        pub si_value: root::sigval,
        pub si_band: ::std::os::raw::c_long,
        pub __pad: [::std::os::raw::c_ulong; 7usize],
    }
    impl Default for __siginfo {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    pub type siginfo_t = root::__siginfo;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __sigaction_u {
        pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        pub __sa_sigaction: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *mut root::__siginfo,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
    }
    impl Default for __sigaction_u {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __sigaction {
        pub __sigaction_u: root::__sigaction_u,
        pub sa_tramp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: *mut root::siginfo_t,
                arg5: *mut ::std::os::raw::c_void,
            ),
        >,
        pub sa_mask: root::sigset_t,
        pub sa_flags: ::std::os::raw::c_int,
    }
    impl Default for __sigaction {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct sigaction {
        pub __sigaction_u: root::__sigaction_u,
        pub sa_mask: root::sigset_t,
        pub sa_flags: ::std::os::raw::c_int,
    }
    impl Default for sigaction {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct sigvec {
        pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        pub sv_mask: ::std::os::raw::c_int,
        pub sv_flags: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sigstack {
        pub ss_sp: *mut ::std::os::raw::c_char,
        pub ss_onstack: ::std::os::raw::c_int,
    }
    impl Default for sigstack {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        pub fn signal(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ) -> ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
            ),
        >;
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct timeval {
        pub tv_sec: root::__darwin_time_t,
        pub tv_usec: root::__darwin_suseconds_t,
    }
    pub type rlim_t = root::__uint64_t;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct rusage {
        pub ru_utime: root::timeval,
        pub ru_stime: root::timeval,
        pub ru_maxrss: ::std::os::raw::c_long,
        pub ru_ixrss: ::std::os::raw::c_long,
        pub ru_idrss: ::std::os::raw::c_long,
        pub ru_isrss: ::std::os::raw::c_long,
        pub ru_minflt: ::std::os::raw::c_long,
        pub ru_majflt: ::std::os::raw::c_long,
        pub ru_nswap: ::std::os::raw::c_long,
        pub ru_inblock: ::std::os::raw::c_long,
        pub ru_oublock: ::std::os::raw::c_long,
        pub ru_msgsnd: ::std::os::raw::c_long,
        pub ru_msgrcv: ::std::os::raw::c_long,
        pub ru_nsignals: ::std::os::raw::c_long,
        pub ru_nvcsw: ::std::os::raw::c_long,
        pub ru_nivcsw: ::std::os::raw::c_long,
    }
    pub type rusage_info_t = *mut ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct rusage_info_v0 {
        pub ri_uuid: [u8; 16usize],
        pub ri_user_time: u64,
        pub ri_system_time: u64,
        pub ri_pkg_idle_wkups: u64,
        pub ri_interrupt_wkups: u64,
        pub ri_pageins: u64,
        pub ri_wired_size: u64,
        pub ri_resident_size: u64,
        pub ri_phys_footprint: u64,
        pub ri_proc_start_abstime: u64,
        pub ri_proc_exit_abstime: u64,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct rusage_info_v1 {
        pub ri_uuid: [u8; 16usize],
        pub ri_user_time: u64,
        pub ri_system_time: u64,
        pub ri_pkg_idle_wkups: u64,
        pub ri_interrupt_wkups: u64,
        pub ri_pageins: u64,
        pub ri_wired_size: u64,
        pub ri_resident_size: u64,
        pub ri_phys_footprint: u64,
        pub ri_proc_start_abstime: u64,
        pub ri_proc_exit_abstime: u64,
        pub ri_child_user_time: u64,
        pub ri_child_system_time: u64,
        pub ri_child_pkg_idle_wkups: u64,
        pub ri_child_interrupt_wkups: u64,
        pub ri_child_pageins: u64,
        pub ri_child_elapsed_abstime: u64,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct rusage_info_v2 {
        pub ri_uuid: [u8; 16usize],
        pub ri_user_time: u64,
        pub ri_system_time: u64,
        pub ri_pkg_idle_wkups: u64,
        pub ri_interrupt_wkups: u64,
        pub ri_pageins: u64,
        pub ri_wired_size: u64,
        pub ri_resident_size: u64,
        pub ri_phys_footprint: u64,
        pub ri_proc_start_abstime: u64,
        pub ri_proc_exit_abstime: u64,
        pub ri_child_user_time: u64,
        pub ri_child_system_time: u64,
        pub ri_child_pkg_idle_wkups: u64,
        pub ri_child_interrupt_wkups: u64,
        pub ri_child_pageins: u64,
        pub ri_child_elapsed_abstime: u64,
        pub ri_diskio_bytesread: u64,
        pub ri_diskio_byteswritten: u64,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct rusage_info_v3 {
        pub ri_uuid: [u8; 16usize],
        pub ri_user_time: u64,
        pub ri_system_time: u64,
        pub ri_pkg_idle_wkups: u64,
        pub ri_interrupt_wkups: u64,
        pub ri_pageins: u64,
        pub ri_wired_size: u64,
        pub ri_resident_size: u64,
        pub ri_phys_footprint: u64,
        pub ri_proc_start_abstime: u64,
        pub ri_proc_exit_abstime: u64,
        pub ri_child_user_time: u64,
        pub ri_child_system_time: u64,
        pub ri_child_pkg_idle_wkups: u64,
        pub ri_child_interrupt_wkups: u64,
        pub ri_child_pageins: u64,
        pub ri_child_elapsed_abstime: u64,
        pub ri_diskio_bytesread: u64,
        pub ri_diskio_byteswritten: u64,
        pub ri_cpu_time_qos_default: u64,
        pub ri_cpu_time_qos_maintenance: u64,
        pub ri_cpu_time_qos_background: u64,
        pub ri_cpu_time_qos_utility: u64,
        pub ri_cpu_time_qos_legacy: u64,
        pub ri_cpu_time_qos_user_initiated: u64,
        pub ri_cpu_time_qos_user_interactive: u64,
        pub ri_billed_system_time: u64,
        pub ri_serviced_system_time: u64,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct rusage_info_v4 {
        pub ri_uuid: [u8; 16usize],
        pub ri_user_time: u64,
        pub ri_system_time: u64,
        pub ri_pkg_idle_wkups: u64,
        pub ri_interrupt_wkups: u64,
        pub ri_pageins: u64,
        pub ri_wired_size: u64,
        pub ri_resident_size: u64,
        pub ri_phys_footprint: u64,
        pub ri_proc_start_abstime: u64,
        pub ri_proc_exit_abstime: u64,
        pub ri_child_user_time: u64,
        pub ri_child_system_time: u64,
        pub ri_child_pkg_idle_wkups: u64,
        pub ri_child_interrupt_wkups: u64,
        pub ri_child_pageins: u64,
        pub ri_child_elapsed_abstime: u64,
        pub ri_diskio_bytesread: u64,
        pub ri_diskio_byteswritten: u64,
        pub ri_cpu_time_qos_default: u64,
        pub ri_cpu_time_qos_maintenance: u64,
        pub ri_cpu_time_qos_background: u64,
        pub ri_cpu_time_qos_utility: u64,
        pub ri_cpu_time_qos_legacy: u64,
        pub ri_cpu_time_qos_user_initiated: u64,
        pub ri_cpu_time_qos_user_interactive: u64,
        pub ri_billed_system_time: u64,
        pub ri_serviced_system_time: u64,
        pub ri_logical_writes: u64,
        pub ri_lifetime_max_phys_footprint: u64,
        pub ri_instructions: u64,
        pub ri_cycles: u64,
        pub ri_billed_energy: u64,
        pub ri_serviced_energy: u64,
        pub ri_interval_max_phys_footprint: u64,
        pub ri_runnable_time: u64,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct rusage_info_v5 {
        pub ri_uuid: [u8; 16usize],
        pub ri_user_time: u64,
        pub ri_system_time: u64,
        pub ri_pkg_idle_wkups: u64,
        pub ri_interrupt_wkups: u64,
        pub ri_pageins: u64,
        pub ri_wired_size: u64,
        pub ri_resident_size: u64,
        pub ri_phys_footprint: u64,
        pub ri_proc_start_abstime: u64,
        pub ri_proc_exit_abstime: u64,
        pub ri_child_user_time: u64,
        pub ri_child_system_time: u64,
        pub ri_child_pkg_idle_wkups: u64,
        pub ri_child_interrupt_wkups: u64,
        pub ri_child_pageins: u64,
        pub ri_child_elapsed_abstime: u64,
        pub ri_diskio_bytesread: u64,
        pub ri_diskio_byteswritten: u64,
        pub ri_cpu_time_qos_default: u64,
        pub ri_cpu_time_qos_maintenance: u64,
        pub ri_cpu_time_qos_background: u64,
        pub ri_cpu_time_qos_utility: u64,
        pub ri_cpu_time_qos_legacy: u64,
        pub ri_cpu_time_qos_user_initiated: u64,
        pub ri_cpu_time_qos_user_interactive: u64,
        pub ri_billed_system_time: u64,
        pub ri_serviced_system_time: u64,
        pub ri_logical_writes: u64,
        pub ri_lifetime_max_phys_footprint: u64,
        pub ri_instructions: u64,
        pub ri_cycles: u64,
        pub ri_billed_energy: u64,
        pub ri_serviced_energy: u64,
        pub ri_interval_max_phys_footprint: u64,
        pub ri_runnable_time: u64,
        pub ri_flags: u64,
    }
    pub type rusage_info_current = root::rusage_info_v5;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct rlimit {
        pub rlim_cur: root::rlim_t,
        pub rlim_max: root::rlim_t,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct proc_rlimit_control_wakeupmon {
        pub wm_flags: u32,
        pub wm_rate: i32,
    }
    extern "C" {
        pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: root::id_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn getiopolicy_np(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn getrlimit(
            arg1: ::std::os::raw::c_int,
            arg2: *mut root::rlimit,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn getrusage(
            arg1: ::std::os::raw::c_int,
            arg2: *mut root::rusage,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn setpriority(
            arg1: ::std::os::raw::c_int,
            arg2: root::id_t,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn setiopolicy_np(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn setrlimit(
            arg1: ::std::os::raw::c_int,
            arg2: *const root::rlimit,
        ) -> ::std::os::raw::c_int;
    }
    #[repr(C, packed)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct _OSUnalignedU16 {
        pub __val: u16,
    }
    #[repr(C, packed)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct _OSUnalignedU32 {
        pub __val: u32,
    }
    #[repr(C, packed)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct _OSUnalignedU64 {
        pub __val: u64,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union wait {
        pub w_status: ::std::os::raw::c_int,
        pub w_T: root::wait__bindgen_ty_1,
        pub w_S: root::wait__bindgen_ty_2,
    }
    #[repr(C)]
    #[repr(align(4))]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct wait__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
    }
    impl wait__bindgen_ty_1 {
        #[inline]
        pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
        }
        #[inline]
        pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 7u8, val as u64)
            }
        }
        #[inline]
        pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(8usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
        }
        #[inline]
        pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            w_Termsig: ::std::os::raw::c_uint,
            w_Coredump: ::std::os::raw::c_uint,
            w_Retcode: ::std::os::raw::c_uint,
            w_Filler: ::std::os::raw::c_uint,
        ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 7u8, {
                let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
                w_Termsig as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
                w_Coredump as u64
            });
            __bindgen_bitfield_unit.set(8usize, 8u8, {
                let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
                w_Retcode as u64
            });
            __bindgen_bitfield_unit.set(16usize, 16u8, {
                let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
                w_Filler as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct wait__bindgen_ty_2 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
    }
    impl wait__bindgen_ty_2 {
        #[inline]
        pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(8usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
        }
        #[inline]
        pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            w_Stopval: ::std::os::raw::c_uint,
            w_Stopsig: ::std::os::raw::c_uint,
            w_Filler: ::std::os::raw::c_uint,
        ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 8u8, {
                let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
                w_Stopval as u64
            });
            __bindgen_bitfield_unit.set(8usize, 8u8, {
                let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
                w_Stopsig as u64
            });
            __bindgen_bitfield_unit.set(16usize, 16u8, {
                let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
                w_Filler as u64
            });
            __bindgen_bitfield_unit
        }
    }
    impl Default for wait {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        pub fn wait(arg1: *mut ::std::os::raw::c_int) -> root::pid_t;
    }
    extern "C" {
        pub fn waitpid(
            arg1: root::pid_t,
            arg2: *mut ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ) -> root::pid_t;
    }
    extern "C" {
        pub fn waitid(
            arg1: root::idtype_t,
            arg2: root::id_t,
            arg3: *mut root::siginfo_t,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn wait3(
            arg1: *mut ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut root::rusage,
        ) -> root::pid_t;
    }
    extern "C" {
        pub fn wait4(
            arg1: root::pid_t,
            arg2: *mut ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut root::rusage,
        ) -> root::pid_t;
    }
    extern "C" {
        pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
    }
    pub type ct_rune_t = root::__darwin_ct_rune_t;
    pub type rune_t = root::__darwin_rune_t;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct div_t {
        pub quot: ::std::os::raw::c_int,
        pub rem: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct ldiv_t {
        pub quot: ::std::os::raw::c_long,
        pub rem: ::std::os::raw::c_long,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct lldiv_t {
        pub quot: ::std::os::raw::c_longlong,
        pub rem: ::std::os::raw::c_longlong,
    }
    extern "C" {
        pub static mut __mb_cur_max: ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn calloc(
            __count: ::std::os::raw::c_ulong,
            __size: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn free(arg1: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        pub fn realloc(
            __ptr: *mut ::std::os::raw::c_void,
            __size: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn valloc(arg1: root::size_t) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn aligned_alloc(
            __alignment: root::size_t,
            __size: root::size_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn posix_memalign(
            __memptr: *mut *mut ::std::os::raw::c_void,
            __alignment: root::size_t,
            __size: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn abort();
    }
    extern "C" {
        pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>)
            -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
    }
    extern "C" {
        pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn bsearch(
            __key: *const ::std::os::raw::c_void,
            __base: *const ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            __compar: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> root::div_t;
    }
    extern "C" {
        pub fn exit(arg1: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> root::ldiv_t;
    }
    extern "C" {
        pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn lldiv(
            arg1: ::std::os::raw::c_longlong,
            arg2: ::std::os::raw::c_longlong,
        ) -> root::lldiv_t;
    }
    extern "C" {
        pub fn mblen(
            __s: *const ::std::os::raw::c_char,
            __n: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn mbstowcs(
            arg1: *mut root::wchar_t,
            arg2: *const ::std::os::raw::c_char,
            arg3: root::size_t,
        ) -> root::size_t;
    }
    extern "C" {
        pub fn mbtowc(
            arg1: *mut root::wchar_t,
            arg2: *const ::std::os::raw::c_char,
            arg3: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn qsort(
            __base: *mut ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            __compar: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        );
    }
    extern "C" {
        pub fn rand() -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn srand(arg1: ::std::os::raw::c_uint);
    }
    extern "C" {
        pub fn strtod(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> f64;
    }
    extern "C" {
        pub fn strtof(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> f32;
    }
    extern "C" {
        pub fn strtol(
            __str: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn strtold(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> f64;
    }
    extern "C" {
        pub fn strtoll(
            __str: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn strtoul(
            __str: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn strtoull(
            __str: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn wcstombs(
            arg1: *mut ::std::os::raw::c_char,
            arg2: *const root::wchar_t,
            arg3: root::size_t,
        ) -> root::size_t;
    }
    extern "C" {
        pub fn wctomb(
            arg1: *mut ::std::os::raw::c_char,
            arg2: root::wchar_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _Exit(arg1: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn drand48() -> f64;
    }
    extern "C" {
        pub fn ecvt(
            arg1: f64,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
    }
    extern "C" {
        pub fn fcvt(
            arg1: f64,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn gcvt(
            arg1: f64,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn getsubopt(
            arg1: *mut *mut ::std::os::raw::c_char,
            arg2: *const *mut ::std::os::raw::c_char,
            arg3: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn initstate(
            arg1: ::std::os::raw::c_uint,
            arg2: *mut ::std::os::raw::c_char,
            arg3: root::size_t,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
    }
    extern "C" {
        pub fn lrand48() -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn mrand48() -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn ptsname_r(
            fildes: ::std::os::raw::c_int,
            buffer: *mut ::std::os::raw::c_char,
            buflen: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn random() -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
        pub fn realpath(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
    }
    extern "C" {
        pub fn setenv(
            __name: *const ::std::os::raw::c_char,
            __value: *const ::std::os::raw::c_char,
            __overwrite: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn setkey(arg1: *const ::std::os::raw::c_char);
    }
    extern "C" {
        pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn srand48(arg1: ::std::os::raw::c_long);
    }
    extern "C" {
        pub fn srandom(arg1: ::std::os::raw::c_uint);
    }
    extern "C" {
        pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    pub type dev_t = root::__darwin_dev_t;
    pub type mode_t = root::__darwin_mode_t;
    extern "C" {
        pub fn arc4random() -> u32;
    }
    extern "C" {
        pub fn arc4random_addrandom(
            arg1: *mut ::std::os::raw::c_uchar,
            arg2: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: root::size_t);
    }
    extern "C" {
        pub fn arc4random_stir();
    }
    extern "C" {
        pub fn arc4random_uniform(__upper_bound: u32) -> u32;
    }
    extern "C" {
        pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn bsearch_b(
            __key: *const ::std::os::raw::c_void,
            __base: *const ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            __compar: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn cgetcap(
            arg1: *mut ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn cgetclose() -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn cgetent(
            arg1: *mut *mut ::std::os::raw::c_char,
            arg2: *mut *mut ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn cgetfirst(
            arg1: *mut *mut ::std::os::raw::c_char,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn cgetmatch(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn cgetnext(
            arg1: *mut *mut ::std::os::raw::c_char,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn cgetnum(
            arg1: *mut ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn cgetstr(
            arg1: *mut ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn cgetustr(
            arg1: *mut ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn daemon(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn devname(arg1: root::dev_t, arg2: root::mode_t) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn devname_r(
            arg1: root::dev_t,
            arg2: root::mode_t,
            buf: *mut ::std::os::raw::c_char,
            len: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn getbsize(
            arg1: *mut ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_long,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn getprogname() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn setprogname(arg1: *const ::std::os::raw::c_char);
    }
    extern "C" {
        pub fn heapsort(
            __base: *mut ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            __compar: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn heapsort_b(
            __base: *mut ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            __compar: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn mergesort(
            __base: *mut ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            __compar: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn mergesort_b(
            __base: *mut ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            __compar: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn psort(
            __base: *mut ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            __compar: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        );
    }
    extern "C" {
        pub fn psort_b(
            __base: *mut ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            __compar: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        pub fn psort_r(
            __base: *mut ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            arg1: *mut ::std::os::raw::c_void,
            __compar: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                    arg3: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        );
    }
    extern "C" {
        pub fn qsort_b(
            __base: *mut ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            __compar: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        pub fn qsort_r(
            __base: *mut ::std::os::raw::c_void,
            __nel: root::size_t,
            __width: root::size_t,
            arg1: *mut ::std::os::raw::c_void,
            __compar: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                    arg3: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        );
    }
    extern "C" {
        pub fn radixsort(
            __base: *mut *const ::std::os::raw::c_uchar,
            __nel: ::std::os::raw::c_int,
            __table: *const ::std::os::raw::c_uchar,
            __endbyte: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn sradixsort(
            __base: *mut *const ::std::os::raw::c_uchar,
            __nel: ::std::os::raw::c_int,
            __table: *const ::std::os::raw::c_uchar,
            __endbyte: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn sranddev();
    }
    extern "C" {
        pub fn srandomdev();
    }
    extern "C" {
        pub fn reallocf(
            __ptr: *mut ::std::os::raw::c_void,
            __size: root::size_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn strtonum(
            __numstr: *const ::std::os::raw::c_char,
            __minval: ::std::os::raw::c_longlong,
            __maxval: ::std::os::raw::c_longlong,
            __errstrp: *mut *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn strtoq(
            __str: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn strtouq(
            __str: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        pub static mut suboptarg: *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn memchr(
            __s: *const ::std::os::raw::c_void,
            __c: ::std::os::raw::c_int,
            __n: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn memcmp(
            __s1: *const ::std::os::raw::c_void,
            __s2: *const ::std::os::raw::c_void,
            __n: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn memcpy(
            __dst: *mut ::std::os::raw::c_void,
            __src: *const ::std::os::raw::c_void,
            __n: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn memmove(
            __dst: *mut ::std::os::raw::c_void,
            __src: *const ::std::os::raw::c_void,
            __len: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn memset(
            __b: *mut ::std::os::raw::c_void,
            __c: ::std::os::raw::c_int,
            __len: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn strcat(
            __s1: *mut ::std::os::raw::c_char,
            __s2: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strchr(
            __s: *const ::std::os::raw::c_char,
            __c: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strcmp(
            __s1: *const ::std::os::raw::c_char,
            __s2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn strcoll(
            __s1: *const ::std::os::raw::c_char,
            __s2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn strcpy(
            __dst: *mut ::std::os::raw::c_char,
            __src: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strcspn(
            __s: *const ::std::os::raw::c_char,
            __charset: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn strncat(
            __s1: *mut ::std::os::raw::c_char,
            __s2: *const ::std::os::raw::c_char,
            __n: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strncmp(
            __s1: *const ::std::os::raw::c_char,
            __s2: *const ::std::os::raw::c_char,
            __n: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn strncpy(
            __dst: *mut ::std::os::raw::c_char,
            __src: *const ::std::os::raw::c_char,
            __n: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strpbrk(
            __s: *const ::std::os::raw::c_char,
            __charset: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strrchr(
            __s: *const ::std::os::raw::c_char,
            __c: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strspn(
            __s: *const ::std::os::raw::c_char,
            __charset: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn strstr(
            __big: *const ::std::os::raw::c_char,
            __little: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strtok(
            __str: *mut ::std::os::raw::c_char,
            __sep: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strxfrm(
            __s1: *mut ::std::os::raw::c_char,
            __s2: *const ::std::os::raw::c_char,
            __n: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn strtok_r(
            __str: *mut ::std::os::raw::c_char,
            __sep: *const ::std::os::raw::c_char,
            __lasts: *mut *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strerror_r(
            __errnum: ::std::os::raw::c_int,
            __strerrbuf: *mut ::std::os::raw::c_char,
            __buflen: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn memccpy(
            __dst: *mut ::std::os::raw::c_void,
            __src: *const ::std::os::raw::c_void,
            __c: ::std::os::raw::c_int,
            __n: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn stpcpy(
            __dst: *mut ::std::os::raw::c_char,
            __src: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn stpncpy(
            __dst: *mut ::std::os::raw::c_char,
            __src: *const ::std::os::raw::c_char,
            __n: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strndup(
            __s1: *const ::std::os::raw::c_char,
            __n: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: root::size_t) -> root::size_t;
    }
    extern "C" {
        pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    }
    pub type rsize_t = root::__darwin_size_t;
    extern "C" {
        pub fn memset_s(
            __s: *mut ::std::os::raw::c_void,
            __smax: root::rsize_t,
            __c: ::std::os::raw::c_int,
            __n: root::rsize_t,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn memmem(
            __big: *const ::std::os::raw::c_void,
            __big_len: root::size_t,
            __little: *const ::std::os::raw::c_void,
            __little_len: root::size_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn memset_pattern4(
            __b: *mut ::std::os::raw::c_void,
            __pattern4: *const ::std::os::raw::c_void,
            __len: root::size_t,
        );
    }
    extern "C" {
        pub fn memset_pattern8(
            __b: *mut ::std::os::raw::c_void,
            __pattern8: *const ::std::os::raw::c_void,
            __len: root::size_t,
        );
    }
    extern "C" {
        pub fn memset_pattern16(
            __b: *mut ::std::os::raw::c_void,
            __pattern16: *const ::std::os::raw::c_void,
            __len: root::size_t,
        );
    }
    extern "C" {
        pub fn strcasestr(
            __big: *const ::std::os::raw::c_char,
            __little: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strnstr(
            __big: *const ::std::os::raw::c_char,
            __little: *const ::std::os::raw::c_char,
            __len: root::size_t,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn strlcat(
            __dst: *mut ::std::os::raw::c_char,
            __source: *const ::std::os::raw::c_char,
            __size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn strlcpy(
            __dst: *mut ::std::os::raw::c_char,
            __source: *const ::std::os::raw::c_char,
            __size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
    }
    extern "C" {
        pub fn strsep(
            __stringp: *mut *mut ::std::os::raw::c_char,
            __delim: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn swab(
            arg1: *const ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_void,
            arg3: root::ssize_t,
        );
    }
    extern "C" {
        pub fn timingsafe_bcmp(
            __b1: *const ::std::os::raw::c_void,
            __b2: *const ::std::os::raw::c_void,
            __len: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn strsignal_r(
            __sig: ::std::os::raw::c_int,
            __strsignalbuf: *mut ::std::os::raw::c_char,
            __buflen: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn bcmp(
            arg1: *const ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn bcopy(
            arg1: *const ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_void,
            arg3: root::size_t,
        );
    }
    extern "C" {
        pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
    }
    extern "C" {
        pub fn index(
            arg1: *const ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn rindex(
            arg1: *const ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn strcasecmp(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn strncasecmp(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_log2(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_log2_16bit(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Allocate a memory block with alignment suitable for all memory accesses"]
        #[doc = " (including vectors if available on the CPU)."]
        #[doc = ""]
        #[doc = " @param size Size in bytes for the memory block to be allocated"]
        #[doc = " @return Pointer to the allocated block, or `NULL` if the block cannot"]
        #[doc = "         be allocated"]
        #[doc = " @see av_mallocz()"]
        pub fn av_malloc(size: root::size_t) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Allocate a memory block with alignment suitable for all memory accesses"]
        #[doc = " (including vectors if available on the CPU) and zero all the bytes of the"]
        #[doc = " block."]
        #[doc = ""]
        #[doc = " @param size Size in bytes for the memory block to be allocated"]
        #[doc = " @return Pointer to the allocated block, or `NULL` if it cannot be allocated"]
        #[doc = " @see av_malloc()"]
        pub fn av_mallocz(size: root::size_t) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Allocate a memory block for an array with av_malloc()."]
        #[doc = ""]
        #[doc = " The allocated memory will have size `size * nmemb` bytes."]
        #[doc = ""]
        #[doc = " @param nmemb Number of element"]
        #[doc = " @param size  Size of a single element"]
        #[doc = " @return Pointer to the allocated block, or `NULL` if the block cannot"]
        #[doc = "         be allocated"]
        #[doc = " @see av_malloc()"]
        pub fn av_malloc_array(
            nmemb: root::size_t,
            size: root::size_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Allocate a memory block for an array with av_mallocz()."]
        #[doc = ""]
        #[doc = " The allocated memory will have size `size * nmemb` bytes."]
        #[doc = ""]
        #[doc = " @param nmemb Number of elements"]
        #[doc = " @param size  Size of the single element"]
        #[doc = " @return Pointer to the allocated block, or `NULL` if the block cannot"]
        #[doc = "         be allocated"]
        #[doc = ""]
        #[doc = " @see av_mallocz()"]
        #[doc = " @see av_malloc_array()"]
        pub fn av_calloc(nmemb: root::size_t, size: root::size_t) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " @deprecated use av_calloc()"]
        pub fn av_mallocz_array(
            nmemb: root::size_t,
            size: root::size_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Allocate, reallocate, or free a block of memory."]
        #[doc = ""]
        #[doc = " If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is"]
        #[doc = " zero, free the memory block pointed to by `ptr`. Otherwise, expand or"]
        #[doc = " shrink that block of memory according to `size`."]
        #[doc = ""]
        #[doc = " @param ptr  Pointer to a memory block already allocated with"]
        #[doc = "             av_realloc() or `NULL`"]
        #[doc = " @param size Size in bytes of the memory block to be allocated or"]
        #[doc = "             reallocated"]
        #[doc = ""]
        #[doc = " @return Pointer to a newly-reallocated block or `NULL` if the block"]
        #[doc = "         cannot be reallocated or the function is used to free the memory block"]
        #[doc = ""]
        #[doc = " @warning Unlike av_malloc(), the returned pointer is not guaranteed to be"]
        #[doc = "          correctly aligned."]
        #[doc = " @see av_fast_realloc()"]
        #[doc = " @see av_reallocp()"]
        pub fn av_realloc(
            ptr: *mut ::std::os::raw::c_void,
            size: root::size_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Allocate, reallocate, or free a block of memory through a pointer to a"]
        #[doc = " pointer."]
        #[doc = ""]
        #[doc = " If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is"]
        #[doc = " zero, free the memory block pointed to by `*ptr`. Otherwise, expand or"]
        #[doc = " shrink that block of memory according to `size`."]
        #[doc = ""]
        #[doc = " @param[in,out] ptr  Pointer to a pointer to a memory block already allocated"]
        #[doc = "                     with av_realloc(), or a pointer to `NULL`. The pointer"]
        #[doc = "                     is updated on success, or freed on failure."]
        #[doc = " @param[in]     size Size in bytes for the memory block to be allocated or"]
        #[doc = "                     reallocated"]
        #[doc = ""]
        #[doc = " @return Zero on success, an AVERROR error code on failure"]
        #[doc = ""]
        #[doc = " @warning Unlike av_malloc(), the allocated memory is not guaranteed to be"]
        #[doc = "          correctly aligned."]
        pub fn av_reallocp(
            ptr: *mut ::std::os::raw::c_void,
            size: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Allocate, reallocate, or free a block of memory."]
        #[doc = ""]
        #[doc = " This function does the same thing as av_realloc(), except:"]
        #[doc = " - It takes two size arguments and allocates `nelem * elsize` bytes,"]
        #[doc = "   after checking the result of the multiplication for integer overflow."]
        #[doc = " - It frees the input block in case of failure, thus avoiding the memory"]
        #[doc = "   leak with the classic"]
        #[doc = "   @code{.c}"]
        #[doc = "   buf = realloc(buf);"]
        #[doc = "   if (!buf)"]
        #[doc = "       return -1;"]
        #[doc = "   @endcode"]
        #[doc = "   pattern."]
        pub fn av_realloc_f(
            ptr: *mut ::std::os::raw::c_void,
            nelem: root::size_t,
            elsize: root::size_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Allocate, reallocate, or free an array."]
        #[doc = ""]
        #[doc = " If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If"]
        #[doc = " `nmemb` is zero, free the memory block pointed to by `ptr`."]
        #[doc = ""]
        #[doc = " @param ptr   Pointer to a memory block already allocated with"]
        #[doc = "              av_realloc() or `NULL`"]
        #[doc = " @param nmemb Number of elements in the array"]
        #[doc = " @param size  Size of the single element of the array"]
        #[doc = ""]
        #[doc = " @return Pointer to a newly-reallocated block or NULL if the block"]
        #[doc = "         cannot be reallocated or the function is used to free the memory block"]
        #[doc = ""]
        #[doc = " @warning Unlike av_malloc(), the allocated memory is not guaranteed to be"]
        #[doc = "          correctly aligned."]
        #[doc = " @see av_reallocp_array()"]
        pub fn av_realloc_array(
            ptr: *mut ::std::os::raw::c_void,
            nmemb: root::size_t,
            size: root::size_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Allocate, reallocate, or free an array through a pointer to a pointer."]
        #[doc = ""]
        #[doc = " If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is"]
        #[doc = " zero, free the memory block pointed to by `*ptr`."]
        #[doc = ""]
        #[doc = " @param[in,out] ptr   Pointer to a pointer to a memory block already"]
        #[doc = "                      allocated with av_realloc(), or a pointer to `NULL`."]
        #[doc = "                      The pointer is updated on success, or freed on failure."]
        #[doc = " @param[in]     nmemb Number of elements"]
        #[doc = " @param[in]     size  Size of the single element"]
        #[doc = ""]
        #[doc = " @return Zero on success, an AVERROR error code on failure"]
        #[doc = ""]
        #[doc = " @warning Unlike av_malloc(), the allocated memory is not guaranteed to be"]
        #[doc = "          correctly aligned."]
        pub fn av_reallocp_array(
            ptr: *mut ::std::os::raw::c_void,
            nmemb: root::size_t,
            size: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Reallocate the given buffer if it is not large enough, otherwise do nothing."]
        #[doc = ""]
        #[doc = " If the given buffer is `NULL`, then a new uninitialized buffer is allocated."]
        #[doc = ""]
        #[doc = " If the given buffer is not large enough, and reallocation fails, `NULL` is"]
        #[doc = " returned and `*size` is set to 0, but the original buffer is not changed or"]
        #[doc = " freed."]
        #[doc = ""]
        #[doc = " A typical use pattern follows:"]
        #[doc = ""]
        #[doc = " @code{.c}"]
        #[doc = " uint8_t *buf = ...;"]
        #[doc = " uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);"]
        #[doc = " if (!new_buf) {"]
        #[doc = "     // Allocation failed; clean up original buffer"]
        #[doc = "     av_freep(&buf);"]
        #[doc = "     return AVERROR(ENOMEM);"]
        #[doc = " }"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @param[in,out] ptr      Already allocated buffer, or `NULL`"]
        #[doc = " @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is"]
        #[doc = "                         updated to the new allocated size, in particular 0"]
        #[doc = "                         in case of failure."]
        #[doc = " @param[in]     min_size Desired minimal size of buffer `ptr`"]
        #[doc = " @return `ptr` if the buffer is large enough, a pointer to newly reallocated"]
        #[doc = "         buffer if the buffer was not large enough, or `NULL` in case of"]
        #[doc = "         error"]
        #[doc = " @see av_realloc()"]
        #[doc = " @see av_fast_malloc()"]
        pub fn av_fast_realloc(
            ptr: *mut ::std::os::raw::c_void,
            size: *mut ::std::os::raw::c_uint,
            min_size: root::size_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Allocate a buffer, reusing the given one if large enough."]
        #[doc = ""]
        #[doc = " Contrary to av_fast_realloc(), the current buffer contents might not be"]
        #[doc = " preserved and on error the old buffer is freed, thus no special handling to"]
        #[doc = " avoid memleaks is necessary."]
        #[doc = ""]
        #[doc = " `*ptr` is allowed to be `NULL`, in which case allocation always happens if"]
        #[doc = " `size_needed` is greater than 0."]
        #[doc = ""]
        #[doc = " @code{.c}"]
        #[doc = " uint8_t *buf = ...;"]
        #[doc = " av_fast_malloc(&buf, &current_size, size_needed);"]
        #[doc = " if (!buf) {"]
        #[doc = "     // Allocation failed; buf already freed"]
        #[doc = "     return AVERROR(ENOMEM);"]
        #[doc = " }"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @param[in,out] ptr      Pointer to pointer to an already allocated buffer."]
        #[doc = "                         `*ptr` will be overwritten with pointer to new"]
        #[doc = "                         buffer on success or `NULL` on failure"]
        #[doc = " @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is"]
        #[doc = "                         updated to the new allocated size, in particular 0"]
        #[doc = "                         in case of failure."]
        #[doc = " @param[in]     min_size Desired minimal size of buffer `*ptr`"]
        #[doc = " @see av_realloc()"]
        #[doc = " @see av_fast_mallocz()"]
        pub fn av_fast_malloc(
            ptr: *mut ::std::os::raw::c_void,
            size: *mut ::std::os::raw::c_uint,
            min_size: root::size_t,
        );
    }
    extern "C" {
        #[doc = " Allocate and clear a buffer, reusing the given one if large enough."]
        #[doc = ""]
        #[doc = " Like av_fast_malloc(), but all newly allocated space is initially cleared."]
        #[doc = " Reused buffer is not cleared."]
        #[doc = ""]
        #[doc = " `*ptr` is allowed to be `NULL`, in which case allocation always happens if"]
        #[doc = " `size_needed` is greater than 0."]
        #[doc = ""]
        #[doc = " @param[in,out] ptr      Pointer to pointer to an already allocated buffer."]
        #[doc = "                         `*ptr` will be overwritten with pointer to new"]
        #[doc = "                         buffer on success or `NULL` on failure"]
        #[doc = " @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is"]
        #[doc = "                         updated to the new allocated size, in particular 0"]
        #[doc = "                         in case of failure."]
        #[doc = " @param[in]     min_size Desired minimal size of buffer `*ptr`"]
        #[doc = " @see av_fast_malloc()"]
        pub fn av_fast_mallocz(
            ptr: *mut ::std::os::raw::c_void,
            size: *mut ::std::os::raw::c_uint,
            min_size: root::size_t,
        );
    }
    extern "C" {
        #[doc = " Free a memory block which has been allocated with a function of av_malloc()"]
        #[doc = " or av_realloc() family."]
        #[doc = ""]
        #[doc = " @param ptr Pointer to the memory block which should be freed."]
        #[doc = ""]
        #[doc = " @note `ptr = NULL` is explicitly allowed."]
        #[doc = " @note It is recommended that you use av_freep() instead, to prevent leaving"]
        #[doc = "       behind dangling pointers."]
        #[doc = " @see av_freep()"]
        pub fn av_free(ptr: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " Free a memory block which has been allocated with a function of av_malloc()"]
        #[doc = " or av_realloc() family, and set the pointer pointing to it to `NULL`."]
        #[doc = ""]
        #[doc = " @code{.c}"]
        #[doc = " uint8_t *buf = av_malloc(16);"]
        #[doc = " av_free(buf);"]
        #[doc = " // buf now contains a dangling pointer to freed memory, and accidental"]
        #[doc = " // dereference of buf will result in a use-after-free, which may be a"]
        #[doc = " // security risk."]
        #[doc = ""]
        #[doc = " uint8_t *buf = av_malloc(16);"]
        #[doc = " av_freep(&buf);"]
        #[doc = " // buf is now NULL, and accidental dereference will only result in a"]
        #[doc = " // NULL-pointer dereference."]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @param ptr Pointer to the pointer to the memory block which should be freed"]
        #[doc = " @note `*ptr = NULL` is safe and leads to no action."]
        #[doc = " @see av_free()"]
        pub fn av_freep(ptr: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " Duplicate a string."]
        #[doc = ""]
        #[doc = " @param s String to be duplicated"]
        #[doc = " @return Pointer to a newly-allocated string containing a"]
        #[doc = "         copy of `s` or `NULL` if the string cannot be allocated"]
        #[doc = " @see av_strndup()"]
        pub fn av_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Duplicate a substring of a string."]
        #[doc = ""]
        #[doc = " @param s   String to be duplicated"]
        #[doc = " @param len Maximum length of the resulting string (not counting the"]
        #[doc = "            terminating byte)"]
        #[doc = " @return Pointer to a newly-allocated string containing a"]
        #[doc = "         substring of `s` or `NULL` if the string cannot be allocated"]
        pub fn av_strndup(
            s: *const ::std::os::raw::c_char,
            len: root::size_t,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Duplicate a buffer with av_malloc()."]
        #[doc = ""]
        #[doc = " @param p    Buffer to be duplicated"]
        #[doc = " @param size Size in bytes of the buffer copied"]
        #[doc = " @return Pointer to a newly allocated buffer containing a"]
        #[doc = "         copy of `p` or `NULL` if the buffer cannot be allocated"]
        pub fn av_memdup(
            p: *const ::std::os::raw::c_void,
            size: root::size_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Overlapping memcpy() implementation."]
        #[doc = ""]
        #[doc = " @param dst  Destination buffer"]
        #[doc = " @param back Number of bytes back to start copying (i.e. the initial size of"]
        #[doc = "             the overlapping window); must be > 0"]
        #[doc = " @param cnt  Number of bytes to copy; must be >= 0"]
        #[doc = ""]
        #[doc = " @note `cnt > back` is valid, this will copy the bytes we just copied,"]
        #[doc = "       thus creating a repeating pattern with a period length of `back`."]
        pub fn av_memcpy_backptr(
            dst: *mut u8,
            back: ::std::os::raw::c_int,
            cnt: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Add the pointer to an element to a dynamic array."]
        #[doc = ""]
        #[doc = " The array to grow is supposed to be an array of pointers to"]
        #[doc = " structures, and the element to add must be a pointer to an already"]
        #[doc = " allocated structure."]
        #[doc = ""]
        #[doc = " The array is reallocated when its size reaches powers of 2."]
        #[doc = " Therefore, the amortized cost of adding an element is constant."]
        #[doc = ""]
        #[doc = " In case of success, the pointer to the array is updated in order to"]
        #[doc = " point to the new grown array, and the number pointed to by `nb_ptr`"]
        #[doc = " is incremented."]
        #[doc = " In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and"]
        #[doc = " `*nb_ptr` is set to 0."]
        #[doc = ""]
        #[doc = " @param[in,out] tab_ptr Pointer to the array to grow"]
        #[doc = " @param[in,out] nb_ptr  Pointer to the number of elements in the array"]
        #[doc = " @param[in]     elem    Element to add"]
        #[doc = " @see av_dynarray_add_nofree(), av_dynarray2_add()"]
        pub fn av_dynarray_add(
            tab_ptr: *mut ::std::os::raw::c_void,
            nb_ptr: *mut ::std::os::raw::c_int,
            elem: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[doc = " Add an element to a dynamic array."]
        #[doc = ""]
        #[doc = " Function has the same functionality as av_dynarray_add(),"]
        #[doc = " but it doesn't free memory on fails. It returns error code"]
        #[doc = " instead and leave current buffer untouched."]
        #[doc = ""]
        #[doc = " @return >=0 on success, negative otherwise"]
        #[doc = " @see av_dynarray_add(), av_dynarray2_add()"]
        pub fn av_dynarray_add_nofree(
            tab_ptr: *mut ::std::os::raw::c_void,
            nb_ptr: *mut ::std::os::raw::c_int,
            elem: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Add an element of size `elem_size` to a dynamic array."]
        #[doc = ""]
        #[doc = " The array is reallocated when its number of elements reaches powers of 2."]
        #[doc = " Therefore, the amortized cost of adding an element is constant."]
        #[doc = ""]
        #[doc = " In case of success, the pointer to the array is updated in order to"]
        #[doc = " point to the new grown array, and the number pointed to by `nb_ptr`"]
        #[doc = " is incremented."]
        #[doc = " In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and"]
        #[doc = " `*nb_ptr` is set to 0."]
        #[doc = ""]
        #[doc = " @param[in,out] tab_ptr   Pointer to the array to grow"]
        #[doc = " @param[in,out] nb_ptr    Pointer to the number of elements in the array"]
        #[doc = " @param[in]     elem_size Size in bytes of an element in the array"]
        #[doc = " @param[in]     elem_data Pointer to the data of the element to add. If"]
        #[doc = "                          `NULL`, the space of the newly added element is"]
        #[doc = "                          allocated but left uninitialized."]
        #[doc = ""]
        #[doc = " @return Pointer to the data of the element to copy in the newly allocated"]
        #[doc = "         space"]
        #[doc = " @see av_dynarray_add(), av_dynarray_add_nofree()"]
        pub fn av_dynarray2_add(
            tab_ptr: *mut *mut ::std::os::raw::c_void,
            nb_ptr: *mut ::std::os::raw::c_int,
            elem_size: root::size_t,
            elem_data: *const u8,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Multiply two `size_t` values checking for overflow."]
        #[doc = ""]
        #[doc = " @param[in]  a,b Operands of multiplication"]
        #[doc = " @param[out] r   Pointer to the result of the operation"]
        #[doc = " @return 0 on success, AVERROR(EINVAL) on overflow"]
        pub fn av_size_mult(
            a: root::size_t,
            b: root::size_t,
            r: *mut root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Set the maximum size that may be allocated in one block."]
        #[doc = ""]
        #[doc = " The value specified with this function is effective for all libavutil's @ref"]
        #[doc = " lavu_mem_funcs \"heap management functions.\""]
        #[doc = ""]
        #[doc = " By default, the max value is defined as `INT_MAX`."]
        #[doc = ""]
        #[doc = " @param max Value to be set as the new maximum size"]
        #[doc = ""]
        #[doc = " @warning Exercise extreme caution when using this function. Don't touch"]
        #[doc = "          this if you do not understand the full consequence of doing so."]
        pub fn av_max_alloc(max: root::size_t);
    }
    extern "C" {
        #[doc = " Put a description of the AVERROR code errnum in errbuf."]
        #[doc = " In case of failure the global variable errno is set to indicate the"]
        #[doc = " error. Even in case of failure av_strerror() will print a generic"]
        #[doc = " error message indicating the errnum provided to errbuf."]
        #[doc = ""]
        #[doc = " @param errnum      error code to describe"]
        #[doc = " @param errbuf      buffer to which description is written"]
        #[doc = " @param errbuf_size the size in bytes of errbuf"]
        #[doc = " @return 0 on success, a negative value if a description for errnum"]
        #[doc = " cannot be found"]
        pub fn av_strerror(
            errnum: ::std::os::raw::c_int,
            errbuf: *mut ::std::os::raw::c_char,
            errbuf_size: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " Rational number (pair of numerator and denominator)."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVRational {
        #[doc = "< Numerator"]
        pub num: ::std::os::raw::c_int,
        #[doc = "< Denominator"]
        pub den: ::std::os::raw::c_int,
    }
    extern "C" {
        #[doc = " Reduce a fraction."]
        #[doc = ""]
        #[doc = " This is useful for framerate calculations."]
        #[doc = ""]
        #[doc = " @param[out] dst_num Destination numerator"]
        #[doc = " @param[out] dst_den Destination denominator"]
        #[doc = " @param[in]      num Source numerator"]
        #[doc = " @param[in]      den Source denominator"]
        #[doc = " @param[in]      max Maximum allowed values for `dst_num` & `dst_den`"]
        #[doc = " @return 1 if the operation is exact, 0 otherwise"]
        pub fn av_reduce(
            dst_num: *mut ::std::os::raw::c_int,
            dst_den: *mut ::std::os::raw::c_int,
            num: i64,
            den: i64,
            max: i64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Multiply two rationals."]
        #[doc = " @param b First rational"]
        #[doc = " @param c Second rational"]
        #[doc = " @return b*c"]
        pub fn av_mul_q(b: root::AVRational, c: root::AVRational) -> root::AVRational;
    }
    extern "C" {
        #[doc = " Divide one rational by another."]
        #[doc = " @param b First rational"]
        #[doc = " @param c Second rational"]
        #[doc = " @return b/c"]
        pub fn av_div_q(b: root::AVRational, c: root::AVRational) -> root::AVRational;
    }
    extern "C" {
        #[doc = " Add two rationals."]
        #[doc = " @param b First rational"]
        #[doc = " @param c Second rational"]
        #[doc = " @return b+c"]
        pub fn av_add_q(b: root::AVRational, c: root::AVRational) -> root::AVRational;
    }
    extern "C" {
        #[doc = " Subtract one rational from another."]
        #[doc = " @param b First rational"]
        #[doc = " @param c Second rational"]
        #[doc = " @return b-c"]
        pub fn av_sub_q(b: root::AVRational, c: root::AVRational) -> root::AVRational;
    }
    extern "C" {
        #[doc = " Convert a double precision floating point number to a rational."]
        #[doc = ""]
        #[doc = " In case of infinity, the returned value is expressed as `{1, 0}` or"]
        #[doc = " `{-1, 0}` depending on the sign."]
        #[doc = ""]
        #[doc = " @param d   `double` to convert"]
        #[doc = " @param max Maximum allowed numerator and denominator"]
        #[doc = " @return `d` in AVRational form"]
        #[doc = " @see av_q2d()"]
        pub fn av_d2q(d: f64, max: ::std::os::raw::c_int) -> root::AVRational;
    }
    extern "C" {
        #[doc = " Find which of the two rationals is closer to another rational."]
        #[doc = ""]
        #[doc = " @param q     Rational to be compared against"]
        #[doc = " @param q1,q2 Rationals to be tested"]
        #[doc = " @return One of the following values:"]
        #[doc = "         - 1 if `q1` is nearer to `q` than `q2`"]
        #[doc = "         - -1 if `q2` is nearer to `q` than `q1`"]
        #[doc = "         - 0 if they have the same distance"]
        pub fn av_nearer_q(
            q: root::AVRational,
            q1: root::AVRational,
            q2: root::AVRational,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Find the value in a list of rationals nearest a given reference rational."]
        #[doc = ""]
        #[doc = " @param q      Reference rational"]
        #[doc = " @param q_list Array of rationals terminated by `{0, 0}`"]
        #[doc = " @return Index of the nearest value found in the array"]
        pub fn av_find_nearest_q_idx(
            q: root::AVRational,
            q_list: *const root::AVRational,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point"]
        #[doc = " format."]
        #[doc = ""]
        #[doc = " @param q Rational to be converted"]
        #[doc = " @return Equivalent floating-point value, expressed as an unsigned 32-bit"]
        #[doc = "         integer."]
        #[doc = " @note The returned value is platform-indepedant."]
        pub fn av_q2intfloat(q: root::AVRational) -> u32;
    }
    extern "C" {
        #[doc = " Return the best rational so that a and b are multiple of it."]
        #[doc = " If the resulting denominator is larger than max_den, return def."]
        pub fn av_gcd_q(
            a: root::AVRational,
            b: root::AVRational,
            max_den: ::std::os::raw::c_int,
            def: root::AVRational,
        ) -> root::AVRational;
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union av_intfloat32 {
        pub i: u32,
        pub f: f32,
    }
    impl Default for av_intfloat32 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union av_intfloat64 {
        pub i: u64,
        pub f: f64,
    }
    impl Default for av_intfloat64 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = "< Round toward zero."]
    pub const AVRounding_AV_ROUND_ZERO: root::AVRounding = 0;
    #[doc = "< Round away from zero."]
    pub const AVRounding_AV_ROUND_INF: root::AVRounding = 1;
    #[doc = "< Round toward -infinity."]
    pub const AVRounding_AV_ROUND_DOWN: root::AVRounding = 2;
    #[doc = "< Round toward +infinity."]
    pub const AVRounding_AV_ROUND_UP: root::AVRounding = 3;
    #[doc = "< Round to nearest and halfway cases away from zero."]
    pub const AVRounding_AV_ROUND_NEAR_INF: root::AVRounding = 5;
    #[doc = " Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through"]
    #[doc = " unchanged, avoiding special cases for #AV_NOPTS_VALUE."]
    #[doc = ""]
    #[doc = " Unlike other values of the enumeration AVRounding, this value is a"]
    #[doc = " bitmask that must be used in conjunction with another value of the"]
    #[doc = " enumeration through a bitwise OR, in order to set behavior for normal"]
    #[doc = " cases."]
    #[doc = ""]
    #[doc = " @code{.c}"]
    #[doc = " av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);"]
    #[doc = " // Rescaling 3:"]
    #[doc = " //     Calculating 3 * 1 / 2"]
    #[doc = " //     3 / 2 is rounded up to 2"]
    #[doc = " //     => 2"]
    #[doc = ""]
    #[doc = " av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);"]
    #[doc = " // Rescaling AV_NOPTS_VALUE:"]
    #[doc = " //     AV_NOPTS_VALUE == INT64_MIN"]
    #[doc = " //     AV_NOPTS_VALUE is passed through"]
    #[doc = " //     => AV_NOPTS_VALUE"]
    #[doc = " @endcode"]
    pub const AVRounding_AV_ROUND_PASS_MINMAX: root::AVRounding = 8192;
    #[doc = " Rounding methods."]
    pub type AVRounding = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Compute the greatest common divisor of two integer operands."]
        #[doc = ""]
        #[doc = " @param a,b Operands"]
        #[doc = " @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;"]
        #[doc = " if a == 0 and b == 0, returns 0."]
        pub fn av_gcd(a: i64, b: i64) -> i64;
    }
    extern "C" {
        #[doc = " Rescale a 64-bit integer with rounding to nearest."]
        #[doc = ""]
        #[doc = " The operation is mathematically equivalent to `a * b / c`, but writing that"]
        #[doc = " directly can overflow."]
        #[doc = ""]
        #[doc = " This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF."]
        #[doc = ""]
        #[doc = " @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()"]
        pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
    }
    extern "C" {
        #[doc = " Rescale a 64-bit integer with specified rounding."]
        #[doc = ""]
        #[doc = " The operation is mathematically equivalent to `a * b / c`, but writing that"]
        #[doc = " directly can overflow, and does not support different rounding methods."]
        #[doc = " If the result is not representable then INT64_MIN is returned."]
        #[doc = ""]
        #[doc = " @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()"]
        pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: root::AVRounding) -> i64;
    }
    extern "C" {
        #[doc = " Rescale a 64-bit integer by 2 rational numbers."]
        #[doc = ""]
        #[doc = " The operation is mathematically equivalent to `a * bq / cq`."]
        #[doc = ""]
        #[doc = " This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF."]
        #[doc = ""]
        #[doc = " @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()"]
        pub fn av_rescale_q(a: i64, bq: root::AVRational, cq: root::AVRational) -> i64;
    }
    extern "C" {
        #[doc = " Rescale a 64-bit integer by 2 rational numbers with specified rounding."]
        #[doc = ""]
        #[doc = " The operation is mathematically equivalent to `a * bq / cq`."]
        #[doc = ""]
        #[doc = " @see av_rescale(), av_rescale_rnd(), av_rescale_q()"]
        pub fn av_rescale_q_rnd(
            a: i64,
            bq: root::AVRational,
            cq: root::AVRational,
            rnd: root::AVRounding,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Compare two timestamps each in its own time base."]
        #[doc = ""]
        #[doc = " @return One of the following values:"]
        #[doc = "         - -1 if `ts_a` is before `ts_b`"]
        #[doc = "         - 1 if `ts_a` is after `ts_b`"]
        #[doc = "         - 0 if they represent the same position"]
        #[doc = ""]
        #[doc = " @warning"]
        #[doc = " The result of the function is undefined if one of the timestamps is outside"]
        #[doc = " the `int64_t` range when represented in the other's timebase."]
        pub fn av_compare_ts(
            ts_a: i64,
            tb_a: root::AVRational,
            ts_b: i64,
            tb_b: root::AVRational,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Compare the remainders of two integer operands divided by a common divisor."]
        #[doc = ""]
        #[doc = " In other words, compare the least significant `log2(mod)` bits of integers"]
        #[doc = " `a` and `b`."]
        #[doc = ""]
        #[doc = " @code{.c}"]
        #[doc = " av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)"]
        #[doc = " av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @param a,b Operands"]
        #[doc = " @param mod Divisor; must be a power of 2"]
        #[doc = " @return"]
        #[doc = "         - a negative value if `a % mod < b % mod`"]
        #[doc = "         - a positive value if `a % mod > b % mod`"]
        #[doc = "         - zero             if `a % mod == b % mod`"]
        pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
    }
    extern "C" {
        #[doc = " Rescale a timestamp while preserving known durations."]
        #[doc = ""]
        #[doc = " This function is designed to be called per audio packet to scale the input"]
        #[doc = " timestamp to a different time base. Compared to a simple av_rescale_q()"]
        #[doc = " call, this function is robust against possible inconsistent frame durations."]
        #[doc = ""]
        #[doc = " The `last` parameter is a state variable that must be preserved for all"]
        #[doc = " subsequent calls for the same stream. For the first call, `*last` should be"]
        #[doc = " initialized to #AV_NOPTS_VALUE."]
        #[doc = ""]
        #[doc = " @param[in]     in_tb    Input time base"]
        #[doc = " @param[in]     in_ts    Input timestamp"]
        #[doc = " @param[in]     fs_tb    Duration time base; typically this is finer-grained"]
        #[doc = "                         (greater) than `in_tb` and `out_tb`"]
        #[doc = " @param[in]     duration Duration till the next call to this function (i.e."]
        #[doc = "                         duration of the current packet/frame)"]
        #[doc = " @param[in,out] last     Pointer to a timestamp expressed in terms of"]
        #[doc = "                         `fs_tb`, acting as a state variable"]
        #[doc = " @param[in]     out_tb   Output timebase"]
        #[doc = " @return        Timestamp expressed in terms of `out_tb`"]
        #[doc = ""]
        #[doc = " @note In the context of this function, \"duration\" is in term of samples, not"]
        #[doc = "       seconds."]
        pub fn av_rescale_delta(
            in_tb: root::AVRational,
            in_ts: i64,
            fs_tb: root::AVRational,
            duration: ::std::os::raw::c_int,
            last: *mut i64,
            out_tb: root::AVRational,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Add a value to a timestamp."]
        #[doc = ""]
        #[doc = " This function guarantees that when the same value is repeatly added that"]
        #[doc = " no accumulation of rounding errors occurs."]
        #[doc = ""]
        #[doc = " @param[in] ts     Input timestamp"]
        #[doc = " @param[in] ts_tb  Input timestamp time base"]
        #[doc = " @param[in] inc    Value to be added"]
        #[doc = " @param[in] inc_tb Time base of `inc`"]
        pub fn av_add_stable(
            ts_tb: root::AVRational,
            ts: i64,
            inc_tb: root::AVRational,
            inc: i64,
        ) -> i64;
    }
    pub type __gnuc_va_list = root::__builtin_va_list;
    pub const AVClassCategory_AV_CLASS_CATEGORY_NA: root::AVClassCategory = 0;
    pub const AVClassCategory_AV_CLASS_CATEGORY_INPUT: root::AVClassCategory = 1;
    pub const AVClassCategory_AV_CLASS_CATEGORY_OUTPUT: root::AVClassCategory = 2;
    pub const AVClassCategory_AV_CLASS_CATEGORY_MUXER: root::AVClassCategory = 3;
    pub const AVClassCategory_AV_CLASS_CATEGORY_DEMUXER: root::AVClassCategory = 4;
    pub const AVClassCategory_AV_CLASS_CATEGORY_ENCODER: root::AVClassCategory = 5;
    pub const AVClassCategory_AV_CLASS_CATEGORY_DECODER: root::AVClassCategory = 6;
    pub const AVClassCategory_AV_CLASS_CATEGORY_FILTER: root::AVClassCategory = 7;
    pub const AVClassCategory_AV_CLASS_CATEGORY_BITSTREAM_FILTER: root::AVClassCategory = 8;
    pub const AVClassCategory_AV_CLASS_CATEGORY_SWSCALER: root::AVClassCategory = 9;
    pub const AVClassCategory_AV_CLASS_CATEGORY_SWRESAMPLER: root::AVClassCategory = 10;
    pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: root::AVClassCategory = 40;
    pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: root::AVClassCategory = 41;
    pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: root::AVClassCategory = 42;
    pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: root::AVClassCategory = 43;
    pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_OUTPUT: root::AVClassCategory = 44;
    pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_INPUT: root::AVClassCategory = 45;
    #[doc = "< not part of ABI/API"]
    pub const AVClassCategory_AV_CLASS_CATEGORY_NB: root::AVClassCategory = 46;
    pub type AVClassCategory = ::std::os::raw::c_uint;
    #[doc = " Describe the class of an AVClass context structure. That is an"]
    #[doc = " arbitrary struct of which the first field is a pointer to an"]
    #[doc = " AVClass struct (e.g. AVCodecContext, AVFormatContext etc.)."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVClass {
        #[doc = " The name of the class; usually it is the same name as the"]
        #[doc = " context structure type to which the AVClass is associated."]
        pub class_name: *const ::std::os::raw::c_char,
        #[doc = " A pointer to a function which returns the name of a context"]
        #[doc = " instance ctx associated with the class."]
        pub item_name: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
        >,
        #[doc = " a pointer to the first option specified in the class if any or NULL"]
        #[doc = ""]
        #[doc = " @see av_set_default_options()"]
        pub option: *const root::AVOption,
        #[doc = " LIBAVUTIL_VERSION with which this structure was created."]
        #[doc = " This is used to allow fields to be added without requiring major"]
        #[doc = " version bumps everywhere."]
        pub version: ::std::os::raw::c_int,
        #[doc = " Offset in the structure where log_level_offset is stored."]
        #[doc = " 0 means there is no such variable"]
        pub log_level_offset_offset: ::std::os::raw::c_int,
        #[doc = " Offset in the structure where a pointer to the parent context for"]
        #[doc = " logging is stored. For example a decoder could pass its AVCodecContext"]
        #[doc = " to eval as such a parent context, which an av_log() implementation"]
        #[doc = " could then leverage to display the parent context."]
        #[doc = " The offset can be NULL."]
        pub parent_log_context_offset: ::std::os::raw::c_int,
        #[doc = " Category used for visualization (like color)"]
        #[doc = " This is only set if the category is equal for all objects using this class."]
        #[doc = " available since version (51 << 16 | 56 << 8 | 100)"]
        pub category: root::AVClassCategory,
        #[doc = " Callback to return the category."]
        #[doc = " available since version (51 << 16 | 59 << 8 | 100)"]
        pub get_category: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> root::AVClassCategory,
        >,
        #[doc = " Callback to return the supported/allowed ranges."]
        #[doc = " available since version (52.12)"]
        pub query_ranges: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *mut root::AVOptionRanges,
                obj: *mut ::std::os::raw::c_void,
                key: *const ::std::os::raw::c_char,
                flags: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        #[doc = " Return next AVOptions-enabled child or NULL"]
        pub child_next: ::std::option::Option<
            unsafe extern "C" fn(
                obj: *mut ::std::os::raw::c_void,
                prev: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        #[doc = " Iterate over the AVClasses corresponding to potential AVOptions-enabled"]
        #[doc = " children."]
        #[doc = ""]
        #[doc = " @param iter pointer to opaque iteration state. The caller must initialize"]
        #[doc = "             *iter to NULL before the first call."]
        #[doc = " @return AVClass for the next AVOptions-enabled child or NULL if there are"]
        #[doc = "         no more such children."]
        #[doc = ""]
        #[doc = " @note The difference between child_next and this is that child_next"]
        #[doc = "       iterates over _already existing_ objects, while child_class_iterate"]
        #[doc = "       iterates over _all possible_ children."]
        pub child_class_iterate: ::std::option::Option<
            unsafe extern "C" fn(iter: *mut *mut ::std::os::raw::c_void) -> *const root::AVClass,
        >,
    }
    impl Default for AVClass {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Send the specified message to the log if the level is less than or equal"]
        #[doc = " to the current av_log_level. By default, all logging messages are sent to"]
        #[doc = " stderr. This behavior can be altered by setting a different logging callback"]
        #[doc = " function."]
        #[doc = " @see av_log_set_callback"]
        #[doc = ""]
        #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
        #[doc = "        pointer to an AVClass struct or NULL if general log."]
        #[doc = " @param level The importance level of the message expressed using a @ref"]
        #[doc = "        lavu_log_constants \"Logging Constant\"."]
        #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
        #[doc = "        subsequent arguments are converted to output."]
        pub fn av_log(
            avcl: *mut ::std::os::raw::c_void,
            level: ::std::os::raw::c_int,
            fmt: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[doc = " Send the specified message to the log once with the initial_level and then with"]
        #[doc = " the subsequent_level. By default, all logging messages are sent to"]
        #[doc = " stderr. This behavior can be altered by setting a different logging callback"]
        #[doc = " function."]
        #[doc = " @see av_log"]
        #[doc = ""]
        #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
        #[doc = "        pointer to an AVClass struct or NULL if general log."]
        #[doc = " @param initial_level importance level of the message expressed using a @ref"]
        #[doc = "        lavu_log_constants \"Logging Constant\" for the first occurance."]
        #[doc = " @param subsequent_level importance level of the message expressed using a @ref"]
        #[doc = "        lavu_log_constants \"Logging Constant\" after the first occurance."]
        #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
        #[doc = "        subsequent arguments are converted to output."]
        #[doc = " @param state a variable to keep trak of if a message has already been printed"]
        #[doc = "        this must be initialized to 0 before the first use. The same state"]
        #[doc = "        must not be accessed by 2 Threads simultaneously."]
        pub fn av_log_once(
            avcl: *mut ::std::os::raw::c_void,
            initial_level: ::std::os::raw::c_int,
            subsequent_level: ::std::os::raw::c_int,
            state: *mut ::std::os::raw::c_int,
            fmt: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[doc = " Send the specified message to the log if the level is less than or equal"]
        #[doc = " to the current av_log_level. By default, all logging messages are sent to"]
        #[doc = " stderr. This behavior can be altered by setting a different logging callback"]
        #[doc = " function."]
        #[doc = " @see av_log_set_callback"]
        #[doc = ""]
        #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
        #[doc = "        pointer to an AVClass struct."]
        #[doc = " @param level The importance level of the message expressed using a @ref"]
        #[doc = "        lavu_log_constants \"Logging Constant\"."]
        #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
        #[doc = "        subsequent arguments are converted to output."]
        #[doc = " @param vl The arguments referenced by the format string."]
        pub fn av_vlog(
            avcl: *mut ::std::os::raw::c_void,
            level: ::std::os::raw::c_int,
            fmt: *const ::std::os::raw::c_char,
            vl: root::va_list,
        );
    }
    extern "C" {
        #[doc = " Get the current log level"]
        #[doc = ""]
        #[doc = " @see lavu_log_constants"]
        #[doc = ""]
        #[doc = " @return Current log level"]
        pub fn av_log_get_level() -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Set the log level"]
        #[doc = ""]
        #[doc = " @see lavu_log_constants"]
        #[doc = ""]
        #[doc = " @param level Logging level"]
        pub fn av_log_set_level(level: ::std::os::raw::c_int);
    }
    extern "C" {
        #[doc = " Set the logging callback"]
        #[doc = ""]
        #[doc = " @note The callback must be thread safe, even if the application does not use"]
        #[doc = "       threads itself as some codecs are multithreaded."]
        #[doc = ""]
        #[doc = " @see av_log_default_callback"]
        #[doc = ""]
        #[doc = " @param callback A logging function with a compatible signature."]
        pub fn av_log_set_callback(
            callback: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_char,
                    arg4: root::va_list,
                ),
            >,
        );
    }
    extern "C" {
        #[doc = " Default logging callback"]
        #[doc = ""]
        #[doc = " It prints the message to stderr, optionally colorizing it."]
        #[doc = ""]
        #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
        #[doc = "        pointer to an AVClass struct."]
        #[doc = " @param level The importance level of the message expressed using a @ref"]
        #[doc = "        lavu_log_constants \"Logging Constant\"."]
        #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
        #[doc = "        subsequent arguments are converted to output."]
        #[doc = " @param vl The arguments referenced by the format string."]
        pub fn av_log_default_callback(
            avcl: *mut ::std::os::raw::c_void,
            level: ::std::os::raw::c_int,
            fmt: *const ::std::os::raw::c_char,
            vl: root::va_list,
        );
    }
    extern "C" {
        #[doc = " Return the context name"]
        #[doc = ""]
        #[doc = " @param  ctx The AVClass context"]
        #[doc = ""]
        #[doc = " @return The AVClass class_name"]
        pub fn av_default_item_name(
            ctx: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn av_default_get_category(ptr: *mut ::std::os::raw::c_void) -> root::AVClassCategory;
    }
    extern "C" {
        #[doc = " Format a line of log the same way as the default callback."]
        #[doc = " @param line          buffer to receive the formatted line"]
        #[doc = " @param line_size     size of the buffer"]
        #[doc = " @param print_prefix  used to store whether the prefix must be printed;"]
        #[doc = "                      must point to a persistent integer initially set to 1"]
        pub fn av_log_format_line(
            ptr: *mut ::std::os::raw::c_void,
            level: ::std::os::raw::c_int,
            fmt: *const ::std::os::raw::c_char,
            vl: root::va_list,
            line: *mut ::std::os::raw::c_char,
            line_size: ::std::os::raw::c_int,
            print_prefix: *mut ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Format a line of log the same way as the default callback."]
        #[doc = " @param line          buffer to receive the formatted line;"]
        #[doc = "                      may be NULL if line_size is 0"]
        #[doc = " @param line_size     size of the buffer; at most line_size-1 characters will"]
        #[doc = "                      be written to the buffer, plus one null terminator"]
        #[doc = " @param print_prefix  used to store whether the prefix must be printed;"]
        #[doc = "                      must point to a persistent integer initially set to 1"]
        #[doc = " @return Returns a negative value if an error occurred, otherwise returns"]
        #[doc = "         the number of characters that would have been written for a"]
        #[doc = "         sufficiently large buffer, not including the terminating null"]
        #[doc = "         character. If the return value is not less than line_size, it means"]
        #[doc = "         that the log message was truncated to fit the buffer."]
        pub fn av_log_format_line2(
            ptr: *mut ::std::os::raw::c_void,
            level: ::std::os::raw::c_int,
            fmt: *const ::std::os::raw::c_char,
            vl: root::va_list,
            line: *mut ::std::os::raw::c_char,
            line_size: ::std::os::raw::c_int,
            print_prefix: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_log_set_flags(arg: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn av_log_get_flags() -> ::std::os::raw::c_int;
    }
    pub const AVPixelFormat_AV_PIX_FMT_NONE: root::AVPixelFormat = -1;
    #[doc = "< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P: root::AVPixelFormat = 0;
    #[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"]
    pub const AVPixelFormat_AV_PIX_FMT_YUYV422: root::AVPixelFormat = 1;
    #[doc = "< packed RGB 8:8:8, 24bpp, RGBRGB..."]
    pub const AVPixelFormat_AV_PIX_FMT_RGB24: root::AVPixelFormat = 2;
    #[doc = "< packed RGB 8:8:8, 24bpp, BGRBGR..."]
    pub const AVPixelFormat_AV_PIX_FMT_BGR24: root::AVPixelFormat = 3;
    #[doc = "< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P: root::AVPixelFormat = 4;
    #[doc = "< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P: root::AVPixelFormat = 5;
    #[doc = "< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV410P: root::AVPixelFormat = 6;
    #[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV411P: root::AVPixelFormat = 7;
    #[doc = "<        Y        ,  8bpp"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY8: root::AVPixelFormat = 8;
    #[doc = "<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"]
    pub const AVPixelFormat_AV_PIX_FMT_MONOWHITE: root::AVPixelFormat = 9;
    #[doc = "<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"]
    pub const AVPixelFormat_AV_PIX_FMT_MONOBLACK: root::AVPixelFormat = 10;
    #[doc = "< 8 bits with AV_PIX_FMT_RGB32 palette"]
    pub const AVPixelFormat_AV_PIX_FMT_PAL8: root::AVPixelFormat = 11;
    #[doc = "< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVJ420P: root::AVPixelFormat = 12;
    #[doc = "< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVJ422P: root::AVPixelFormat = 13;
    #[doc = "< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVJ444P: root::AVPixelFormat = 14;
    #[doc = "< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"]
    pub const AVPixelFormat_AV_PIX_FMT_UYVY422: root::AVPixelFormat = 15;
    #[doc = "< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3"]
    pub const AVPixelFormat_AV_PIX_FMT_UYYVYY411: root::AVPixelFormat = 16;
    #[doc = "< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR8: root::AVPixelFormat = 17;
    #[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR4: root::AVPixelFormat = 18;
    #[doc = "< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR4_BYTE: root::AVPixelFormat = 19;
    #[doc = "< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB8: root::AVPixelFormat = 20;
    #[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB4: root::AVPixelFormat = 21;
    #[doc = "< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB4_BYTE: root::AVPixelFormat = 22;
    #[doc = "< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
    pub const AVPixelFormat_AV_PIX_FMT_NV12: root::AVPixelFormat = 23;
    #[doc = "< as above, but U and V bytes are swapped"]
    pub const AVPixelFormat_AV_PIX_FMT_NV21: root::AVPixelFormat = 24;
    #[doc = "< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."]
    pub const AVPixelFormat_AV_PIX_FMT_ARGB: root::AVPixelFormat = 25;
    #[doc = "< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."]
    pub const AVPixelFormat_AV_PIX_FMT_RGBA: root::AVPixelFormat = 26;
    #[doc = "< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."]
    pub const AVPixelFormat_AV_PIX_FMT_ABGR: root::AVPixelFormat = 27;
    #[doc = "< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."]
    pub const AVPixelFormat_AV_PIX_FMT_BGRA: root::AVPixelFormat = 28;
    #[doc = "<        Y        , 16bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY16BE: root::AVPixelFormat = 29;
    #[doc = "<        Y        , 16bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY16LE: root::AVPixelFormat = 30;
    #[doc = "< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV440P: root::AVPixelFormat = 31;
    #[doc = "< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVJ440P: root::AVPixelFormat = 32;
    #[doc = "< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA420P: root::AVPixelFormat = 33;
    #[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB48BE: root::AVPixelFormat = 34;
    #[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB48LE: root::AVPixelFormat = 35;
    #[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB565BE: root::AVPixelFormat = 36;
    #[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB565LE: root::AVPixelFormat = 37;
    #[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB555BE: root::AVPixelFormat = 38;
    #[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB555LE: root::AVPixelFormat = 39;
    #[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR565BE: root::AVPixelFormat = 40;
    #[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR565LE: root::AVPixelFormat = 41;
    #[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR555BE: root::AVPixelFormat = 42;
    #[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR555LE: root::AVPixelFormat = 43;
    #[doc = "  Hardware acceleration through VA-API, data[3] contains a"]
    #[doc = "  VASurfaceID."]
    pub const AVPixelFormat_AV_PIX_FMT_VAAPI: root::AVPixelFormat = 44;
    #[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P16LE: root::AVPixelFormat = 45;
    #[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P16BE: root::AVPixelFormat = 46;
    #[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P16LE: root::AVPixelFormat = 47;
    #[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P16BE: root::AVPixelFormat = 48;
    #[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P16LE: root::AVPixelFormat = 49;
    #[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P16BE: root::AVPixelFormat = 50;
    #[doc = "< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer"]
    pub const AVPixelFormat_AV_PIX_FMT_DXVA2_VLD: root::AVPixelFormat = 51;
    #[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB444LE: root::AVPixelFormat = 52;
    #[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB444BE: root::AVPixelFormat = 53;
    #[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR444LE: root::AVPixelFormat = 54;
    #[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR444BE: root::AVPixelFormat = 55;
    #[doc = "< 8 bits gray, 8 bits alpha"]
    pub const AVPixelFormat_AV_PIX_FMT_YA8: root::AVPixelFormat = 56;
    #[doc = "< alias for AV_PIX_FMT_YA8"]
    pub const AVPixelFormat_AV_PIX_FMT_Y400A: root::AVPixelFormat = 56;
    #[doc = "< alias for AV_PIX_FMT_YA8"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY8A: root::AVPixelFormat = 56;
    #[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR48BE: root::AVPixelFormat = 57;
    #[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR48LE: root::AVPixelFormat = 58;
    #[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P9BE: root::AVPixelFormat = 59;
    #[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P9LE: root::AVPixelFormat = 60;
    #[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P10BE: root::AVPixelFormat = 61;
    #[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P10LE: root::AVPixelFormat = 62;
    #[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P10BE: root::AVPixelFormat = 63;
    #[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P10LE: root::AVPixelFormat = 64;
    #[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P9BE: root::AVPixelFormat = 65;
    #[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P9LE: root::AVPixelFormat = 66;
    #[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P10BE: root::AVPixelFormat = 67;
    #[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P10LE: root::AVPixelFormat = 68;
    #[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P9BE: root::AVPixelFormat = 69;
    #[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P9LE: root::AVPixelFormat = 70;
    #[doc = "< planar GBR 4:4:4 24bpp"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP: root::AVPixelFormat = 71;
    pub const AVPixelFormat_AV_PIX_FMT_GBR24P: root::AVPixelFormat = 71;
    #[doc = "< planar GBR 4:4:4 27bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP9BE: root::AVPixelFormat = 72;
    #[doc = "< planar GBR 4:4:4 27bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP9LE: root::AVPixelFormat = 73;
    #[doc = "< planar GBR 4:4:4 30bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP10BE: root::AVPixelFormat = 74;
    #[doc = "< planar GBR 4:4:4 30bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP10LE: root::AVPixelFormat = 75;
    #[doc = "< planar GBR 4:4:4 48bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP16BE: root::AVPixelFormat = 76;
    #[doc = "< planar GBR 4:4:4 48bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP16LE: root::AVPixelFormat = 77;
    #[doc = "< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA422P: root::AVPixelFormat = 78;
    #[doc = "< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA444P: root::AVPixelFormat = 79;
    #[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9BE: root::AVPixelFormat = 80;
    #[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9LE: root::AVPixelFormat = 81;
    #[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9BE: root::AVPixelFormat = 82;
    #[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9LE: root::AVPixelFormat = 83;
    #[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9BE: root::AVPixelFormat = 84;
    #[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9LE: root::AVPixelFormat = 85;
    #[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10BE: root::AVPixelFormat = 86;
    #[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10LE: root::AVPixelFormat = 87;
    #[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10BE: root::AVPixelFormat = 88;
    #[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10LE: root::AVPixelFormat = 89;
    #[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10BE: root::AVPixelFormat = 90;
    #[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10LE: root::AVPixelFormat = 91;
    #[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16BE: root::AVPixelFormat = 92;
    #[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16LE: root::AVPixelFormat = 93;
    #[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16BE: root::AVPixelFormat = 94;
    #[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16LE: root::AVPixelFormat = 95;
    #[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16BE: root::AVPixelFormat = 96;
    #[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16LE: root::AVPixelFormat = 97;
    #[doc = "< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface"]
    pub const AVPixelFormat_AV_PIX_FMT_VDPAU: root::AVPixelFormat = 98;
    #[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0"]
    pub const AVPixelFormat_AV_PIX_FMT_XYZ12LE: root::AVPixelFormat = 99;
    #[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0"]
    pub const AVPixelFormat_AV_PIX_FMT_XYZ12BE: root::AVPixelFormat = 100;
    #[doc = "< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
    pub const AVPixelFormat_AV_PIX_FMT_NV16: root::AVPixelFormat = 101;
    #[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_NV20LE: root::AVPixelFormat = 102;
    #[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_NV20BE: root::AVPixelFormat = 103;
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_RGBA64BE: root::AVPixelFormat = 104;
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_RGBA64LE: root::AVPixelFormat = 105;
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BGRA64BE: root::AVPixelFormat = 106;
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BGRA64LE: root::AVPixelFormat = 107;
    #[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb"]
    pub const AVPixelFormat_AV_PIX_FMT_YVYU422: root::AVPixelFormat = 108;
    #[doc = "< 16 bits gray, 16 bits alpha (big-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YA16BE: root::AVPixelFormat = 109;
    #[doc = "< 16 bits gray, 16 bits alpha (little-endian)"]
    pub const AVPixelFormat_AV_PIX_FMT_YA16LE: root::AVPixelFormat = 110;
    #[doc = "< planar GBRA 4:4:4:4 32bpp"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRAP: root::AVPixelFormat = 111;
    #[doc = "< planar GBRA 4:4:4:4 64bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRAP16BE: root::AVPixelFormat = 112;
    #[doc = "< planar GBRA 4:4:4:4 64bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRAP16LE: root::AVPixelFormat = 113;
    #[doc = "  HW acceleration through QSV, data[3] contains a pointer to the"]
    #[doc = "  mfxFrameSurface1 structure."]
    pub const AVPixelFormat_AV_PIX_FMT_QSV: root::AVPixelFormat = 114;
    #[doc = " HW acceleration though MMAL, data[3] contains a pointer to the"]
    #[doc = " MMAL_BUFFER_HEADER_T structure."]
    pub const AVPixelFormat_AV_PIX_FMT_MMAL: root::AVPixelFormat = 115;
    #[doc = "< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer"]
    pub const AVPixelFormat_AV_PIX_FMT_D3D11VA_VLD: root::AVPixelFormat = 116;
    #[doc = " HW acceleration through CUDA. data[i] contain CUdeviceptr pointers"]
    #[doc = " exactly as for system memory frames."]
    pub const AVPixelFormat_AV_PIX_FMT_CUDA: root::AVPixelFormat = 117;
    #[doc = "< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_0RGB: root::AVPixelFormat = 118;
    #[doc = "< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_RGB0: root::AVPixelFormat = 119;
    #[doc = "< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_0BGR: root::AVPixelFormat = 120;
    #[doc = "< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_BGR0: root::AVPixelFormat = 121;
    #[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P12BE: root::AVPixelFormat = 122;
    #[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P12LE: root::AVPixelFormat = 123;
    #[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P14BE: root::AVPixelFormat = 124;
    #[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV420P14LE: root::AVPixelFormat = 125;
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P12BE: root::AVPixelFormat = 126;
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P12LE: root::AVPixelFormat = 127;
    #[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P14BE: root::AVPixelFormat = 128;
    #[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV422P14LE: root::AVPixelFormat = 129;
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P12BE: root::AVPixelFormat = 130;
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P12LE: root::AVPixelFormat = 131;
    #[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P14BE: root::AVPixelFormat = 132;
    #[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV444P14LE: root::AVPixelFormat = 133;
    #[doc = "< planar GBR 4:4:4 36bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP12BE: root::AVPixelFormat = 134;
    #[doc = "< planar GBR 4:4:4 36bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP12LE: root::AVPixelFormat = 135;
    #[doc = "< planar GBR 4:4:4 42bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP14BE: root::AVPixelFormat = 136;
    #[doc = "< planar GBR 4:4:4 42bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRP14LE: root::AVPixelFormat = 137;
    #[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVJ411P: root::AVPixelFormat = 138;
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR8: root::AVPixelFormat = 139;
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB8: root::AVPixelFormat = 140;
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG8: root::AVPixelFormat = 141;
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG8: root::AVPixelFormat = 142;
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16LE: root::AVPixelFormat = 143;
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16BE: root::AVPixelFormat = 144;
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16LE: root::AVPixelFormat = 145;
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16BE: root::AVPixelFormat = 146;
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16LE: root::AVPixelFormat = 147;
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16BE: root::AVPixelFormat = 148;
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16LE: root::AVPixelFormat = 149;
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16BE: root::AVPixelFormat = 150;
    #[doc = "< XVideo Motion Acceleration via common packet passing"]
    pub const AVPixelFormat_AV_PIX_FMT_XVMC: root::AVPixelFormat = 151;
    #[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV440P10LE: root::AVPixelFormat = 152;
    #[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV440P10BE: root::AVPixelFormat = 153;
    #[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV440P12LE: root::AVPixelFormat = 154;
    #[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUV440P12BE: root::AVPixelFormat = 155;
    #[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_AYUV64LE: root::AVPixelFormat = 156;
    #[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_AYUV64BE: root::AVPixelFormat = 157;
    #[doc = "< hardware decoding through Videotoolbox"]
    pub const AVPixelFormat_AV_PIX_FMT_VIDEOTOOLBOX: root::AVPixelFormat = 158;
    #[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_P010LE: root::AVPixelFormat = 159;
    #[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_P010BE: root::AVPixelFormat = 160;
    #[doc = "< planar GBR 4:4:4:4 48bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRAP12BE: root::AVPixelFormat = 161;
    #[doc = "< planar GBR 4:4:4:4 48bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRAP12LE: root::AVPixelFormat = 162;
    #[doc = "< planar GBR 4:4:4:4 40bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRAP10BE: root::AVPixelFormat = 163;
    #[doc = "< planar GBR 4:4:4:4 40bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRAP10LE: root::AVPixelFormat = 164;
    #[doc = "< hardware decoding through MediaCodec"]
    pub const AVPixelFormat_AV_PIX_FMT_MEDIACODEC: root::AVPixelFormat = 165;
    #[doc = "<        Y        , 12bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY12BE: root::AVPixelFormat = 166;
    #[doc = "<        Y        , 12bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY12LE: root::AVPixelFormat = 167;
    #[doc = "<        Y        , 10bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY10BE: root::AVPixelFormat = 168;
    #[doc = "<        Y        , 10bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY10LE: root::AVPixelFormat = 169;
    #[doc = "< like NV12, with 16bpp per component, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_P016LE: root::AVPixelFormat = 170;
    #[doc = "< like NV12, with 16bpp per component, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_P016BE: root::AVPixelFormat = 171;
    #[doc = " Hardware surfaces for Direct3D11."]
    #[doc = ""]
    #[doc = " This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11"]
    #[doc = " hwaccel API and filtering support AV_PIX_FMT_D3D11 only."]
    #[doc = ""]
    #[doc = " data[0] contains a ID3D11Texture2D pointer, and data[1] contains the"]
    #[doc = " texture array index of the frame as intptr_t if the ID3D11Texture2D is"]
    #[doc = " an array texture (or always 0 if it's a normal texture)."]
    pub const AVPixelFormat_AV_PIX_FMT_D3D11: root::AVPixelFormat = 172;
    #[doc = "<        Y        , 9bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY9BE: root::AVPixelFormat = 173;
    #[doc = "<        Y        , 9bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY9LE: root::AVPixelFormat = 174;
    #[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRPF32BE: root::AVPixelFormat = 175;
    #[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRPF32LE: root::AVPixelFormat = 176;
    #[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32BE: root::AVPixelFormat = 177;
    #[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32LE: root::AVPixelFormat = 178;
    #[doc = " DRM-managed buffers exposed through PRIME buffer sharing."]
    #[doc = ""]
    #[doc = " data[0] points to an AVDRMFrameDescriptor."]
    pub const AVPixelFormat_AV_PIX_FMT_DRM_PRIME: root::AVPixelFormat = 179;
    #[doc = " Hardware surfaces for OpenCL."]
    #[doc = ""]
    #[doc = " data[i] contain 2D image objects (typed in C as cl_mem, used"]
    #[doc = " in OpenCL as image2d_t) for each plane of the surface."]
    pub const AVPixelFormat_AV_PIX_FMT_OPENCL: root::AVPixelFormat = 180;
    #[doc = "<        Y        , 14bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY14BE: root::AVPixelFormat = 181;
    #[doc = "<        Y        , 14bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAY14LE: root::AVPixelFormat = 182;
    #[doc = "< IEEE-754 single precision Y, 32bpp, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAYF32BE: root::AVPixelFormat = 183;
    #[doc = "< IEEE-754 single precision Y, 32bpp, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_GRAYF32LE: root::AVPixelFormat = 184;
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA422P12BE: root::AVPixelFormat = 185;
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA422P12LE: root::AVPixelFormat = 186;
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA444P12BE: root::AVPixelFormat = 187;
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_YUVA444P12LE: root::AVPixelFormat = 188;
    #[doc = "< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
    pub const AVPixelFormat_AV_PIX_FMT_NV24: root::AVPixelFormat = 189;
    #[doc = "< as above, but U and V bytes are swapped"]
    pub const AVPixelFormat_AV_PIX_FMT_NV42: root::AVPixelFormat = 190;
    #[doc = " Vulkan hardware images."]
    #[doc = ""]
    #[doc = " data[0] points to an AVVkFrame"]
    pub const AVPixelFormat_AV_PIX_FMT_VULKAN: root::AVPixelFormat = 191;
    #[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_Y210BE: root::AVPixelFormat = 192;
    #[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian"]
    pub const AVPixelFormat_AV_PIX_FMT_Y210LE: root::AVPixelFormat = 193;
    #[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_X2RGB10LE: root::AVPixelFormat = 194;
    #[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_X2RGB10BE: root::AVPixelFormat = 195;
    #[doc = "< packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G 10R(lsb), little-endian, X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_X2BGR10LE: root::AVPixelFormat = 196;
    #[doc = "< packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G 10R(lsb), big-endian, X=unused/undefined"]
    pub const AVPixelFormat_AV_PIX_FMT_X2BGR10BE: root::AVPixelFormat = 197;
    #[doc = "< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions"]
    pub const AVPixelFormat_AV_PIX_FMT_NB: root::AVPixelFormat = 198;
    #[doc = " Pixel format."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA"]
    #[doc = " color is put together as:"]
    #[doc = "  (A << 24) | (R << 16) | (G << 8) | B"]
    #[doc = " This is stored as BGRA on little-endian CPU architectures and ARGB on"]
    #[doc = " big-endian CPUs."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " If the resolution is not a multiple of the chroma subsampling factor"]
    #[doc = " then the chroma plane resolution must be rounded up."]
    #[doc = ""]
    #[doc = " @par"]
    #[doc = " When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized"]
    #[doc = " image data is stored in AVFrame.data[0]. The palette is transported in"]
    #[doc = " AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is"]
    #[doc = " formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is"]
    #[doc = " also endian-specific). Note also that the individual RGB32 palette"]
    #[doc = " components stored in AVFrame.data[1] should be in the range 0..255."]
    #[doc = " This is important as many custom PAL8 video codecs that were designed"]
    #[doc = " to run on the IBM VGA graphics adapter use 6-bit palette components."]
    #[doc = ""]
    #[doc = " @par"]
    #[doc = " For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like"]
    #[doc = " for pal8. This palette is filled in automatically by the function"]
    #[doc = " allocating the picture."]
    pub type AVPixelFormat = ::std::os::raw::c_int;
    pub const AVColorPrimaries_AVCOL_PRI_RESERVED0: root::AVColorPrimaries = 0;
    #[doc = "< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP 177 Annex B"]
    pub const AVColorPrimaries_AVCOL_PRI_BT709: root::AVColorPrimaries = 1;
    pub const AVColorPrimaries_AVCOL_PRI_UNSPECIFIED: root::AVColorPrimaries = 2;
    pub const AVColorPrimaries_AVCOL_PRI_RESERVED: root::AVColorPrimaries = 3;
    #[doc = "< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
    pub const AVColorPrimaries_AVCOL_PRI_BT470M: root::AVColorPrimaries = 4;
    #[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM"]
    pub const AVColorPrimaries_AVCOL_PRI_BT470BG: root::AVColorPrimaries = 5;
    #[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"]
    pub const AVColorPrimaries_AVCOL_PRI_SMPTE170M: root::AVColorPrimaries = 6;
    #[doc = "< identical to above, also called \"SMPTE C\" even though it uses D65"]
    pub const AVColorPrimaries_AVCOL_PRI_SMPTE240M: root::AVColorPrimaries = 7;
    #[doc = "< colour filters using Illuminant C"]
    pub const AVColorPrimaries_AVCOL_PRI_FILM: root::AVColorPrimaries = 8;
    #[doc = "< ITU-R BT2020"]
    pub const AVColorPrimaries_AVCOL_PRI_BT2020: root::AVColorPrimaries = 9;
    #[doc = "< SMPTE ST 428-1 (CIE 1931 XYZ)"]
    pub const AVColorPrimaries_AVCOL_PRI_SMPTE428: root::AVColorPrimaries = 10;
    pub const AVColorPrimaries_AVCOL_PRI_SMPTEST428_1: root::AVColorPrimaries = 10;
    #[doc = "< SMPTE ST 431-2 (2011) / DCI P3"]
    pub const AVColorPrimaries_AVCOL_PRI_SMPTE431: root::AVColorPrimaries = 11;
    #[doc = "< SMPTE ST 432-1 (2010) / P3 D65 / Display P3"]
    pub const AVColorPrimaries_AVCOL_PRI_SMPTE432: root::AVColorPrimaries = 12;
    #[doc = "< EBU Tech. 3213-E (nothing there) / one of JEDEC P22 group phosphors"]
    pub const AVColorPrimaries_AVCOL_PRI_EBU3213: root::AVColorPrimaries = 22;
    pub const AVColorPrimaries_AVCOL_PRI_JEDEC_P22: root::AVColorPrimaries = 22;
    #[doc = "< Not part of ABI"]
    pub const AVColorPrimaries_AVCOL_PRI_NB: root::AVColorPrimaries = 23;
    #[doc = " Chromaticity coordinates of the source primaries."]
    #[doc = " These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.1 and ITU-T H.273."]
    pub type AVColorPrimaries = ::std::os::raw::c_uint;
    pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED0:
        root::AVColorTransferCharacteristic = 0;
    #[doc = "< also ITU-R BT1361"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_BT709: root::AVColorTransferCharacteristic =
        1;
    pub const AVColorTransferCharacteristic_AVCOL_TRC_UNSPECIFIED:
        root::AVColorTransferCharacteristic = 2;
    pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED:
        root::AVColorTransferCharacteristic = 3;
    #[doc = "< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA22: root::AVColorTransferCharacteristic =
        4;
    #[doc = "< also ITU-R BT470BG"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA28: root::AVColorTransferCharacteristic =
        5;
    #[doc = "< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE170M:
        root::AVColorTransferCharacteristic = 6;
    pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE240M:
        root::AVColorTransferCharacteristic = 7;
    #[doc = "< \"Linear transfer characteristics\""]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_LINEAR: root::AVColorTransferCharacteristic =
        8;
    #[doc = "< \"Logarithmic transfer characteristic (100:1 range)\""]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG: root::AVColorTransferCharacteristic = 9;
    #[doc = "< \"Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)\""]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG_SQRT:
        root::AVColorTransferCharacteristic = 10;
    #[doc = "< IEC 61966-2-4"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_4:
        root::AVColorTransferCharacteristic = 11;
    #[doc = "< ITU-R BT1361 Extended Colour Gamut"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_BT1361_ECG:
        root::AVColorTransferCharacteristic = 12;
    #[doc = "< IEC 61966-2-1 (sRGB or sYCC)"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_1:
        root::AVColorTransferCharacteristic = 13;
    #[doc = "< ITU-R BT2020 for 10-bit system"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_10:
        root::AVColorTransferCharacteristic = 14;
    #[doc = "< ITU-R BT2020 for 12-bit system"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_12:
        root::AVColorTransferCharacteristic = 15;
    #[doc = "< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE2084:
        root::AVColorTransferCharacteristic = 16;
    pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST2084:
        root::AVColorTransferCharacteristic = 16;
    #[doc = "< SMPTE ST 428-1"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE428:
        root::AVColorTransferCharacteristic = 17;
    pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST428_1:
        root::AVColorTransferCharacteristic = 17;
    #[doc = "< ARIB STD-B67, known as \"Hybrid log-gamma\""]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_ARIB_STD_B67:
        root::AVColorTransferCharacteristic = 18;
    #[doc = "< Not part of ABI"]
    pub const AVColorTransferCharacteristic_AVCOL_TRC_NB: root::AVColorTransferCharacteristic = 19;
    #[doc = " Color Transfer Characteristic."]
    #[doc = " These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.2."]
    pub type AVColorTransferCharacteristic = ::std::os::raw::c_uint;
    #[doc = "< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB), YZX and ST 428-1"]
    pub const AVColorSpace_AVCOL_SPC_RGB: root::AVColorSpace = 0;
    #[doc = "< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / derived in SMPTE RP 177 Annex B"]
    pub const AVColorSpace_AVCOL_SPC_BT709: root::AVColorSpace = 1;
    pub const AVColorSpace_AVCOL_SPC_UNSPECIFIED: root::AVColorSpace = 2;
    #[doc = "< reserved for future use by ITU-T and ISO/IEC just like 15-255 are"]
    pub const AVColorSpace_AVCOL_SPC_RESERVED: root::AVColorSpace = 3;
    #[doc = "< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
    pub const AVColorSpace_AVCOL_SPC_FCC: root::AVColorSpace = 4;
    #[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601"]
    pub const AVColorSpace_AVCOL_SPC_BT470BG: root::AVColorSpace = 5;
    #[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above"]
    pub const AVColorSpace_AVCOL_SPC_SMPTE170M: root::AVColorSpace = 6;
    #[doc = "< derived from 170M primaries and D65 white point, 170M is derived from BT470 System M's primaries"]
    pub const AVColorSpace_AVCOL_SPC_SMPTE240M: root::AVColorSpace = 7;
    #[doc = "< used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16"]
    pub const AVColorSpace_AVCOL_SPC_YCGCO: root::AVColorSpace = 8;
    pub const AVColorSpace_AVCOL_SPC_YCOCG: root::AVColorSpace = 8;
    #[doc = "< ITU-R BT2020 non-constant luminance system"]
    pub const AVColorSpace_AVCOL_SPC_BT2020_NCL: root::AVColorSpace = 9;
    #[doc = "< ITU-R BT2020 constant luminance system"]
    pub const AVColorSpace_AVCOL_SPC_BT2020_CL: root::AVColorSpace = 10;
    #[doc = "< SMPTE 2085, Y'D'zD'x"]
    pub const AVColorSpace_AVCOL_SPC_SMPTE2085: root::AVColorSpace = 11;
    #[doc = "< Chromaticity-derived non-constant luminance system"]
    pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_NCL: root::AVColorSpace = 12;
    #[doc = "< Chromaticity-derived constant luminance system"]
    pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_CL: root::AVColorSpace = 13;
    #[doc = "< ITU-R BT.2100-0, ICtCp"]
    pub const AVColorSpace_AVCOL_SPC_ICTCP: root::AVColorSpace = 14;
    #[doc = "< Not part of ABI"]
    pub const AVColorSpace_AVCOL_SPC_NB: root::AVColorSpace = 15;
    #[doc = " YUV colorspace type."]
    #[doc = " These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.3."]
    pub type AVColorSpace = ::std::os::raw::c_uint;
    pub const AVColorRange_AVCOL_RANGE_UNSPECIFIED: root::AVColorRange = 0;
    #[doc = " Narrow or limited range content."]
    #[doc = ""]
    #[doc = " - For luma planes:"]
    #[doc = ""]
    #[doc = "       (219 * E + 16) * 2^(n-8)"]
    #[doc = ""]
    #[doc = "   F.ex. the range of 16-235 for 8 bits"]
    #[doc = ""]
    #[doc = " - For chroma planes:"]
    #[doc = ""]
    #[doc = "       (224 * E + 128) * 2^(n-8)"]
    #[doc = ""]
    #[doc = "   F.ex. the range of 16-240 for 8 bits"]
    pub const AVColorRange_AVCOL_RANGE_MPEG: root::AVColorRange = 1;
    #[doc = " Full range content."]
    #[doc = ""]
    #[doc = " - For RGB and luma planes:"]
    #[doc = ""]
    #[doc = "       (2^n - 1) * E"]
    #[doc = ""]
    #[doc = "   F.ex. the range of 0-255 for 8 bits"]
    #[doc = ""]
    #[doc = " - For chroma planes:"]
    #[doc = ""]
    #[doc = "       (2^n - 1) * E + 2^(n - 1)"]
    #[doc = ""]
    #[doc = "   F.ex. the range of 1-255 for 8 bits"]
    pub const AVColorRange_AVCOL_RANGE_JPEG: root::AVColorRange = 2;
    #[doc = "< Not part of ABI"]
    pub const AVColorRange_AVCOL_RANGE_NB: root::AVColorRange = 3;
    #[doc = " Visual content value range."]
    #[doc = ""]
    #[doc = " These values are based on definitions that can be found in multiple"]
    #[doc = " specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance"]
    #[doc = " and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital"]
    #[doc = " Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit"]
    #[doc = " integer representation). At the time of writing, the BT.2100 one is"]
    #[doc = " recommended, as it also defines the full range representation."]
    #[doc = ""]
    #[doc = " Common definitions:"]
    #[doc = "   - For RGB and luma planes such as Y in YCbCr and I in ICtCp,"]
    #[doc = "     'E' is the original value in range of 0.0 to 1.0."]
    #[doc = "   - For chroma planes such as Cb,Cr and Ct,Cp, 'E' is the original"]
    #[doc = "     value in range of -0.5 to 0.5."]
    #[doc = "   - 'n' is the output bit depth."]
    #[doc = "   - For additional definitions such as rounding and clipping to valid n"]
    #[doc = "     bit unsigned integer range, please refer to BT.2100 (Table 9)."]
    pub type AVColorRange = ::std::os::raw::c_uint;
    pub const AVChromaLocation_AVCHROMA_LOC_UNSPECIFIED: root::AVChromaLocation = 0;
    #[doc = "< MPEG-2/4 4:2:0, H.264 default for 4:2:0"]
    pub const AVChromaLocation_AVCHROMA_LOC_LEFT: root::AVChromaLocation = 1;
    #[doc = "< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0"]
    pub const AVChromaLocation_AVCHROMA_LOC_CENTER: root::AVChromaLocation = 2;
    #[doc = "< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2"]
    pub const AVChromaLocation_AVCHROMA_LOC_TOPLEFT: root::AVChromaLocation = 3;
    pub const AVChromaLocation_AVCHROMA_LOC_TOP: root::AVChromaLocation = 4;
    pub const AVChromaLocation_AVCHROMA_LOC_BOTTOMLEFT: root::AVChromaLocation = 5;
    pub const AVChromaLocation_AVCHROMA_LOC_BOTTOM: root::AVChromaLocation = 6;
    #[doc = "< Not part of ABI"]
    pub const AVChromaLocation_AVCHROMA_LOC_NB: root::AVChromaLocation = 7;
    #[doc = " Location of chroma samples."]
    #[doc = ""]
    #[doc = " Illustration showing the location of the first (top left) chroma sample of the"]
    #[doc = " image, the left shows only luma, the right"]
    #[doc = " shows the location of the chroma sample, the 2 could be imagined to overlay"]
    #[doc = " each other but are drawn separately due to limitations of ASCII"]
    #[doc = ""]
    #[doc = "                1st 2nd       1st 2nd horizontal luma sample positions"]
    #[doc = "                 v   v         v   v"]
    #[doc = "                 ______        ______"]
    #[doc = "1st luma line > |X   X ...    |3 4 X ...     X are luma samples,"]
    #[doc = "                |             |1 2           1-6 are possible chroma positions"]
    #[doc = "2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position"]
    pub type AVChromaLocation = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Compute the length of an integer list."]
        #[doc = ""]
        #[doc = " @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)"]
        #[doc = " @param term    list terminator (usually 0 or -1)"]
        #[doc = " @param list    pointer to the list"]
        #[doc = " @return  length of the list, in elements, not counting the terminator"]
        pub fn av_int_list_length_for_size(
            elsize: ::std::os::raw::c_uint,
            list: *const ::std::os::raw::c_void,
            term: u64,
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[doc = " Open a file using a UTF-8 filename."]
        #[doc = " The API of this function matches POSIX fopen(), errors are returned through"]
        #[doc = " errno."]
        pub fn av_fopen_utf8(
            path: *const ::std::os::raw::c_char,
            mode: *const ::std::os::raw::c_char,
        ) -> *mut root::FILE;
    }
    extern "C" {
        #[doc = " Return the fractional representation of the internal time base."]
        pub fn av_get_time_base_q() -> root::AVRational;
    }
    extern "C" {
        #[doc = " Fill the provided buffer with a string containing a FourCC (four-character"]
        #[doc = " code) representation."]
        #[doc = ""]
        #[doc = " @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE"]
        #[doc = " @param fourcc the fourcc to represent"]
        #[doc = " @return the buffer in input"]
        pub fn av_fourcc_make_string(
            buf: *mut ::std::os::raw::c_char,
            fourcc: u32,
        ) -> *mut ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVDictionaryEntry {
        pub key: *mut ::std::os::raw::c_char,
        pub value: *mut ::std::os::raw::c_char,
    }
    impl Default for AVDictionaryEntry {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVDictionary {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Get a dictionary entry with matching key."]
        #[doc = ""]
        #[doc = " The returned entry key or value must not be changed, or it will"]
        #[doc = " cause undefined behavior."]
        #[doc = ""]
        #[doc = " To iterate through all the dictionary entries, you can set the matching key"]
        #[doc = " to the null string \"\" and set the AV_DICT_IGNORE_SUFFIX flag."]
        #[doc = ""]
        #[doc = " @param prev Set to the previous matching element to find the next."]
        #[doc = "             If set to NULL the first matching element is returned."]
        #[doc = " @param key matching key"]
        #[doc = " @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved"]
        #[doc = " @return found entry or NULL in case no matching entry was found in the dictionary"]
        pub fn av_dict_get(
            m: *const root::AVDictionary,
            key: *const ::std::os::raw::c_char,
            prev: *const root::AVDictionaryEntry,
            flags: ::std::os::raw::c_int,
        ) -> *mut root::AVDictionaryEntry;
    }
    extern "C" {
        #[doc = " Get number of entries in dictionary."]
        #[doc = ""]
        #[doc = " @param m dictionary"]
        #[doc = " @return  number of entries in dictionary"]
        pub fn av_dict_count(m: *const root::AVDictionary) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Set the given entry in *pm, overwriting an existing entry."]
        #[doc = ""]
        #[doc = " Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,"]
        #[doc = " these arguments will be freed on error."]
        #[doc = ""]
        #[doc = " Warning: Adding a new entry to a dictionary invalidates all existing entries"]
        #[doc = " previously returned with av_dict_get."]
        #[doc = ""]
        #[doc = " @param pm pointer to a pointer to a dictionary struct. If *pm is NULL"]
        #[doc = " a dictionary struct is allocated and put in *pm."]
        #[doc = " @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)"]
        #[doc = " @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags)."]
        #[doc = "        Passing a NULL value will cause an existing entry to be deleted."]
        #[doc = " @return >= 0 on success otherwise an error code <0"]
        pub fn av_dict_set(
            pm: *mut *mut root::AVDictionary,
            key: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Convenience wrapper for av_dict_set that converts the value to a string"]
        #[doc = " and stores it."]
        #[doc = ""]
        #[doc = " Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error."]
        pub fn av_dict_set_int(
            pm: *mut *mut root::AVDictionary,
            key: *const ::std::os::raw::c_char,
            value: i64,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Parse the key/value pairs list and add the parsed entries to a dictionary."]
        #[doc = ""]
        #[doc = " In case of failure, all the successfully set entries are stored in"]
        #[doc = " *pm. You may need to manually free the created dictionary."]
        #[doc = ""]
        #[doc = " @param key_val_sep  a 0-terminated list of characters used to separate"]
        #[doc = "                     key from value"]
        #[doc = " @param pairs_sep    a 0-terminated list of characters used to separate"]
        #[doc = "                     two pairs from each other"]
        #[doc = " @param flags        flags to use when adding to dictionary."]
        #[doc = "                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL"]
        #[doc = "                     are ignored since the key/value tokens will always"]
        #[doc = "                     be duplicated."]
        #[doc = " @return             0 on success, negative AVERROR code on failure"]
        pub fn av_dict_parse_string(
            pm: *mut *mut root::AVDictionary,
            str_: *const ::std::os::raw::c_char,
            key_val_sep: *const ::std::os::raw::c_char,
            pairs_sep: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Copy entries from one AVDictionary struct into another."]
        #[doc = " @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,"]
        #[doc = "            this function will allocate a struct for you and put it in *dst"]
        #[doc = " @param src pointer to source AVDictionary struct"]
        #[doc = " @param flags flags to use when setting entries in *dst"]
        #[doc = " @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag"]
        #[doc = " @return 0 on success, negative AVERROR code on failure. If dst was allocated"]
        #[doc = "           by this function, callers should free the associated memory."]
        pub fn av_dict_copy(
            dst: *mut *mut root::AVDictionary,
            src: *const root::AVDictionary,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Free all the memory allocated for an AVDictionary struct"]
        #[doc = " and all keys and values."]
        pub fn av_dict_free(m: *mut *mut root::AVDictionary);
    }
    extern "C" {
        #[doc = " Get dictionary entries as a string."]
        #[doc = ""]
        #[doc = " Create a string containing dictionary's entries."]
        #[doc = " Such string may be passed back to av_dict_parse_string()."]
        #[doc = " @note String is escaped with backslashes ('\\')."]
        #[doc = ""]
        #[doc = " @param[in]  m             dictionary"]
        #[doc = " @param[out] buffer        Pointer to buffer that will be allocated with string containg entries."]
        #[doc = "                           Buffer must be freed by the caller when is no longer needed."]
        #[doc = " @param[in]  key_val_sep   character used to separate key from value"]
        #[doc = " @param[in]  pairs_sep     character used to separate two pairs from each other"]
        #[doc = " @return                   >= 0 on success, negative on error"]
        #[doc = " @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same."]
        pub fn av_dict_get_string(
            m: *const root::AVDictionary,
            buffer: *mut *mut ::std::os::raw::c_char,
            key_val_sep: ::std::os::raw::c_char,
            pairs_sep: ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    pub const AVSampleFormat_AV_SAMPLE_FMT_NONE: root::AVSampleFormat = -1;
    #[doc = "< unsigned 8 bits"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_U8: root::AVSampleFormat = 0;
    #[doc = "< signed 16 bits"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_S16: root::AVSampleFormat = 1;
    #[doc = "< signed 32 bits"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_S32: root::AVSampleFormat = 2;
    #[doc = "< float"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_FLT: root::AVSampleFormat = 3;
    #[doc = "< double"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_DBL: root::AVSampleFormat = 4;
    #[doc = "< unsigned 8 bits, planar"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_U8P: root::AVSampleFormat = 5;
    #[doc = "< signed 16 bits, planar"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_S16P: root::AVSampleFormat = 6;
    #[doc = "< signed 32 bits, planar"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_S32P: root::AVSampleFormat = 7;
    #[doc = "< float, planar"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_FLTP: root::AVSampleFormat = 8;
    #[doc = "< double, planar"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_DBLP: root::AVSampleFormat = 9;
    #[doc = "< signed 64 bits"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_S64: root::AVSampleFormat = 10;
    #[doc = "< signed 64 bits, planar"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_S64P: root::AVSampleFormat = 11;
    #[doc = "< Number of sample formats. DO NOT USE if linking dynamically"]
    pub const AVSampleFormat_AV_SAMPLE_FMT_NB: root::AVSampleFormat = 12;
    #[doc = " Audio sample formats"]
    #[doc = ""]
    #[doc = " - The data described by the sample format is always in native-endian order."]
    #[doc = "   Sample values can be expressed by native C types, hence the lack of a signed"]
    #[doc = "   24-bit sample format even though it is a common raw audio data format."]
    #[doc = ""]
    #[doc = " - The floating-point formats are based on full volume being in the range"]
    #[doc = "   [-1.0, 1.0]. Any values outside this range are beyond full volume level."]
    #[doc = ""]
    #[doc = " - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg"]
    #[doc = "   (such as AVFrame in libavcodec) is as follows:"]
    #[doc = ""]
    #[doc = " @par"]
    #[doc = " For planar sample formats, each audio channel is in a separate data plane,"]
    #[doc = " and linesize is the buffer size, in bytes, for a single plane. All data"]
    #[doc = " planes must be the same size. For packed sample formats, only the first data"]
    #[doc = " plane is used, and samples for each channel are interleaved. In this case,"]
    #[doc = " linesize is the buffer size, in bytes, for the 1 plane."]
    #[doc = ""]
    pub type AVSampleFormat = ::std::os::raw::c_int;
    extern "C" {
        #[doc = " Return the name of sample_fmt, or NULL if sample_fmt is not"]
        #[doc = " recognized."]
        pub fn av_get_sample_fmt_name(
            sample_fmt: root::AVSampleFormat,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE"]
        #[doc = " on error."]
        pub fn av_get_sample_fmt(name: *const ::std::os::raw::c_char) -> root::AVSampleFormat;
    }
    extern "C" {
        #[doc = " Return the planar<->packed alternative form of the given sample format, or"]
        #[doc = " AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the"]
        #[doc = " requested planar/packed format, the format returned is the same as the"]
        #[doc = " input."]
        pub fn av_get_alt_sample_fmt(
            sample_fmt: root::AVSampleFormat,
            planar: ::std::os::raw::c_int,
        ) -> root::AVSampleFormat;
    }
    extern "C" {
        #[doc = " Get the packed alternative form of the given sample format."]
        #[doc = ""]
        #[doc = " If the passed sample_fmt is already in packed format, the format returned is"]
        #[doc = " the same as the input."]
        #[doc = ""]
        #[doc = " @return  the packed alternative form of the given sample format or"]
        #[doc = "AV_SAMPLE_FMT_NONE on error."]
        pub fn av_get_packed_sample_fmt(sample_fmt: root::AVSampleFormat) -> root::AVSampleFormat;
    }
    extern "C" {
        #[doc = " Get the planar alternative form of the given sample format."]
        #[doc = ""]
        #[doc = " If the passed sample_fmt is already in planar format, the format returned is"]
        #[doc = " the same as the input."]
        #[doc = ""]
        #[doc = " @return  the planar alternative form of the given sample format or"]
        #[doc = "AV_SAMPLE_FMT_NONE on error."]
        pub fn av_get_planar_sample_fmt(sample_fmt: root::AVSampleFormat) -> root::AVSampleFormat;
    }
    extern "C" {
        #[doc = " Generate a string corresponding to the sample format with"]
        #[doc = " sample_fmt, or a header if sample_fmt is negative."]
        #[doc = ""]
        #[doc = " @param buf the buffer where to write the string"]
        #[doc = " @param buf_size the size of buf"]
        #[doc = " @param sample_fmt the number of the sample format to print the"]
        #[doc = " corresponding info string, or a negative value to print the"]
        #[doc = " corresponding header."]
        #[doc = " @return the pointer to the filled buffer or NULL if sample_fmt is"]
        #[doc = " unknown or in case of other errors"]
        pub fn av_get_sample_fmt_string(
            buf: *mut ::std::os::raw::c_char,
            buf_size: ::std::os::raw::c_int,
            sample_fmt: root::AVSampleFormat,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Return number of bytes per sample."]
        #[doc = ""]
        #[doc = " @param sample_fmt the sample format"]
        #[doc = " @return number of bytes per sample or zero if unknown for the given"]
        #[doc = " sample format"]
        pub fn av_get_bytes_per_sample(sample_fmt: root::AVSampleFormat) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Check if the sample format is planar."]
        #[doc = ""]
        #[doc = " @param sample_fmt the sample format to inspect"]
        #[doc = " @return 1 if the sample format is planar, 0 if it is interleaved"]
        pub fn av_sample_fmt_is_planar(sample_fmt: root::AVSampleFormat) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the required buffer size for the given audio parameters."]
        #[doc = ""]
        #[doc = " @param[out] linesize calculated linesize, may be NULL"]
        #[doc = " @param nb_channels   the number of channels"]
        #[doc = " @param nb_samples    the number of samples in a single channel"]
        #[doc = " @param sample_fmt    the sample format"]
        #[doc = " @param align         buffer size alignment (0 = default, 1 = no alignment)"]
        #[doc = " @return              required buffer size, or negative error code on failure"]
        pub fn av_samples_get_buffer_size(
            linesize: *mut ::std::os::raw::c_int,
            nb_channels: ::std::os::raw::c_int,
            nb_samples: ::std::os::raw::c_int,
            sample_fmt: root::AVSampleFormat,
            align: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Fill plane data pointers and linesize for samples with sample"]
        #[doc = " format sample_fmt."]
        #[doc = ""]
        #[doc = " The audio_data array is filled with the pointers to the samples data planes:"]
        #[doc = " for planar, set the start point of each channel's data within the buffer,"]
        #[doc = " for packed, set the start point of the entire buffer only."]
        #[doc = ""]
        #[doc = " The value pointed to by linesize is set to the aligned size of each"]
        #[doc = " channel's data buffer for planar layout, or to the aligned size of the"]
        #[doc = " buffer for all channels for packed layout."]
        #[doc = ""]
        #[doc = " The buffer in buf must be big enough to contain all the samples"]
        #[doc = " (use av_samples_get_buffer_size() to compute its minimum size),"]
        #[doc = " otherwise the audio_data pointers will point to invalid data."]
        #[doc = ""]
        #[doc = " @see enum AVSampleFormat"]
        #[doc = " The documentation for AVSampleFormat describes the data layout."]
        #[doc = ""]
        #[doc = " @param[out] audio_data  array to be filled with the pointer for each channel"]
        #[doc = " @param[out] linesize    calculated linesize, may be NULL"]
        #[doc = " @param buf              the pointer to a buffer containing the samples"]
        #[doc = " @param nb_channels      the number of channels"]
        #[doc = " @param nb_samples       the number of samples in a single channel"]
        #[doc = " @param sample_fmt       the sample format"]
        #[doc = " @param align            buffer size alignment (0 = default, 1 = no alignment)"]
        #[doc = " @return                 minimum size in bytes required for the buffer on success,"]
        #[doc = "                         or a negative error code on failure"]
        pub fn av_samples_fill_arrays(
            audio_data: *mut *mut u8,
            linesize: *mut ::std::os::raw::c_int,
            buf: *const u8,
            nb_channels: ::std::os::raw::c_int,
            nb_samples: ::std::os::raw::c_int,
            sample_fmt: root::AVSampleFormat,
            align: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Allocate a samples buffer for nb_samples samples, and fill data pointers and"]
        #[doc = " linesize accordingly."]
        #[doc = " The allocated samples buffer can be freed by using av_freep(&audio_data[0])"]
        #[doc = " Allocated data will be initialized to silence."]
        #[doc = ""]
        #[doc = " @see enum AVSampleFormat"]
        #[doc = " The documentation for AVSampleFormat describes the data layout."]
        #[doc = ""]
        #[doc = " @param[out] audio_data  array to be filled with the pointer for each channel"]
        #[doc = " @param[out] linesize    aligned size for audio buffer(s), may be NULL"]
        #[doc = " @param nb_channels      number of audio channels"]
        #[doc = " @param nb_samples       number of samples per channel"]
        #[doc = " @param align            buffer size alignment (0 = default, 1 = no alignment)"]
        #[doc = " @return                 >=0 on success or a negative error code on failure"]
        #[doc = " @todo return the size of the allocated buffer in case of success at the next bump"]
        #[doc = " @see av_samples_fill_arrays()"]
        #[doc = " @see av_samples_alloc_array_and_samples()"]
        pub fn av_samples_alloc(
            audio_data: *mut *mut u8,
            linesize: *mut ::std::os::raw::c_int,
            nb_channels: ::std::os::raw::c_int,
            nb_samples: ::std::os::raw::c_int,
            sample_fmt: root::AVSampleFormat,
            align: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Allocate a data pointers array, samples buffer for nb_samples"]
        #[doc = " samples, and fill data pointers and linesize accordingly."]
        #[doc = ""]
        #[doc = " This is the same as av_samples_alloc(), but also allocates the data"]
        #[doc = " pointers array."]
        #[doc = ""]
        #[doc = " @see av_samples_alloc()"]
        pub fn av_samples_alloc_array_and_samples(
            audio_data: *mut *mut *mut u8,
            linesize: *mut ::std::os::raw::c_int,
            nb_channels: ::std::os::raw::c_int,
            nb_samples: ::std::os::raw::c_int,
            sample_fmt: root::AVSampleFormat,
            align: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Copy samples from src to dst."]
        #[doc = ""]
        #[doc = " @param dst destination array of pointers to data planes"]
        #[doc = " @param src source array of pointers to data planes"]
        #[doc = " @param dst_offset offset in samples at which the data will be written to dst"]
        #[doc = " @param src_offset offset in samples at which the data will be read from src"]
        #[doc = " @param nb_samples number of samples to be copied"]
        #[doc = " @param nb_channels number of audio channels"]
        #[doc = " @param sample_fmt audio sample format"]
        pub fn av_samples_copy(
            dst: *mut *mut u8,
            src: *const *mut u8,
            dst_offset: ::std::os::raw::c_int,
            src_offset: ::std::os::raw::c_int,
            nb_samples: ::std::os::raw::c_int,
            nb_channels: ::std::os::raw::c_int,
            sample_fmt: root::AVSampleFormat,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Fill an audio buffer with silence."]
        #[doc = ""]
        #[doc = " @param audio_data  array of pointers to data planes"]
        #[doc = " @param offset      offset in samples at which to start filling"]
        #[doc = " @param nb_samples  number of samples to fill"]
        #[doc = " @param nb_channels number of audio channels"]
        #[doc = " @param sample_fmt  audio sample format"]
        pub fn av_samples_set_silence(
            audio_data: *mut *mut u8,
            offset: ::std::os::raw::c_int,
            nb_samples: ::std::os::raw::c_int,
            nb_channels: ::std::os::raw::c_int,
            sample_fmt: root::AVSampleFormat,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " The data is the AVPanScan struct defined in libavcodec."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_PANSCAN: root::AVFrameSideDataType = 0;
    #[doc = " ATSC A53 Part 4 Closed Captions."]
    #[doc = " A53 CC bitstream is stored as uint8_t in AVFrameSideData.data."]
    #[doc = " The number of bytes of CC data is AVFrameSideData.size."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_A53_CC: root::AVFrameSideDataType = 1;
    #[doc = " Stereoscopic 3d metadata."]
    #[doc = " The data is the AVStereo3D struct defined in libavutil/stereo3d.h."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_STEREO3D: root::AVFrameSideDataType = 2;
    #[doc = " The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_MATRIXENCODING: root::AVFrameSideDataType = 3;
    #[doc = " Metadata relevant to a downmix procedure."]
    #[doc = " The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_DOWNMIX_INFO: root::AVFrameSideDataType = 4;
    #[doc = " ReplayGain information in the form of the AVReplayGain struct."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_REPLAYGAIN: root::AVFrameSideDataType = 5;
    #[doc = " This side data contains a 3x3 transformation matrix describing an affine"]
    #[doc = " transformation that needs to be applied to the frame for correct"]
    #[doc = " presentation."]
    #[doc = ""]
    #[doc = " See libavutil/display.h for a detailed description of the data."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_DISPLAYMATRIX: root::AVFrameSideDataType = 6;
    #[doc = " Active Format Description data consisting of a single byte as specified"]
    #[doc = " in ETSI TS 101 154 using AVActiveFormatDescription enum."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_AFD: root::AVFrameSideDataType = 7;
    #[doc = " Motion vectors exported by some codecs (on demand through the export_mvs"]
    #[doc = " flag set in the libavcodec AVCodecContext flags2 option)."]
    #[doc = " The data is the AVMotionVector struct defined in"]
    #[doc = " libavutil/motion_vector.h."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_MOTION_VECTORS: root::AVFrameSideDataType = 8;
    #[doc = " Recommmends skipping the specified number of samples. This is exported"]
    #[doc = " only if the \"skip_manual\" AVOption is set in libavcodec."]
    #[doc = " This has the same format as AV_PKT_DATA_SKIP_SAMPLES."]
    #[doc = " @code"]
    #[doc = " u32le number of samples to skip from start of this packet"]
    #[doc = " u32le number of samples to skip from end of this packet"]
    #[doc = " u8    reason for start skip"]
    #[doc = " u8    reason for end   skip (0=padding silence, 1=convergence)"]
    #[doc = " @endcode"]
    pub const AVFrameSideDataType_AV_FRAME_DATA_SKIP_SAMPLES: root::AVFrameSideDataType = 9;
    #[doc = " This side data must be associated with an audio frame and corresponds to"]
    #[doc = " enum AVAudioServiceType defined in avcodec.h."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_AUDIO_SERVICE_TYPE: root::AVFrameSideDataType = 10;
    #[doc = " Mastering display metadata associated with a video frame. The payload is"]
    #[doc = " an AVMasteringDisplayMetadata type and contains information about the"]
    #[doc = " mastering display color volume."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_MASTERING_DISPLAY_METADATA:
        root::AVFrameSideDataType = 11;
    #[doc = " The GOP timecode in 25 bit timecode format. Data format is 64-bit integer."]
    #[doc = " This is set on the first frame of a GOP that has a temporal reference of 0."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_GOP_TIMECODE: root::AVFrameSideDataType = 12;
    #[doc = " The data represents the AVSphericalMapping structure defined in"]
    #[doc = " libavutil/spherical.h."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_SPHERICAL: root::AVFrameSideDataType = 13;
    #[doc = " Content light level (based on CTA-861.3). This payload contains data in"]
    #[doc = " the form of the AVContentLightMetadata struct."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_CONTENT_LIGHT_LEVEL: root::AVFrameSideDataType = 14;
    #[doc = " The data contains an ICC profile as an opaque octet buffer following the"]
    #[doc = " format described by ISO 15076-1 with an optional name defined in the"]
    #[doc = " metadata key entry \"name\"."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_ICC_PROFILE: root::AVFrameSideDataType = 15;
    #[doc = " Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t"]
    #[doc = " where the first uint32_t describes how many (1-3) of the other timecodes are used."]
    #[doc = " The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()"]
    #[doc = " function in libavutil/timecode.h."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_S12M_TIMECODE: root::AVFrameSideDataType = 16;
    #[doc = " HDR dynamic metadata associated with a video frame. The payload is"]
    #[doc = " an AVDynamicHDRPlus type and contains information for color"]
    #[doc = " volume transform - application 4 of SMPTE 2094-40:2016 standard."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_DYNAMIC_HDR_PLUS: root::AVFrameSideDataType = 17;
    #[doc = " Regions Of Interest, the data is an array of AVRegionOfInterest type, the number of"]
    #[doc = " array element is implied by AVFrameSideData.size / AVRegionOfInterest.self_size."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_REGIONS_OF_INTEREST: root::AVFrameSideDataType = 18;
    #[doc = " Encoding parameters for a video frame, as described by AVVideoEncParams."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_VIDEO_ENC_PARAMS: root::AVFrameSideDataType = 19;
    #[doc = " User data unregistered metadata associated with a video frame."]
    #[doc = " This is the H.26[45] UDU SEI message, and shouldn't be used for any other purpose"]
    #[doc = " The data is stored as uint8_t in AVFrameSideData.data which is 16 bytes of"]
    #[doc = " uuid_iso_iec_11578 followed by AVFrameSideData.size - 16 bytes of user_data_payload_byte."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_SEI_UNREGISTERED: root::AVFrameSideDataType = 20;
    #[doc = " Film grain parameters for a frame, described by AVFilmGrainParams."]
    #[doc = " Must be present for every frame which should have film grain applied."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_FILM_GRAIN_PARAMS: root::AVFrameSideDataType = 21;
    #[doc = " Bounding boxes for object detection and classification,"]
    #[doc = " as described by AVDetectionBBoxHeader."]
    pub const AVFrameSideDataType_AV_FRAME_DATA_DETECTION_BBOXES: root::AVFrameSideDataType = 22;
    #[doc = " @defgroup lavu_frame AVFrame"]
    #[doc = " @ingroup lavu_data"]
    #[doc = ""]
    #[doc = " @{"]
    #[doc = " AVFrame is an abstraction for reference-counted raw multimedia data."]
    pub type AVFrameSideDataType = ::std::os::raw::c_uint;
    pub const AVActiveFormatDescription_AV_AFD_SAME: root::AVActiveFormatDescription = 8;
    pub const AVActiveFormatDescription_AV_AFD_4_3: root::AVActiveFormatDescription = 9;
    pub const AVActiveFormatDescription_AV_AFD_16_9: root::AVActiveFormatDescription = 10;
    pub const AVActiveFormatDescription_AV_AFD_14_9: root::AVActiveFormatDescription = 11;
    pub const AVActiveFormatDescription_AV_AFD_4_3_SP_14_9: root::AVActiveFormatDescription = 13;
    pub const AVActiveFormatDescription_AV_AFD_16_9_SP_14_9: root::AVActiveFormatDescription = 14;
    pub const AVActiveFormatDescription_AV_AFD_SP_4_3: root::AVActiveFormatDescription = 15;
    pub type AVActiveFormatDescription = ::std::os::raw::c_uint;
    #[doc = " Structure to hold side data for an AVFrame."]
    #[doc = ""]
    #[doc = " sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added"]
    #[doc = " to the end with a minor bump."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVFrameSideData {
        pub type_: root::AVFrameSideDataType,
        pub data: *mut u8,
        pub size: root::size_t,
        pub metadata: *mut root::AVDictionary,
        pub buf: *mut root::AVBufferRef,
    }
    impl Default for AVFrameSideData {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = " Structure describing a single Region Of Interest."]
    #[doc = ""]
    #[doc = " When multiple regions are defined in a single side-data block, they"]
    #[doc = " should be ordered from most to least important - some encoders are only"]
    #[doc = " capable of supporting a limited number of distinct regions, so will have"]
    #[doc = " to truncate the list."]
    #[doc = ""]
    #[doc = " When overlapping regions are defined, the first region containing a given"]
    #[doc = " area of the frame applies."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVRegionOfInterest {
        #[doc = " Must be set to the size of this data structure (that is,"]
        #[doc = " sizeof(AVRegionOfInterest))."]
        pub self_size: u32,
        #[doc = " Distance in pixels from the top edge of the frame to the top and"]
        #[doc = " bottom edges and from the left edge of the frame to the left and"]
        #[doc = " right edges of the rectangle defining this region of interest."]
        #[doc = ""]
        #[doc = " The constraints on a region are encoder dependent, so the region"]
        #[doc = " actually affected may be slightly larger for alignment or other"]
        #[doc = " reasons."]
        pub top: ::std::os::raw::c_int,
        pub bottom: ::std::os::raw::c_int,
        pub left: ::std::os::raw::c_int,
        pub right: ::std::os::raw::c_int,
        #[doc = " Quantisation offset."]
        #[doc = ""]
        #[doc = " Must be in the range -1 to +1.  A value of zero indicates no quality"]
        #[doc = " change.  A negative value asks for better quality (less quantisation),"]
        #[doc = " while a positive value asks for worse quality (greater quantisation)."]
        #[doc = ""]
        #[doc = " The range is calibrated so that the extreme values indicate the"]
        #[doc = " largest possible offset - if the rest of the frame is encoded with the"]
        #[doc = " worst possible quality, an offset of -1 indicates that this region"]
        #[doc = " should be encoded with the best possible quality anyway.  Intermediate"]
        #[doc = " values are then interpolated in some codec-dependent way."]
        #[doc = ""]
        #[doc = " For example, in 10-bit H.264 the quantisation parameter varies between"]
        #[doc = " -12 and 51.  A typical qoffset value of -1/10 therefore indicates that"]
        #[doc = " this region should be encoded with a QP around one-tenth of the full"]
        #[doc = " range better than the rest of the frame.  So, if most of the frame"]
        #[doc = " were to be encoded with a QP of around 30, this region would get a QP"]
        #[doc = " of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3)."]
        #[doc = " An extreme value of -1 would indicate that this region should be"]
        #[doc = " encoded with the best possible quality regardless of the treatment of"]
        #[doc = " the rest of the frame - that is, should be encoded at a QP of -12."]
        pub qoffset: root::AVRational,
    }
    #[doc = " This structure describes decoded (raw) audio or video data."]
    #[doc = ""]
    #[doc = " AVFrame must be allocated using av_frame_alloc(). Note that this only"]
    #[doc = " allocates the AVFrame itself, the buffers for the data must be managed"]
    #[doc = " through other means (see below)."]
    #[doc = " AVFrame must be freed with av_frame_free()."]
    #[doc = ""]
    #[doc = " AVFrame is typically allocated once and then reused multiple times to hold"]
    #[doc = " different data (e.g. a single AVFrame to hold frames received from a"]
    #[doc = " decoder). In such a case, av_frame_unref() will free any references held by"]
    #[doc = " the frame and reset it to its original clean state before it"]
    #[doc = " is reused again."]
    #[doc = ""]
    #[doc = " The data described by an AVFrame is usually reference counted through the"]
    #[doc = " AVBuffer API. The underlying buffer references are stored in AVFrame.buf /"]
    #[doc = " AVFrame.extended_buf. An AVFrame is considered to be reference counted if at"]
    #[doc = " least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,"]
    #[doc = " every single data plane must be contained in one of the buffers in"]
    #[doc = " AVFrame.buf or AVFrame.extended_buf."]
    #[doc = " There may be a single buffer for all the data, or one separate buffer for"]
    #[doc = " each plane, or anything in between."]
    #[doc = ""]
    #[doc = " sizeof(AVFrame) is not a part of the public ABI, so new fields may be added"]
    #[doc = " to the end with a minor bump."]
    #[doc = ""]
    #[doc = " Fields can be accessed through AVOptions, the name string used, matches the"]
    #[doc = " C structure field name for fields accessible through AVOptions. The AVClass"]
    #[doc = " for AVFrame can be obtained from avcodec_get_frame_class()"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVFrame {
        #[doc = " pointer to the picture/channel planes."]
        #[doc = " This might be different from the first allocated byte"]
        #[doc = ""]
        #[doc = " Some decoders access areas outside 0,0 - width,height, please"]
        #[doc = " see avcodec_align_dimensions2(). Some filters and swscale can read"]
        #[doc = " up to 16 bytes beyond the planes, if these filters are to be used,"]
        #[doc = " then 16 extra bytes must be allocated."]
        #[doc = ""]
        #[doc = " NOTE: Except for hwaccel formats, pointers not needed by the format"]
        #[doc = " MUST be set to NULL."]
        pub data: [*mut u8; 8usize],
        #[doc = " For video, size in bytes of each picture line."]
        #[doc = " For audio, size in bytes of each plane."]
        #[doc = ""]
        #[doc = " For audio, only linesize[0] may be set. For planar audio, each channel"]
        #[doc = " plane must be the same size."]
        #[doc = ""]
        #[doc = " For video the linesizes should be multiples of the CPUs alignment"]
        #[doc = " preference, this is 16 or 32 for modern desktop CPUs."]
        #[doc = " Some code requires such alignment other code can be slower without"]
        #[doc = " correct alignment, for yet other it makes no difference."]
        #[doc = ""]
        #[doc = " @note The linesize may be larger than the size of usable data -- there"]
        #[doc = " may be extra padding present for performance reasons."]
        pub linesize: [::std::os::raw::c_int; 8usize],
        #[doc = " pointers to the data planes/channels."]
        #[doc = ""]
        #[doc = " For video, this should simply point to data[]."]
        #[doc = ""]
        #[doc = " For planar audio, each channel has a separate data pointer, and"]
        #[doc = " linesize[0] contains the size of each channel buffer."]
        #[doc = " For packed audio, there is just one data pointer, and linesize[0]"]
        #[doc = " contains the total size of the buffer for all channels."]
        #[doc = ""]
        #[doc = " Note: Both data and extended_data should always be set in a valid frame,"]
        #[doc = " but for planar audio with more channels that can fit in data,"]
        #[doc = " extended_data must be used in order to access all channels."]
        pub extended_data: *mut *mut u8,
        #[doc = " @name Video dimensions"]
        #[doc = " Video frames only. The coded dimensions (in pixels) of the video frame,"]
        #[doc = " i.e. the size of the rectangle that contains some well-defined values."]
        #[doc = ""]
        #[doc = " @note The part of the frame intended for display/presentation is further"]
        #[doc = " restricted by the @ref cropping \"Cropping rectangle\"."]
        #[doc = " @{"]
        pub width: ::std::os::raw::c_int,
        #[doc = " @name Video dimensions"]
        #[doc = " Video frames only. The coded dimensions (in pixels) of the video frame,"]
        #[doc = " i.e. the size of the rectangle that contains some well-defined values."]
        #[doc = ""]
        #[doc = " @note The part of the frame intended for display/presentation is further"]
        #[doc = " restricted by the @ref cropping \"Cropping rectangle\"."]
        #[doc = " @{"]
        pub height: ::std::os::raw::c_int,
        #[doc = " number of audio samples (per channel) described by this frame"]
        pub nb_samples: ::std::os::raw::c_int,
        #[doc = " format of the frame, -1 if unknown or unset"]
        #[doc = " Values correspond to enum AVPixelFormat for video frames,"]
        #[doc = " enum AVSampleFormat for audio)"]
        pub format: ::std::os::raw::c_int,
        #[doc = " 1 -> keyframe, 0-> not"]
        pub key_frame: ::std::os::raw::c_int,
        #[doc = " Picture type of the frame."]
        pub pict_type: root::AVPictureType,
        #[doc = " Sample aspect ratio for the video frame, 0/1 if unknown/unspecified."]
        pub sample_aspect_ratio: root::AVRational,
        #[doc = " Presentation timestamp in time_base units (time when frame should be shown to user)."]
        pub pts: i64,
        #[doc = " DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)"]
        #[doc = " This is also the Presentation time of this AVFrame calculated from"]
        #[doc = " only AVPacket.dts values without pts values."]
        pub pkt_dts: i64,
        #[doc = " picture number in bitstream order"]
        pub coded_picture_number: ::std::os::raw::c_int,
        #[doc = " picture number in display order"]
        pub display_picture_number: ::std::os::raw::c_int,
        #[doc = " quality (between 1 (good) and FF_LAMBDA_MAX (bad))"]
        pub quality: ::std::os::raw::c_int,
        #[doc = " for some private data of the user"]
        pub opaque: *mut ::std::os::raw::c_void,
        #[doc = " When decoding, this signals how much the picture must be delayed."]
        #[doc = " extra_delay = repeat_pict / (2*fps)"]
        pub repeat_pict: ::std::os::raw::c_int,
        #[doc = " The content of the picture is interlaced."]
        pub interlaced_frame: ::std::os::raw::c_int,
        #[doc = " If the content is interlaced, is top field displayed first."]
        pub top_field_first: ::std::os::raw::c_int,
        #[doc = " Tell user application that palette has changed from previous frame."]
        pub palette_has_changed: ::std::os::raw::c_int,
        #[doc = " reordered opaque 64 bits (generally an integer or a double precision float"]
        #[doc = " PTS but can be anything)."]
        #[doc = " The user sets AVCodecContext.reordered_opaque to represent the input at"]
        #[doc = " that time,"]
        #[doc = " the decoder reorders values as needed and sets AVFrame.reordered_opaque"]
        #[doc = " to exactly one of the values provided by the user through AVCodecContext.reordered_opaque"]
        pub reordered_opaque: i64,
        #[doc = " Sample rate of the audio data."]
        pub sample_rate: ::std::os::raw::c_int,
        #[doc = " Channel layout of the audio data."]
        pub channel_layout: u64,
        #[doc = " AVBuffer references backing the data for this frame. If all elements of"]
        #[doc = " this array are NULL, then this frame is not reference counted. This array"]
        #[doc = " must be filled contiguously -- if buf[i] is non-NULL then buf[j] must"]
        #[doc = " also be non-NULL for all j < i."]
        #[doc = ""]
        #[doc = " There may be at most one AVBuffer per data plane, so for video this array"]
        #[doc = " always contains all the references. For planar audio with more than"]
        #[doc = " AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in"]
        #[doc = " this array. Then the extra AVBufferRef pointers are stored in the"]
        #[doc = " extended_buf array."]
        pub buf: [*mut root::AVBufferRef; 8usize],
        #[doc = " For planar audio which requires more than AV_NUM_DATA_POINTERS"]
        #[doc = " AVBufferRef pointers, this array will hold all the references which"]
        #[doc = " cannot fit into AVFrame.buf."]
        #[doc = ""]
        #[doc = " Note that this is different from AVFrame.extended_data, which always"]
        #[doc = " contains all the pointers. This array only contains the extra pointers,"]
        #[doc = " which cannot fit into AVFrame.buf."]
        #[doc = ""]
        #[doc = " This array is always allocated using av_malloc() by whoever constructs"]
        #[doc = " the frame. It is freed in av_frame_unref()."]
        pub extended_buf: *mut *mut root::AVBufferRef,
        #[doc = " Number of elements in extended_buf."]
        pub nb_extended_buf: ::std::os::raw::c_int,
        pub side_data: *mut *mut root::AVFrameSideData,
        pub nb_side_data: ::std::os::raw::c_int,
        #[doc = " Frame flags, a combination of @ref lavu_frame_flags"]
        pub flags: ::std::os::raw::c_int,
        #[doc = " MPEG vs JPEG YUV range."]
        #[doc = " - encoding: Set by user"]
        #[doc = " - decoding: Set by libavcodec"]
        pub color_range: root::AVColorRange,
        pub color_primaries: root::AVColorPrimaries,
        pub color_trc: root::AVColorTransferCharacteristic,
        #[doc = " YUV colorspace type."]
        #[doc = " - encoding: Set by user"]
        #[doc = " - decoding: Set by libavcodec"]
        pub colorspace: root::AVColorSpace,
        pub chroma_location: root::AVChromaLocation,
        #[doc = " frame timestamp estimated using various heuristics, in stream time base"]
        #[doc = " - encoding: unused"]
        #[doc = " - decoding: set by libavcodec, read by user."]
        pub best_effort_timestamp: i64,
        #[doc = " reordered pos from the last AVPacket that has been input into the decoder"]
        #[doc = " - encoding: unused"]
        #[doc = " - decoding: Read by user."]
        pub pkt_pos: i64,
        #[doc = " duration of the corresponding packet, expressed in"]
        #[doc = " AVStream->time_base units, 0 if unknown."]
        #[doc = " - encoding: unused"]
        #[doc = " - decoding: Read by user."]
        pub pkt_duration: i64,
        #[doc = " metadata."]
        #[doc = " - encoding: Set by user."]
        #[doc = " - decoding: Set by libavcodec."]
        pub metadata: *mut root::AVDictionary,
        #[doc = " decode error flags of the frame, set to a combination of"]
        #[doc = " FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there"]
        #[doc = " were errors during the decoding."]
        #[doc = " - encoding: unused"]
        #[doc = " - decoding: set by libavcodec, read by user."]
        pub decode_error_flags: ::std::os::raw::c_int,
        #[doc = " number of audio channels, only used for audio."]
        #[doc = " - encoding: unused"]
        #[doc = " - decoding: Read by user."]
        pub channels: ::std::os::raw::c_int,
        #[doc = " size of the corresponding packet containing the compressed"]
        #[doc = " frame."]
        #[doc = " It is set to a negative value if unknown."]
        #[doc = " - encoding: unused"]
        #[doc = " - decoding: set by libavcodec, read by user."]
        pub pkt_size: ::std::os::raw::c_int,
        #[doc = " For hwaccel-format frames, this should be a reference to the"]
        #[doc = " AVHWFramesContext describing the frame."]
        pub hw_frames_ctx: *mut root::AVBufferRef,
        #[doc = " AVBufferRef for free use by the API user. FFmpeg will never check the"]
        #[doc = " contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when"]
        #[doc = " the frame is unreferenced. av_frame_copy_props() calls create a new"]
        #[doc = " reference with av_buffer_ref() for the target frame's opaque_ref field."]
        #[doc = ""]
        #[doc = " This is unrelated to the opaque field, although it serves a similar"]
        #[doc = " purpose."]
        pub opaque_ref: *mut root::AVBufferRef,
        #[doc = " @anchor cropping"]
        #[doc = " @name Cropping"]
        #[doc = " Video frames only. The number of pixels to discard from the the"]
        #[doc = " top/bottom/left/right border of the frame to obtain the sub-rectangle of"]
        #[doc = " the frame intended for presentation."]
        #[doc = " @{"]
        pub crop_top: root::size_t,
        pub crop_bottom: root::size_t,
        pub crop_left: root::size_t,
        pub crop_right: root::size_t,
        #[doc = " AVBufferRef for internal use by a single libav* library."]
        #[doc = " Must not be used to transfer data between libraries."]
        #[doc = " Has to be NULL when ownership of the frame leaves the respective library."]
        #[doc = ""]
        #[doc = " Code outside the FFmpeg libs should never check or change the contents of the buffer ref."]
        #[doc = ""]
        #[doc = " FFmpeg calls av_buffer_unref() on it when the frame is unreferenced."]
        #[doc = " av_frame_copy_props() calls create a new reference with av_buffer_ref()"]
        #[doc = " for the target frame's private_ref field."]
        pub private_ref: *mut root::AVBufferRef,
    }
    impl Default for AVFrame {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Get the name of a colorspace."]
        #[doc = " @return a static string identifying the colorspace; can be NULL."]
        #[doc = " @deprecated use av_color_space_name()"]
        pub fn av_get_colorspace_name(val: root::AVColorSpace) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Allocate an AVFrame and set its fields to default values.  The resulting"]
        #[doc = " struct must be freed using av_frame_free()."]
        #[doc = ""]
        #[doc = " @return An AVFrame filled with default values or NULL on failure."]
        #[doc = ""]
        #[doc = " @note this only allocates the AVFrame itself, not the data buffers. Those"]
        #[doc = " must be allocated through other means, e.g. with av_frame_get_buffer() or"]
        #[doc = " manually."]
        pub fn av_frame_alloc() -> *mut root::AVFrame;
    }
    extern "C" {
        #[doc = " Free the frame and any dynamically allocated objects in it,"]
        #[doc = " e.g. extended_data. If the frame is reference counted, it will be"]
        #[doc = " unreferenced first."]
        #[doc = ""]
        #[doc = " @param frame frame to be freed. The pointer will be set to NULL."]
        pub fn av_frame_free(frame: *mut *mut root::AVFrame);
    }
    extern "C" {
        #[doc = " Set up a new reference to the data described by the source frame."]
        #[doc = ""]
        #[doc = " Copy frame properties from src to dst and create a new reference for each"]
        #[doc = " AVBufferRef from src."]
        #[doc = ""]
        #[doc = " If src is not reference counted, new buffers are allocated and the data is"]
        #[doc = " copied."]
        #[doc = ""]
        #[doc = " @warning: dst MUST have been either unreferenced with av_frame_unref(dst),"]
        #[doc = "           or newly allocated with av_frame_alloc() before calling this"]
        #[doc = "           function, or undefined behavior will occur."]
        #[doc = ""]
        #[doc = " @return 0 on success, a negative AVERROR on error"]
        pub fn av_frame_ref(
            dst: *mut root::AVFrame,
            src: *const root::AVFrame,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Create a new frame that references the same data as src."]
        #[doc = ""]
        #[doc = " This is a shortcut for av_frame_alloc()+av_frame_ref()."]
        #[doc = ""]
        #[doc = " @return newly created AVFrame on success, NULL on error."]
        pub fn av_frame_clone(src: *const root::AVFrame) -> *mut root::AVFrame;
    }
    extern "C" {
        #[doc = " Unreference all the buffers referenced by frame and reset the frame fields."]
        pub fn av_frame_unref(frame: *mut root::AVFrame);
    }
    extern "C" {
        #[doc = " Move everything contained in src to dst and reset src."]
        #[doc = ""]
        #[doc = " @warning: dst is not unreferenced, but directly overwritten without reading"]
        #[doc = "           or deallocating its contents. Call av_frame_unref(dst) manually"]
        #[doc = "           before calling this function to ensure that no memory is leaked."]
        pub fn av_frame_move_ref(dst: *mut root::AVFrame, src: *mut root::AVFrame);
    }
    extern "C" {
        #[doc = " Allocate new buffer(s) for audio or video data."]
        #[doc = ""]
        #[doc = " The following fields must be set on frame before calling this function:"]
        #[doc = " - format (pixel format for video, sample format for audio)"]
        #[doc = " - width and height for video"]
        #[doc = " - nb_samples and channel_layout for audio"]
        #[doc = ""]
        #[doc = " This function will fill AVFrame.data and AVFrame.buf arrays and, if"]
        #[doc = " necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf."]
        #[doc = " For planar formats, one buffer will be allocated for each plane."]
        #[doc = ""]
        #[doc = " @warning: if frame already has been allocated, calling this function will"]
        #[doc = "           leak memory. In addition, undefined behavior can occur in certain"]
        #[doc = "           cases."]
        #[doc = ""]
        #[doc = " @param frame frame in which to store the new buffers."]
        #[doc = " @param align Required buffer size alignment. If equal to 0, alignment will be"]
        #[doc = "              chosen automatically for the current CPU. It is highly"]
        #[doc = "              recommended to pass 0 here unless you know what you are doing."]
        #[doc = ""]
        #[doc = " @return 0 on success, a negative AVERROR on error."]
        pub fn av_frame_get_buffer(
            frame: *mut root::AVFrame,
            align: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Check if the frame data is writable."]
        #[doc = ""]
        #[doc = " @return A positive value if the frame data is writable (which is true if and"]
        #[doc = " only if each of the underlying buffers has only one reference, namely the one"]
        #[doc = " stored in this frame). Return 0 otherwise."]
        #[doc = ""]
        #[doc = " If 1 is returned the answer is valid until av_buffer_ref() is called on any"]
        #[doc = " of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly)."]
        #[doc = ""]
        #[doc = " @see av_frame_make_writable(), av_buffer_is_writable()"]
        pub fn av_frame_is_writable(frame: *mut root::AVFrame) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Ensure that the frame data is writable, avoiding data copy if possible."]
        #[doc = ""]
        #[doc = " Do nothing if the frame is writable, allocate new buffers and copy the data"]
        #[doc = " if it is not."]
        #[doc = ""]
        #[doc = " @return 0 on success, a negative AVERROR on error."]
        #[doc = ""]
        #[doc = " @see av_frame_is_writable(), av_buffer_is_writable(),"]
        #[doc = " av_buffer_make_writable()"]
        pub fn av_frame_make_writable(frame: *mut root::AVFrame) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Copy the frame data from src to dst."]
        #[doc = ""]
        #[doc = " This function does not allocate anything, dst must be already initialized and"]
        #[doc = " allocated with the same parameters as src."]
        #[doc = ""]
        #[doc = " This function only copies the frame data (i.e. the contents of the data /"]
        #[doc = " extended data arrays), not any other properties."]
        #[doc = ""]
        #[doc = " @return >= 0 on success, a negative AVERROR on error."]
        pub fn av_frame_copy(
            dst: *mut root::AVFrame,
            src: *const root::AVFrame,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Copy only \"metadata\" fields from src to dst."]
        #[doc = ""]
        #[doc = " Metadata for the purpose of this function are those fields that do not affect"]
        #[doc = " the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample"]
        #[doc = " aspect ratio (for video), but not width/height or channel layout."]
        #[doc = " Side data is also copied."]
        pub fn av_frame_copy_props(
            dst: *mut root::AVFrame,
            src: *const root::AVFrame,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the buffer reference a given data plane is stored in."]
        #[doc = ""]
        #[doc = " @param plane index of the data plane of interest in frame->extended_data."]
        #[doc = ""]
        #[doc = " @return the buffer reference that contains the plane or NULL if the input"]
        #[doc = " frame is not valid."]
        pub fn av_frame_get_plane_buffer(
            frame: *mut root::AVFrame,
            plane: ::std::os::raw::c_int,
        ) -> *mut root::AVBufferRef;
    }
    extern "C" {
        #[doc = " Add a new side data to a frame."]
        #[doc = ""]
        #[doc = " @param frame a frame to which the side data should be added"]
        #[doc = " @param type type of the added side data"]
        #[doc = " @param size size of the side data"]
        #[doc = ""]
        #[doc = " @return newly added side data on success, NULL on error"]
        pub fn av_frame_new_side_data(
            frame: *mut root::AVFrame,
            type_: root::AVFrameSideDataType,
            size: root::size_t,
        ) -> *mut root::AVFrameSideData;
    }
    extern "C" {
        #[doc = " Add a new side data to a frame from an existing AVBufferRef"]
        #[doc = ""]
        #[doc = " @param frame a frame to which the side data should be added"]
        #[doc = " @param type  the type of the added side data"]
        #[doc = " @param buf   an AVBufferRef to add as side data. The ownership of"]
        #[doc = "              the reference is transferred to the frame."]
        #[doc = ""]
        #[doc = " @return newly added side data on success, NULL on error. On failure"]
        #[doc = "         the frame is unchanged and the AVBufferRef remains owned by"]
        #[doc = "         the caller."]
        pub fn av_frame_new_side_data_from_buf(
            frame: *mut root::AVFrame,
            type_: root::AVFrameSideDataType,
            buf: *mut root::AVBufferRef,
        ) -> *mut root::AVFrameSideData;
    }
    extern "C" {
        #[doc = " @return a pointer to the side data of a given type on success, NULL if there"]
        #[doc = " is no side data with such type in this frame."]
        pub fn av_frame_get_side_data(
            frame: *const root::AVFrame,
            type_: root::AVFrameSideDataType,
        ) -> *mut root::AVFrameSideData;
    }
    extern "C" {
        #[doc = " Remove and free all side data instances of the given type."]
        pub fn av_frame_remove_side_data(
            frame: *mut root::AVFrame,
            type_: root::AVFrameSideDataType,
        );
    }
    #[doc = " Apply the maximum possible cropping, even if it requires setting the"]
    #[doc = " AVFrame.data[] entries to unaligned pointers. Passing unaligned data"]
    #[doc = " to FFmpeg API is generally not allowed, and causes undefined behavior"]
    #[doc = " (such as crashes). You can pass unaligned data only to FFmpeg APIs that"]
    #[doc = " are explicitly documented to accept it. Use this flag only if you"]
    #[doc = " absolutely know what you are doing."]
    pub const AV_FRAME_CROP_UNALIGNED: ::std::os::raw::c_uint = 1;
    #[doc = " Flags for frame cropping."]
    pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Crop the given video AVFrame according to its crop_left/crop_top/crop_right/"]
        #[doc = " crop_bottom fields. If cropping is successful, the function will adjust the"]
        #[doc = " data pointers and the width/height fields, and set the crop fields to 0."]
        #[doc = ""]
        #[doc = " In all cases, the cropping boundaries will be rounded to the inherent"]
        #[doc = " alignment of the pixel format. In some cases, such as for opaque hwaccel"]
        #[doc = " formats, the left/top cropping is ignored. The crop fields are set to 0 even"]
        #[doc = " if the cropping was rounded or ignored."]
        #[doc = ""]
        #[doc = " @param frame the frame which should be cropped"]
        #[doc = " @param flags Some combination of AV_FRAME_CROP_* flags, or 0."]
        #[doc = ""]
        #[doc = " @return >= 0 on success, a negative AVERROR on error. If the cropping fields"]
        #[doc = " were invalid, AVERROR(ERANGE) is returned, and nothing is changed."]
        pub fn av_frame_apply_cropping(
            frame: *mut root::AVFrame,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @return a string identifying the side data type"]
        pub fn av_frame_side_data_name(
            type_: root::AVFrameSideDataType,
        ) -> *const ::std::os::raw::c_char;
    }
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_NONE: root::AVHWDeviceType = 0;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_VDPAU: root::AVHWDeviceType = 1;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_CUDA: root::AVHWDeviceType = 2;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_VAAPI: root::AVHWDeviceType = 3;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_DXVA2: root::AVHWDeviceType = 4;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_QSV: root::AVHWDeviceType = 5;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_VIDEOTOOLBOX: root::AVHWDeviceType = 6;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_D3D11VA: root::AVHWDeviceType = 7;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_DRM: root::AVHWDeviceType = 8;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_OPENCL: root::AVHWDeviceType = 9;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_MEDIACODEC: root::AVHWDeviceType = 10;
    pub const AVHWDeviceType_AV_HWDEVICE_TYPE_VULKAN: root::AVHWDeviceType = 11;
    pub type AVHWDeviceType = ::std::os::raw::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVHWDeviceInternal {
        _unused: [u8; 0],
    }
    #[doc = " This struct aggregates all the (hardware/vendor-specific) \"high-level\" state,"]
    #[doc = " i.e. state that is not tied to a concrete processing configuration."]
    #[doc = " E.g., in an API that supports hardware-accelerated encoding and decoding,"]
    #[doc = " this struct will (if possible) wrap the state that is common to both encoding"]
    #[doc = " and decoding and from which specific instances of encoders or decoders can be"]
    #[doc = " derived."]
    #[doc = ""]
    #[doc = " This struct is reference-counted with the AVBuffer mechanism. The"]
    #[doc = " av_hwdevice_ctx_alloc() constructor yields a reference, whose data field"]
    #[doc = " points to the actual AVHWDeviceContext. Further objects derived from"]
    #[doc = " AVHWDeviceContext (such as AVHWFramesContext, describing a frame pool with"]
    #[doc = " specific properties) will hold an internal reference to it. After all the"]
    #[doc = " references are released, the AVHWDeviceContext itself will be freed,"]
    #[doc = " optionally invoking a user-specified callback for uninitializing the hardware"]
    #[doc = " state."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVHWDeviceContext {
        #[doc = " A class for logging. Set by av_hwdevice_ctx_alloc()."]
        pub av_class: *const root::AVClass,
        #[doc = " Private data used internally by libavutil. Must not be accessed in any"]
        #[doc = " way by the caller."]
        pub internal: *mut root::AVHWDeviceInternal,
        #[doc = " This field identifies the underlying API used for hardware access."]
        #[doc = ""]
        #[doc = " This field is set when this struct is allocated and never changed"]
        #[doc = " afterwards."]
        pub type_: root::AVHWDeviceType,
        #[doc = " The format-specific data, allocated and freed by libavutil along with"]
        #[doc = " this context."]
        #[doc = ""]
        #[doc = " Should be cast by the user to the format-specific context defined in the"]
        #[doc = " corresponding header (hwcontext_*.h) and filled as described in the"]
        #[doc = " documentation before calling av_hwdevice_ctx_init()."]
        #[doc = ""]
        #[doc = " After calling av_hwdevice_ctx_init() this struct should not be modified"]
        #[doc = " by the caller."]
        pub hwctx: *mut ::std::os::raw::c_void,
        #[doc = " This field may be set by the caller before calling av_hwdevice_ctx_init()."]
        #[doc = ""]
        #[doc = " If non-NULL, this callback will be called when the last reference to"]
        #[doc = " this context is unreferenced, immediately before it is freed."]
        #[doc = ""]
        #[doc = " @note when other objects (e.g an AVHWFramesContext) are derived from this"]
        #[doc = "       struct, this callback will be invoked after all such child objects"]
        #[doc = "       are fully uninitialized and their respective destructors invoked."]
        pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut root::AVHWDeviceContext)>,
        #[doc = " Arbitrary user data, to be used e.g. by the free() callback."]
        pub user_opaque: *mut ::std::os::raw::c_void,
    }
    impl Default for AVHWDeviceContext {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVHWFramesInternal {
        _unused: [u8; 0],
    }
    #[doc = " This struct describes a set or pool of \"hardware\" frames (i.e. those with"]
    #[doc = " data not located in normal system memory). All the frames in the pool are"]
    #[doc = " assumed to be allocated in the same way and interchangeable."]
    #[doc = ""]
    #[doc = " This struct is reference-counted with the AVBuffer mechanism and tied to a"]
    #[doc = " given AVHWDeviceContext instance. The av_hwframe_ctx_alloc() constructor"]
    #[doc = " yields a reference, whose data field points to the actual AVHWFramesContext"]
    #[doc = " struct."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVHWFramesContext {
        #[doc = " A class for logging."]
        pub av_class: *const root::AVClass,
        #[doc = " Private data used internally by libavutil. Must not be accessed in any"]
        #[doc = " way by the caller."]
        pub internal: *mut root::AVHWFramesInternal,
        #[doc = " A reference to the parent AVHWDeviceContext. This reference is owned and"]
        #[doc = " managed by the enclosing AVHWFramesContext, but the caller may derive"]
        #[doc = " additional references from it."]
        pub device_ref: *mut root::AVBufferRef,
        #[doc = " The parent AVHWDeviceContext. This is simply a pointer to"]
        #[doc = " device_ref->data provided for convenience."]
        #[doc = ""]
        #[doc = " Set by libavutil in av_hwframe_ctx_init()."]
        pub device_ctx: *mut root::AVHWDeviceContext,
        #[doc = " The format-specific data, allocated and freed automatically along with"]
        #[doc = " this context."]
        #[doc = ""]
        #[doc = " Should be cast by the user to the format-specific context defined in the"]
        #[doc = " corresponding header (hwframe_*.h) and filled as described in the"]
        #[doc = " documentation before calling av_hwframe_ctx_init()."]
        #[doc = ""]
        #[doc = " After any frames using this context are created, the contents of this"]
        #[doc = " struct should not be modified by the caller."]
        pub hwctx: *mut ::std::os::raw::c_void,
        #[doc = " This field may be set by the caller before calling av_hwframe_ctx_init()."]
        #[doc = ""]
        #[doc = " If non-NULL, this callback will be called when the last reference to"]
        #[doc = " this context is unreferenced, immediately before it is freed."]
        pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut root::AVHWFramesContext)>,
        #[doc = " Arbitrary user data, to be used e.g. by the free() callback."]
        pub user_opaque: *mut ::std::os::raw::c_void,
        #[doc = " A pool from which the frames are allocated by av_hwframe_get_buffer()."]
        #[doc = " This field may be set by the caller before calling av_hwframe_ctx_init()."]
        #[doc = " The buffers returned by calling av_buffer_pool_get() on this pool must"]
        #[doc = " have the properties described in the documentation in the corresponding hw"]
        #[doc = " type's header (hwcontext_*.h). The pool will be freed strictly before"]
        #[doc = " this struct's free() callback is invoked."]
        #[doc = ""]
        #[doc = " This field may be NULL, then libavutil will attempt to allocate a pool"]
        #[doc = " internally. Note that certain device types enforce pools allocated at"]
        #[doc = " fixed size (frame count), which cannot be extended dynamically. In such a"]
        #[doc = " case, initial_pool_size must be set appropriately."]
        pub pool: *mut root::AVBufferPool,
        #[doc = " Initial size of the frame pool. If a device type does not support"]
        #[doc = " dynamically resizing the pool, then this is also the maximum pool size."]
        #[doc = ""]
        #[doc = " May be set by the caller before calling av_hwframe_ctx_init(). Must be"]
        #[doc = " set if pool is NULL and the device type does not support dynamic pools."]
        pub initial_pool_size: ::std::os::raw::c_int,
        #[doc = " The pixel format identifying the underlying HW surface type."]
        #[doc = ""]
        #[doc = " Must be a hwaccel format, i.e. the corresponding descriptor must have the"]
        #[doc = " AV_PIX_FMT_FLAG_HWACCEL flag set."]
        #[doc = ""]
        #[doc = " Must be set by the user before calling av_hwframe_ctx_init()."]
        pub format: root::AVPixelFormat,
        #[doc = " The pixel format identifying the actual data layout of the hardware"]
        #[doc = " frames."]
        #[doc = ""]
        #[doc = " Must be set by the caller before calling av_hwframe_ctx_init()."]
        #[doc = ""]
        #[doc = " @note when the underlying API does not provide the exact data layout, but"]
        #[doc = " only the colorspace/bit depth, this field should be set to the fully"]
        #[doc = " planar version of that format (e.g. for 8-bit 420 YUV it should be"]
        #[doc = " AV_PIX_FMT_YUV420P, not AV_PIX_FMT_NV12 or anything else)."]
        pub sw_format: root::AVPixelFormat,
        #[doc = " The allocated dimensions of the frames in this pool."]
        #[doc = ""]
        #[doc = " Must be set by the user before calling av_hwframe_ctx_init()."]
        pub width: ::std::os::raw::c_int,
        #[doc = " The allocated dimensions of the frames in this pool."]
        #[doc = ""]
        #[doc = " Must be set by the user before calling av_hwframe_ctx_init()."]
        pub height: ::std::os::raw::c_int,
    }
    impl Default for AVHWFramesContext {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Look up an AVHWDeviceType by name."]
        #[doc = ""]
        #[doc = " @param name String name of the device type (case-insensitive)."]
        #[doc = " @return The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if"]
        #[doc = "         not found."]
        pub fn av_hwdevice_find_type_by_name(
            name: *const ::std::os::raw::c_char,
        ) -> root::AVHWDeviceType;
    }
    extern "C" {
        #[doc = " Get the string name of an AVHWDeviceType."]
        #[doc = ""]
        #[doc = " @param type Type from enum AVHWDeviceType."]
        #[doc = " @return Pointer to a static string containing the name, or NULL if the type"]
        #[doc = "         is not valid."]
        pub fn av_hwdevice_get_type_name(
            type_: root::AVHWDeviceType,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Iterate over supported device types."]
        #[doc = ""]
        #[doc = " @param type AV_HWDEVICE_TYPE_NONE initially, then the previous type"]
        #[doc = "             returned by this function in subsequent iterations."]
        #[doc = " @return The next usable device type from enum AVHWDeviceType, or"]
        #[doc = "         AV_HWDEVICE_TYPE_NONE if there are no more."]
        pub fn av_hwdevice_iterate_types(prev: root::AVHWDeviceType) -> root::AVHWDeviceType;
    }
    extern "C" {
        #[doc = " Allocate an AVHWDeviceContext for a given hardware type."]
        #[doc = ""]
        #[doc = " @param type the type of the hardware device to allocate."]
        #[doc = " @return a reference to the newly created AVHWDeviceContext on success or NULL"]
        #[doc = "         on failure."]
        pub fn av_hwdevice_ctx_alloc(type_: root::AVHWDeviceType) -> *mut root::AVBufferRef;
    }
    extern "C" {
        #[doc = " Finalize the device context before use. This function must be called after"]
        #[doc = " the context is filled with all the required information and before it is"]
        #[doc = " used in any way."]
        #[doc = ""]
        #[doc = " @param ref a reference to the AVHWDeviceContext"]
        #[doc = " @return 0 on success, a negative AVERROR code on failure"]
        pub fn av_hwdevice_ctx_init(ref_: *mut root::AVBufferRef) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Open a device of the specified type and create an AVHWDeviceContext for it."]
        #[doc = ""]
        #[doc = " This is a convenience function intended to cover the simple cases. Callers"]
        #[doc = " who need to fine-tune device creation/management should open the device"]
        #[doc = " manually and then wrap it in an AVHWDeviceContext using"]
        #[doc = " av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init()."]
        #[doc = ""]
        #[doc = " The returned context is already initialized and ready for use, the caller"]
        #[doc = " should not call av_hwdevice_ctx_init() on it. The user_opaque/free fields of"]
        #[doc = " the created AVHWDeviceContext are set by this function and should not be"]
        #[doc = " touched by the caller."]
        #[doc = ""]
        #[doc = " @param device_ctx On success, a reference to the newly-created device context"]
        #[doc = "                   will be written here. The reference is owned by the caller"]
        #[doc = "                   and must be released with av_buffer_unref() when no longer"]
        #[doc = "                   needed. On failure, NULL will be written to this pointer."]
        #[doc = " @param type The type of the device to create."]
        #[doc = " @param device A type-specific string identifying the device to open."]
        #[doc = " @param opts A dictionary of additional (type-specific) options to use in"]
        #[doc = "             opening the device. The dictionary remains owned by the caller."]
        #[doc = " @param flags currently unused"]
        #[doc = ""]
        #[doc = " @return 0 on success, a negative AVERROR code on failure."]
        pub fn av_hwdevice_ctx_create(
            device_ctx: *mut *mut root::AVBufferRef,
            type_: root::AVHWDeviceType,
            device: *const ::std::os::raw::c_char,
            opts: *mut root::AVDictionary,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Create a new device of the specified type from an existing device."]
        #[doc = ""]
        #[doc = " If the source device is a device of the target type or was originally"]
        #[doc = " derived from such a device (possibly through one or more intermediate"]
        #[doc = " devices of other types), then this will return a reference to the"]
        #[doc = " existing device of the same type as is requested."]
        #[doc = ""]
        #[doc = " Otherwise, it will attempt to derive a new device from the given source"]
        #[doc = " device.  If direct derivation to the new type is not implemented, it will"]
        #[doc = " attempt the same derivation from each ancestor of the source device in"]
        #[doc = " turn looking for an implemented derivation method."]
        #[doc = ""]
        #[doc = " @param dst_ctx On success, a reference to the newly-created"]
        #[doc = "                AVHWDeviceContext."]
        #[doc = " @param type    The type of the new device to create."]
        #[doc = " @param src_ctx A reference to an existing AVHWDeviceContext which will be"]
        #[doc = "                used to create the new device."]
        #[doc = " @param flags   Currently unused; should be set to zero."]
        #[doc = " @return        Zero on success, a negative AVERROR code on failure."]
        pub fn av_hwdevice_ctx_create_derived(
            dst_ctx: *mut *mut root::AVBufferRef,
            type_: root::AVHWDeviceType,
            src_ctx: *mut root::AVBufferRef,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Create a new device of the specified type from an existing device."]
        #[doc = ""]
        #[doc = " This function performs the same action as av_hwdevice_ctx_create_derived,"]
        #[doc = " however, it is able to set options for the new device to be derived."]
        #[doc = ""]
        #[doc = " @param dst_ctx On success, a reference to the newly-created"]
        #[doc = "                AVHWDeviceContext."]
        #[doc = " @param type    The type of the new device to create."]
        #[doc = " @param src_ctx A reference to an existing AVHWDeviceContext which will be"]
        #[doc = "                used to create the new device."]
        #[doc = " @param options Options for the new device to create, same format as in"]
        #[doc = "                av_hwdevice_ctx_create."]
        #[doc = " @param flags   Currently unused; should be set to zero."]
        #[doc = " @return        Zero on success, a negative AVERROR code on failure."]
        pub fn av_hwdevice_ctx_create_derived_opts(
            dst_ctx: *mut *mut root::AVBufferRef,
            type_: root::AVHWDeviceType,
            src_ctx: *mut root::AVBufferRef,
            options: *mut root::AVDictionary,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Allocate an AVHWFramesContext tied to a given device context."]
        #[doc = ""]
        #[doc = " @param device_ctx a reference to a AVHWDeviceContext. This function will make"]
        #[doc = "                   a new reference for internal use, the one passed to the"]
        #[doc = "                   function remains owned by the caller."]
        #[doc = " @return a reference to the newly created AVHWFramesContext on success or NULL"]
        #[doc = "         on failure."]
        pub fn av_hwframe_ctx_alloc(device_ctx: *mut root::AVBufferRef) -> *mut root::AVBufferRef;
    }
    extern "C" {
        #[doc = " Finalize the context before use. This function must be called after the"]
        #[doc = " context is filled with all the required information and before it is attached"]
        #[doc = " to any frames."]
        #[doc = ""]
        #[doc = " @param ref a reference to the AVHWFramesContext"]
        #[doc = " @return 0 on success, a negative AVERROR code on failure"]
        pub fn av_hwframe_ctx_init(ref_: *mut root::AVBufferRef) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Allocate a new frame attached to the given AVHWFramesContext."]
        #[doc = ""]
        #[doc = " @param hwframe_ctx a reference to an AVHWFramesContext"]
        #[doc = " @param frame an empty (freshly allocated or unreffed) frame to be filled with"]
        #[doc = "              newly allocated buffers."]
        #[doc = " @param flags currently unused, should be set to zero"]
        #[doc = " @return 0 on success, a negative AVERROR code on failure"]
        pub fn av_hwframe_get_buffer(
            hwframe_ctx: *mut root::AVBufferRef,
            frame: *mut root::AVFrame,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Copy data to or from a hw surface. At least one of dst/src must have an"]
        #[doc = " AVHWFramesContext attached."]
        #[doc = ""]
        #[doc = " If src has an AVHWFramesContext attached, then the format of dst (if set)"]
        #[doc = " must use one of the formats returned by av_hwframe_transfer_get_formats(src,"]
        #[doc = " AV_HWFRAME_TRANSFER_DIRECTION_FROM)."]
        #[doc = " If dst has an AVHWFramesContext attached, then the format of src must use one"]
        #[doc = " of the formats returned by av_hwframe_transfer_get_formats(dst,"]
        #[doc = " AV_HWFRAME_TRANSFER_DIRECTION_TO)"]
        #[doc = ""]
        #[doc = " dst may be \"clean\" (i.e. with data/buf pointers unset), in which case the"]
        #[doc = " data buffers will be allocated by this function using av_frame_get_buffer()."]
        #[doc = " If dst->format is set, then this format will be used, otherwise (when"]
        #[doc = " dst->format is AV_PIX_FMT_NONE) the first acceptable format will be chosen."]
        #[doc = ""]
        #[doc = " The two frames must have matching allocated dimensions (i.e. equal to"]
        #[doc = " AVHWFramesContext.width/height), since not all device types support"]
        #[doc = " transferring a sub-rectangle of the whole surface. The display dimensions"]
        #[doc = " (i.e. AVFrame.width/height) may be smaller than the allocated dimensions, but"]
        #[doc = " also have to be equal for both frames. When the display dimensions are"]
        #[doc = " smaller than the allocated dimensions, the content of the padding in the"]
        #[doc = " destination frame is unspecified."]
        #[doc = ""]
        #[doc = " @param dst the destination frame. dst is not touched on failure."]
        #[doc = " @param src the source frame."]
        #[doc = " @param flags currently unused, should be set to zero"]
        #[doc = " @return 0 on success, a negative AVERROR error code on failure."]
        pub fn av_hwframe_transfer_data(
            dst: *mut root::AVFrame,
            src: *const root::AVFrame,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " Transfer the data from the queried hw frame."]
    pub const AVHWFrameTransferDirection_AV_HWFRAME_TRANSFER_DIRECTION_FROM:
        root::AVHWFrameTransferDirection = 0;
    #[doc = " Transfer the data to the queried hw frame."]
    pub const AVHWFrameTransferDirection_AV_HWFRAME_TRANSFER_DIRECTION_TO:
        root::AVHWFrameTransferDirection = 1;
    pub type AVHWFrameTransferDirection = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Get a list of possible source or target formats usable in"]
        #[doc = " av_hwframe_transfer_data()."]
        #[doc = ""]
        #[doc = " @param hwframe_ctx the frame context to obtain the information for"]
        #[doc = " @param dir the direction of the transfer"]
        #[doc = " @param formats the pointer to the output format list will be written here."]
        #[doc = "                The list is terminated with AV_PIX_FMT_NONE and must be freed"]
        #[doc = "                by the caller when no longer needed using av_free()."]
        #[doc = "                If this function returns successfully, the format list will"]
        #[doc = "                have at least one item (not counting the terminator)."]
        #[doc = "                On failure, the contents of this pointer are unspecified."]
        #[doc = " @param flags currently unused, should be set to zero"]
        #[doc = " @return 0 on success, a negative AVERROR code on failure."]
        pub fn av_hwframe_transfer_get_formats(
            hwframe_ctx: *mut root::AVBufferRef,
            dir: root::AVHWFrameTransferDirection,
            formats: *mut *mut root::AVPixelFormat,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " This struct describes the constraints on hardware frames attached to"]
    #[doc = " a given device with a hardware-specific configuration.  This is returned"]
    #[doc = " by av_hwdevice_get_hwframe_constraints() and must be freed by"]
    #[doc = " av_hwframe_constraints_free() after use."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVHWFramesConstraints {
        #[doc = " A list of possible values for format in the hw_frames_ctx,"]
        #[doc = " terminated by AV_PIX_FMT_NONE.  This member will always be filled."]
        pub valid_hw_formats: *mut root::AVPixelFormat,
        #[doc = " A list of possible values for sw_format in the hw_frames_ctx,"]
        #[doc = " terminated by AV_PIX_FMT_NONE.  Can be NULL if this information is"]
        #[doc = " not known."]
        pub valid_sw_formats: *mut root::AVPixelFormat,
        #[doc = " The minimum size of frames in this hw_frames_ctx."]
        #[doc = " (Zero if not known.)"]
        pub min_width: ::std::os::raw::c_int,
        pub min_height: ::std::os::raw::c_int,
        #[doc = " The maximum size of frames in this hw_frames_ctx."]
        #[doc = " (INT_MAX if not known / no limit.)"]
        pub max_width: ::std::os::raw::c_int,
        pub max_height: ::std::os::raw::c_int,
    }
    impl Default for AVHWFramesConstraints {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Allocate a HW-specific configuration structure for a given HW device."]
        #[doc = " After use, the user must free all members as required by the specific"]
        #[doc = " hardware structure being used, then free the structure itself with"]
        #[doc = " av_free()."]
        #[doc = ""]
        #[doc = " @param device_ctx a reference to the associated AVHWDeviceContext."]
        #[doc = " @return The newly created HW-specific configuration structure on"]
        #[doc = "         success or NULL on failure."]
        pub fn av_hwdevice_hwconfig_alloc(
            device_ctx: *mut root::AVBufferRef,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Get the constraints on HW frames given a device and the HW-specific"]
        #[doc = " configuration to be used with that device.  If no HW-specific"]
        #[doc = " configuration is provided, returns the maximum possible capabilities"]
        #[doc = " of the device."]
        #[doc = ""]
        #[doc = " @param ref a reference to the associated AVHWDeviceContext."]
        #[doc = " @param hwconfig a filled HW-specific configuration structure, or NULL"]
        #[doc = "        to return the maximum possible capabilities of the device."]
        #[doc = " @return AVHWFramesConstraints structure describing the constraints"]
        #[doc = "         on the device, or NULL if not available."]
        pub fn av_hwdevice_get_hwframe_constraints(
            ref_: *mut root::AVBufferRef,
            hwconfig: *const ::std::os::raw::c_void,
        ) -> *mut root::AVHWFramesConstraints;
    }
    extern "C" {
        #[doc = " Free an AVHWFrameConstraints structure."]
        #[doc = ""]
        #[doc = " @param constraints The (filled or unfilled) AVHWFrameConstraints structure."]
        pub fn av_hwframe_constraints_free(constraints: *mut *mut root::AVHWFramesConstraints);
    }
    #[doc = " The mapping must be readable."]
    pub const AV_HWFRAME_MAP_READ: ::std::os::raw::c_uint = 1;
    #[doc = " The mapping must be writeable."]
    pub const AV_HWFRAME_MAP_WRITE: ::std::os::raw::c_uint = 2;
    #[doc = " The mapped frame will be overwritten completely in subsequent"]
    #[doc = " operations, so the current frame data need not be loaded.  Any values"]
    #[doc = " which are not overwritten are unspecified."]
    pub const AV_HWFRAME_MAP_OVERWRITE: ::std::os::raw::c_uint = 4;
    #[doc = " The mapping must be direct.  That is, there must not be any copying in"]
    #[doc = " the map or unmap steps.  Note that performance of direct mappings may"]
    #[doc = " be much lower than normal memory."]
    pub const AV_HWFRAME_MAP_DIRECT: ::std::os::raw::c_uint = 8;
    #[doc = " Flags to apply to frame mappings."]
    pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Map a hardware frame."]
        #[doc = ""]
        #[doc = " This has a number of different possible effects, depending on the format"]
        #[doc = " and origin of the src and dst frames.  On input, src should be a usable"]
        #[doc = " frame with valid buffers and dst should be blank (typically as just created"]
        #[doc = " by av_frame_alloc()).  src should have an associated hwframe context, and"]
        #[doc = " dst may optionally have a format and associated hwframe context."]
        #[doc = ""]
        #[doc = " If src was created by mapping a frame from the hwframe context of dst,"]
        #[doc = " then this function undoes the mapping - dst is replaced by a reference to"]
        #[doc = " the frame that src was originally mapped from."]
        #[doc = ""]
        #[doc = " If both src and dst have an associated hwframe context, then this function"]
        #[doc = " attempts to map the src frame from its hardware context to that of dst and"]
        #[doc = " then fill dst with appropriate data to be usable there.  This will only be"]
        #[doc = " possible if the hwframe contexts and associated devices are compatible -"]
        #[doc = " given compatible devices, av_hwframe_ctx_create_derived() can be used to"]
        #[doc = " create a hwframe context for dst in which mapping should be possible."]
        #[doc = ""]
        #[doc = " If src has a hwframe context but dst does not, then the src frame is"]
        #[doc = " mapped to normal memory and should thereafter be usable as a normal frame."]
        #[doc = " If the format is set on dst, then the mapping will attempt to create dst"]
        #[doc = " with that format and fail if it is not possible.  If format is unset (is"]
        #[doc = " AV_PIX_FMT_NONE) then dst will be mapped with whatever the most appropriate"]
        #[doc = " format to use is (probably the sw_format of the src hwframe context)."]
        #[doc = ""]
        #[doc = " A return value of AVERROR(ENOSYS) indicates that the mapping is not"]
        #[doc = " possible with the given arguments and hwframe setup, while other return"]
        #[doc = " values indicate that it failed somehow."]
        #[doc = ""]
        #[doc = " @param dst Destination frame, to contain the mapping."]
        #[doc = " @param src Source frame, to be mapped."]
        #[doc = " @param flags Some combination of AV_HWFRAME_MAP_* flags."]
        #[doc = " @return Zero on success, negative AVERROR code on failure."]
        pub fn av_hwframe_map(
            dst: *mut root::AVFrame,
            src: *const root::AVFrame,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Create and initialise an AVHWFramesContext as a mapping of another existing"]
        #[doc = " AVHWFramesContext on a different device."]
        #[doc = ""]
        #[doc = " av_hwframe_ctx_init() should not be called after this."]
        #[doc = ""]
        #[doc = " @param derived_frame_ctx  On success, a reference to the newly created"]
        #[doc = "                           AVHWFramesContext."]
        #[doc = " @param derived_device_ctx A reference to the device to create the new"]
        #[doc = "                           AVHWFramesContext on."]
        #[doc = " @param source_frame_ctx   A reference to an existing AVHWFramesContext"]
        #[doc = "                           which will be mapped to the derived context."]
        #[doc = " @param flags  Some combination of AV_HWFRAME_MAP_* flags, defining the"]
        #[doc = "               mapping parameters to apply to frames which are allocated"]
        #[doc = "               in the derived device."]
        #[doc = " @return       Zero on success, negative AVERROR code on failure."]
        pub fn av_hwframe_ctx_create_derived(
            derived_frame_ctx: *mut *mut root::AVBufferRef,
            format: root::AVPixelFormat,
            derived_device_ctx: *mut root::AVBufferRef,
            source_frame_ctx: *mut root::AVBufferRef,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the current time in microseconds."]
        pub fn av_gettime() -> i64;
    }
    extern "C" {
        #[doc = " Get the current time in microseconds since some unspecified starting point."]
        #[doc = " On platforms that support it, the time comes from a monotonic clock"]
        #[doc = " This property makes this time source ideal for measuring relative time."]
        #[doc = " The returned values may not be monotonic on platforms where a monotonic"]
        #[doc = " clock is not available."]
        pub fn av_gettime_relative() -> i64;
    }
    extern "C" {
        #[doc = " Indicates with a boolean result if the av_gettime_relative() time source"]
        #[doc = " is monotonic."]
        pub fn av_gettime_relative_is_monotonic() -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Sleep for a period of time.  Although the duration is expressed in"]
        #[doc = " microseconds, the actual delay may be rounded to the precision of the"]
        #[doc = " system timer."]
        #[doc = ""]
        #[doc = " @param  usec Number of microseconds to sleep."]
        #[doc = " @return zero on success or (negative) error code."]
        pub fn av_usleep(usec: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Assert that floating point operations can be executed."]
        #[doc = ""]
        #[doc = " This will av_assert0() that the cpu is not in MMX state on X86"]
        pub fn av_assert0_fpu();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVDetectionBBox {
        #[doc = " Distance in pixels from the left/top edge of the frame,"]
        #[doc = " together with width and height, defining the bounding box."]
        pub x: ::std::os::raw::c_int,
        pub y: ::std::os::raw::c_int,
        pub w: ::std::os::raw::c_int,
        pub h: ::std::os::raw::c_int,
        #[doc = " Detect result with confidence"]
        pub detect_label: [::std::os::raw::c_char; 64usize],
        pub detect_confidence: root::AVRational,
        pub classify_count: u32,
        pub classify_labels: [[::std::os::raw::c_char; 64usize]; 4usize],
        pub classify_confidences: [root::AVRational; 4usize],
    }
    impl Default for AVDetectionBBox {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVDetectionBBoxHeader {
        #[doc = " Information about how the bounding box is generated."]
        #[doc = " for example, the DNN model name."]
        pub source: [::std::os::raw::c_char; 256usize],
        #[doc = " Number of bounding boxes in the array."]
        pub nb_bboxes: u32,
        #[doc = " Offset in bytes from the beginning of this structure at which"]
        #[doc = " the array of bounding boxes starts."]
        pub bboxes_offset: root::size_t,
        #[doc = " Size of each bounding box in bytes."]
        pub bbox_size: root::size_t,
    }
    impl Default for AVDetectionBBoxHeader {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Allocates memory for AVDetectionBBoxHeader, plus an array of {@code nb_bboxes}"]
        #[doc = " AVDetectionBBox, and initializes the variables."]
        #[doc = " Can be freed with a normal av_free() call."]
        #[doc = ""]
        #[doc = " @param out_size if non-NULL, the size in bytes of the resulting data array is"]
        #[doc = " written here."]
        pub fn av_detection_bbox_alloc(
            nb_bboxes: u32,
            out_size: *mut root::size_t,
        ) -> *mut root::AVDetectionBBoxHeader;
    }
    extern "C" {
        #[doc = " Allocates memory for AVDetectionBBoxHeader, plus an array of {@code nb_bboxes}"]
        #[doc = " AVDetectionBBox, in the given AVFrame {@code frame} as AVFrameSideData of type"]
        #[doc = " AV_FRAME_DATA_DETECTION_BBOXES and initializes the variables."]
        pub fn av_detection_bbox_create_side_data(
            frame: *mut root::AVFrame,
            nb_bboxes: u32,
        ) -> *mut root::AVDetectionBBoxHeader;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVFifoBuffer {
        pub buffer: *mut u8,
        pub rptr: *mut u8,
        pub wptr: *mut u8,
        pub end: *mut u8,
        pub rndx: u32,
        pub wndx: u32,
    }
    impl Default for AVFifoBuffer {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Initialize an AVFifoBuffer."]
        #[doc = " @param size of FIFO"]
        #[doc = " @return AVFifoBuffer or NULL in case of memory allocation failure"]
        pub fn av_fifo_alloc(size: ::std::os::raw::c_uint) -> *mut root::AVFifoBuffer;
    }
    extern "C" {
        #[doc = " Initialize an AVFifoBuffer."]
        #[doc = " @param nmemb number of elements"]
        #[doc = " @param size  size of the single element"]
        #[doc = " @return AVFifoBuffer or NULL in case of memory allocation failure"]
        pub fn av_fifo_alloc_array(
            nmemb: root::size_t,
            size: root::size_t,
        ) -> *mut root::AVFifoBuffer;
    }
    extern "C" {
        #[doc = " Free an AVFifoBuffer."]
        #[doc = " @param f AVFifoBuffer to free"]
        pub fn av_fifo_free(f: *mut root::AVFifoBuffer);
    }
    extern "C" {
        #[doc = " Free an AVFifoBuffer and reset pointer to NULL."]
        #[doc = " @param f AVFifoBuffer to free"]
        pub fn av_fifo_freep(f: *mut *mut root::AVFifoBuffer);
    }
    extern "C" {
        #[doc = " Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied."]
        #[doc = " @param f AVFifoBuffer to reset"]
        pub fn av_fifo_reset(f: *mut root::AVFifoBuffer);
    }
    extern "C" {
        #[doc = " Return the amount of data in bytes in the AVFifoBuffer, that is the"]
        #[doc = " amount of data you can read from it."]
        #[doc = " @param f AVFifoBuffer to read from"]
        #[doc = " @return size"]
        pub fn av_fifo_size(f: *const root::AVFifoBuffer) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return the amount of space in bytes in the AVFifoBuffer, that is the"]
        #[doc = " amount of data you can write into it."]
        #[doc = " @param f AVFifoBuffer to write into"]
        #[doc = " @return size"]
        pub fn av_fifo_space(f: *const root::AVFifoBuffer) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Feed data at specific position from an AVFifoBuffer to a user-supplied callback."]
        #[doc = " Similar as av_fifo_gereric_read but without discarding data."]
        #[doc = " @param f AVFifoBuffer to read from"]
        #[doc = " @param offset offset from current read position"]
        #[doc = " @param buf_size number of bytes to read"]
        #[doc = " @param func generic read function"]
        #[doc = " @param dest data destination"]
        pub fn av_fifo_generic_peek_at(
            f: *mut root::AVFifoBuffer,
            dest: *mut ::std::os::raw::c_void,
            offset: ::std::os::raw::c_int,
            buf_size: ::std::os::raw::c_int,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *mut ::std::os::raw::c_void,
                    arg3: ::std::os::raw::c_int,
                ),
            >,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Feed data from an AVFifoBuffer to a user-supplied callback."]
        #[doc = " Similar as av_fifo_gereric_read but without discarding data."]
        #[doc = " @param f AVFifoBuffer to read from"]
        #[doc = " @param buf_size number of bytes to read"]
        #[doc = " @param func generic read function"]
        #[doc = " @param dest data destination"]
        pub fn av_fifo_generic_peek(
            f: *mut root::AVFifoBuffer,
            dest: *mut ::std::os::raw::c_void,
            buf_size: ::std::os::raw::c_int,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *mut ::std::os::raw::c_void,
                    arg3: ::std::os::raw::c_int,
                ),
            >,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Feed data from an AVFifoBuffer to a user-supplied callback."]
        #[doc = " @param f AVFifoBuffer to read from"]
        #[doc = " @param buf_size number of bytes to read"]
        #[doc = " @param func generic read function"]
        #[doc = " @param dest data destination"]
        pub fn av_fifo_generic_read(
            f: *mut root::AVFifoBuffer,
            dest: *mut ::std::os::raw::c_void,
            buf_size: ::std::os::raw::c_int,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *mut ::std::os::raw::c_void,
                    arg3: ::std::os::raw::c_int,
                ),
            >,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Feed data from a user-supplied callback to an AVFifoBuffer."]
        #[doc = " @param f AVFifoBuffer to write to"]
        #[doc = " @param src data source; non-const since it may be used as a"]
        #[doc = " modifiable context by the function defined in func"]
        #[doc = " @param size number of bytes to write"]
        #[doc = " @param func generic write function; the first parameter is src,"]
        #[doc = " the second is dest_buf, the third is dest_buf_size."]
        #[doc = " func must return the number of bytes written to dest_buf, or <= 0 to"]
        #[doc = " indicate no more data available to write."]
        #[doc = " If func is NULL, src is interpreted as a simple byte array for source data."]
        #[doc = " @return the number of bytes written to the FIFO"]
        pub fn av_fifo_generic_write(
            f: *mut root::AVFifoBuffer,
            src: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *mut ::std::os::raw::c_void,
                    arg3: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Resize an AVFifoBuffer."]
        #[doc = " In case of reallocation failure, the old FIFO is kept unchanged."]
        #[doc = ""]
        #[doc = " @param f AVFifoBuffer to resize"]
        #[doc = " @param size new AVFifoBuffer size in bytes"]
        #[doc = " @return <0 for failure, >=0 otherwise"]
        pub fn av_fifo_realloc2(
            f: *mut root::AVFifoBuffer,
            size: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Enlarge an AVFifoBuffer."]
        #[doc = " In case of reallocation failure, the old FIFO is kept unchanged."]
        #[doc = " The new fifo size may be larger than the requested size."]
        #[doc = ""]
        #[doc = " @param f AVFifoBuffer to resize"]
        #[doc = " @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()"]
        #[doc = " @return <0 for failure, >=0 otherwise"]
        pub fn av_fifo_grow(
            f: *mut root::AVFifoBuffer,
            additional_space: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Read and discard the specified amount of data from an AVFifoBuffer."]
        #[doc = " @param f AVFifoBuffer to read from"]
        #[doc = " @param size amount of data to read in bytes"]
        pub fn av_fifo_drain(f: *mut root::AVFifoBuffer, size: ::std::os::raw::c_int);
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVBlowfish {
        pub p: [u32; 18usize],
        pub s: [[u32; 256usize]; 4usize],
    }
    impl Default for AVBlowfish {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Allocate an AVBlowfish context."]
        pub fn av_blowfish_alloc() -> *mut root::AVBlowfish;
    }
    extern "C" {
        #[doc = " Initialize an AVBlowfish context."]
        #[doc = ""]
        #[doc = " @param ctx an AVBlowfish context"]
        #[doc = " @param key a key"]
        #[doc = " @param key_len length of the key"]
        pub fn av_blowfish_init(
            ctx: *mut root::AVBlowfish,
            key: *const u8,
            key_len: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Encrypt or decrypt a buffer using a previously initialized context."]
        #[doc = ""]
        #[doc = " @param ctx an AVBlowfish context"]
        #[doc = " @param xl left four bytes halves of input to be encrypted"]
        #[doc = " @param xr right four bytes halves of input to be encrypted"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_blowfish_crypt_ecb(
            ctx: *mut root::AVBlowfish,
            xl: *mut u32,
            xr: *mut u32,
            decrypt: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Encrypt or decrypt a buffer using a previously initialized context."]
        #[doc = ""]
        #[doc = " @param ctx an AVBlowfish context"]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst"]
        #[doc = " @param count number of 8 byte blocks"]
        #[doc = " @param iv initialization vector for CBC mode, if NULL ECB will be used"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_blowfish_crypt(
            ctx: *mut root::AVBlowfish,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            iv: *mut u8,
            decrypt: ::std::os::raw::c_int,
        );
    }
    #[doc = " MediaCodec details."]
    #[doc = ""]
    #[doc = " Allocated as AVHWDeviceContext.hwctx"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVMediaCodecDeviceContext {
        #[doc = " android/view/Surface handle, to be filled by the user."]
        #[doc = ""]
        #[doc = " This is the default surface used by decoders on this device."]
        pub surface: *mut ::std::os::raw::c_void,
    }
    impl Default for AVMediaCodecDeviceContext {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = " ReplayGain information (see"]
    #[doc = " http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1.0_specification)."]
    #[doc = " The size of this struct is a part of the public ABI."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVReplayGain {
        #[doc = " Track replay gain in microbels (divide by 100000 to get the value in dB)."]
        #[doc = " Should be set to INT32_MIN when unknown."]
        pub track_gain: i32,
        #[doc = " Peak track amplitude, with 100000 representing full scale (but values"]
        #[doc = " may overflow). 0 when unknown."]
        pub track_peak: u32,
        #[doc = " Same as track_gain, but for the whole album."]
        pub album_gain: i32,
        #[doc = " Same as track_peak, but for the whole album,"]
        pub album_peak: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVMurMur3 {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVMurMur3 hash context."]
        #[doc = ""]
        #[doc = " @return Uninitialized hash context or `NULL` in case of error"]
        pub fn av_murmur3_alloc() -> *mut root::AVMurMur3;
    }
    extern "C" {
        #[doc = " Initialize or reinitialize an AVMurMur3 hash context with a seed."]
        #[doc = ""]
        #[doc = " @param[out] c    Hash context"]
        #[doc = " @param[in]  seed Random seed"]
        #[doc = ""]
        #[doc = " @see av_murmur3_init()"]
        #[doc = " @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of"]
        #[doc = " seeds for MurmurHash3."]
        pub fn av_murmur3_init_seeded(c: *mut root::AVMurMur3, seed: u64);
    }
    extern "C" {
        #[doc = " Initialize or reinitialize an AVMurMur3 hash context."]
        #[doc = ""]
        #[doc = " Equivalent to av_murmur3_init_seeded() with a built-in seed."]
        #[doc = ""]
        #[doc = " @param[out] c    Hash context"]
        #[doc = ""]
        #[doc = " @see av_murmur3_init_seeded()"]
        #[doc = " @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of"]
        #[doc = " seeds for MurmurHash3."]
        pub fn av_murmur3_init(c: *mut root::AVMurMur3);
    }
    extern "C" {
        #[doc = " Update hash context with new data."]
        #[doc = ""]
        #[doc = " @param[out] c    Hash context"]
        #[doc = " @param[in]  src  Input data to update hash with"]
        #[doc = " @param[in]  len  Number of bytes to read from `src`"]
        pub fn av_murmur3_update(c: *mut root::AVMurMur3, src: *const u8, len: root::size_t);
    }
    extern "C" {
        #[doc = " Finish hashing and output digest value."]
        #[doc = ""]
        #[doc = " @param[in,out] c    Hash context"]
        #[doc = " @param[out]    dst  Buffer where output digest value is stored"]
        pub fn av_murmur3_final(c: *mut root::AVMurMur3, dst: *mut u8);
    }
    #[doc = " Video is not stereoscopic (and metadata has to be there)."]
    pub const AVStereo3DType_AV_STEREO3D_2D: root::AVStereo3DType = 0;
    #[doc = " Views are next to each other."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "    LLLLRRRR"]
    #[doc = "    LLLLRRRR"]
    #[doc = "    LLLLRRRR"]
    #[doc = "    ..."]
    #[doc = " @endcode"]
    pub const AVStereo3DType_AV_STEREO3D_SIDEBYSIDE: root::AVStereo3DType = 1;
    #[doc = " Views are on top of each other."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "    LLLLLLLL"]
    #[doc = "    LLLLLLLL"]
    #[doc = "    RRRRRRRR"]
    #[doc = "    RRRRRRRR"]
    #[doc = " @endcode"]
    pub const AVStereo3DType_AV_STEREO3D_TOPBOTTOM: root::AVStereo3DType = 2;
    #[doc = " Views are alternated temporally."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "     frame0   frame1   frame2   ..."]
    #[doc = "    LLLLLLLL RRRRRRRR LLLLLLLL"]
    #[doc = "    LLLLLLLL RRRRRRRR LLLLLLLL"]
    #[doc = "    LLLLLLLL RRRRRRRR LLLLLLLL"]
    #[doc = "    ...      ...      ..."]
    #[doc = " @endcode"]
    pub const AVStereo3DType_AV_STEREO3D_FRAMESEQUENCE: root::AVStereo3DType = 3;
    #[doc = " Views are packed in a checkerboard-like structure per pixel."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "    LRLRLRLR"]
    #[doc = "    RLRLRLRL"]
    #[doc = "    LRLRLRLR"]
    #[doc = "    ..."]
    #[doc = " @endcode"]
    pub const AVStereo3DType_AV_STEREO3D_CHECKERBOARD: root::AVStereo3DType = 4;
    #[doc = " Views are next to each other, but when upscaling"]
    #[doc = " apply a checkerboard pattern."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "     LLLLRRRR          L L L L    R R R R"]
    #[doc = "     LLLLRRRR    =>     L L L L  R R R R"]
    #[doc = "     LLLLRRRR          L L L L    R R R R"]
    #[doc = "     LLLLRRRR           L L L L  R R R R"]
    #[doc = " @endcode"]
    pub const AVStereo3DType_AV_STEREO3D_SIDEBYSIDE_QUINCUNX: root::AVStereo3DType = 5;
    #[doc = " Views are packed per line, as if interlaced."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "    LLLLLLLL"]
    #[doc = "    RRRRRRRR"]
    #[doc = "    LLLLLLLL"]
    #[doc = "    ..."]
    #[doc = " @endcode"]
    pub const AVStereo3DType_AV_STEREO3D_LINES: root::AVStereo3DType = 6;
    #[doc = " Views are packed per column."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "    LRLRLRLR"]
    #[doc = "    LRLRLRLR"]
    #[doc = "    LRLRLRLR"]
    #[doc = "    ..."]
    #[doc = " @endcode"]
    pub const AVStereo3DType_AV_STEREO3D_COLUMNS: root::AVStereo3DType = 7;
    #[doc = " List of possible 3D Types"]
    pub type AVStereo3DType = ::std::os::raw::c_uint;
    #[doc = " Frame contains two packed views."]
    pub const AVStereo3DView_AV_STEREO3D_VIEW_PACKED: root::AVStereo3DView = 0;
    #[doc = " Frame contains only the left view."]
    pub const AVStereo3DView_AV_STEREO3D_VIEW_LEFT: root::AVStereo3DView = 1;
    #[doc = " Frame contains only the right view."]
    pub const AVStereo3DView_AV_STEREO3D_VIEW_RIGHT: root::AVStereo3DView = 2;
    #[doc = " List of possible view types."]
    pub type AVStereo3DView = ::std::os::raw::c_uint;
    #[doc = " Stereo 3D type: this structure describes how two videos are packed"]
    #[doc = " within a single video surface, with additional information as needed."]
    #[doc = ""]
    #[doc = " @note The struct must be allocated with av_stereo3d_alloc() and"]
    #[doc = "       its size is not a part of the public ABI."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVStereo3D {
        #[doc = " How views are packed within the video."]
        pub type_: root::AVStereo3DType,
        #[doc = " Additional information about the frame packing."]
        pub flags: ::std::os::raw::c_int,
        #[doc = " Determines which views are packed."]
        pub view: root::AVStereo3DView,
    }
    impl Default for AVStereo3D {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Allocate an AVStereo3D structure and set its fields to default values."]
        #[doc = " The resulting struct can be freed using av_freep()."]
        #[doc = ""]
        #[doc = " @return An AVStereo3D filled with default values or NULL on failure."]
        pub fn av_stereo3d_alloc() -> *mut root::AVStereo3D;
    }
    extern "C" {
        #[doc = " Allocate a complete AVFrameSideData and add it to the frame."]
        #[doc = ""]
        #[doc = " @param frame The frame which side data is added to."]
        #[doc = ""]
        #[doc = " @return The AVStereo3D structure to be filled by caller."]
        pub fn av_stereo3d_create_side_data(frame: *mut root::AVFrame) -> *mut root::AVStereo3D;
    }
    extern "C" {
        #[doc = " Provide a human-readable name of a given stereo3d type."]
        #[doc = ""]
        #[doc = " @param type The input stereo3d type value."]
        #[doc = ""]
        #[doc = " @return The name of the stereo3d value, or \"unknown\"."]
        pub fn av_stereo3d_type_name(
            type_: ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the AVStereo3DType form a human-readable name."]
        #[doc = ""]
        #[doc = " @param name The input string."]
        #[doc = ""]
        #[doc = " @return The AVStereo3DType value, or -1 if not found."]
        pub fn av_stereo3d_from_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVComponentDescriptor {
        #[doc = " Which of the 4 planes contains the component."]
        pub plane: ::std::os::raw::c_int,
        #[doc = " Number of elements between 2 horizontally consecutive pixels."]
        #[doc = " Elements are bits for bitstream formats, bytes otherwise."]
        pub step: ::std::os::raw::c_int,
        #[doc = " Number of elements before the component of the first pixel."]
        #[doc = " Elements are bits for bitstream formats, bytes otherwise."]
        pub offset: ::std::os::raw::c_int,
        #[doc = " Number of least significant bits that must be shifted away"]
        #[doc = " to get the value."]
        pub shift: ::std::os::raw::c_int,
        #[doc = " Number of bits in the component."]
        pub depth: ::std::os::raw::c_int,
    }
    #[doc = " Descriptor that unambiguously describes how the bits of a pixel are"]
    #[doc = " stored in the up to 4 data planes of an image. It also stores the"]
    #[doc = " subsampling factors and number of components."]
    #[doc = ""]
    #[doc = " @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV"]
    #[doc = "       and all the YUV variants) AVPixFmtDescriptor just stores how values"]
    #[doc = "       are stored not what these values represent."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVPixFmtDescriptor {
        pub name: *const ::std::os::raw::c_char,
        #[doc = "< The number of components each pixel has, (1-4)"]
        pub nb_components: u8,
        #[doc = " Amount to shift the luma width right to find the chroma width."]
        #[doc = " For YV12 this is 1 for example."]
        #[doc = " chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)"]
        #[doc = " The note above is needed to ensure rounding up."]
        #[doc = " This value only refers to the chroma components."]
        pub log2_chroma_w: u8,
        #[doc = " Amount to shift the luma height right to find the chroma height."]
        #[doc = " For YV12 this is 1 for example."]
        #[doc = " chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)"]
        #[doc = " The note above is needed to ensure rounding up."]
        #[doc = " This value only refers to the chroma components."]
        pub log2_chroma_h: u8,
        #[doc = " Combination of AV_PIX_FMT_FLAG_... flags."]
        pub flags: u64,
        #[doc = " Parameters that describe how pixels are packed."]
        #[doc = " If the format has 1 or 2 components, then luma is 0."]
        #[doc = " If the format has 3 or 4 components:"]
        #[doc = "   if the RGB flag is set then 0 is red, 1 is green and 2 is blue;"]
        #[doc = "   otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V."]
        #[doc = ""]
        #[doc = " If present, the Alpha channel is always the last component."]
        pub comp: [root::AVComponentDescriptor; 4usize],
        #[doc = " Alternative comma-separated names."]
        pub alias: *const ::std::os::raw::c_char,
    }
    impl Default for AVPixFmtDescriptor {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Return the number of bits per pixel used by the pixel format"]
        #[doc = " described by pixdesc. Note that this is not the same as the number"]
        #[doc = " of bits per sample."]
        #[doc = ""]
        #[doc = " The returned number of bits refers to the number of bits actually"]
        #[doc = " used for storing the pixel information, that is padding bits are"]
        #[doc = " not counted."]
        pub fn av_get_bits_per_pixel(
            pixdesc: *const root::AVPixFmtDescriptor,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return the number of bits per pixel for the pixel format"]
        #[doc = " described by pixdesc, including any padding or unused bits."]
        pub fn av_get_padded_bits_per_pixel(
            pixdesc: *const root::AVPixFmtDescriptor,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @return a pixel format descriptor for provided pixel format or NULL if"]
        #[doc = " this pixel format is unknown."]
        pub fn av_pix_fmt_desc_get(pix_fmt: root::AVPixelFormat)
            -> *const root::AVPixFmtDescriptor;
    }
    extern "C" {
        #[doc = " Iterate over all pixel format descriptors known to libavutil."]
        #[doc = ""]
        #[doc = " @param prev previous descriptor. NULL to get the first descriptor."]
        #[doc = ""]
        #[doc = " @return next descriptor or NULL after the last descriptor"]
        pub fn av_pix_fmt_desc_next(
            prev: *const root::AVPixFmtDescriptor,
        ) -> *const root::AVPixFmtDescriptor;
    }
    extern "C" {
        #[doc = " @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc"]
        #[doc = " is not a valid pointer to a pixel format descriptor."]
        pub fn av_pix_fmt_desc_get_id(desc: *const root::AVPixFmtDescriptor)
            -> root::AVPixelFormat;
    }
    extern "C" {
        #[doc = " Utility function to access log2_chroma_w log2_chroma_h from"]
        #[doc = " the pixel format AVPixFmtDescriptor."]
        #[doc = ""]
        #[doc = " @param[in]  pix_fmt the pixel format"]
        #[doc = " @param[out] h_shift store log2_chroma_w (horizontal/width shift)"]
        #[doc = " @param[out] v_shift store log2_chroma_h (vertical/height shift)"]
        #[doc = ""]
        #[doc = " @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format"]
        pub fn av_pix_fmt_get_chroma_sub_sample(
            pix_fmt: root::AVPixelFormat,
            h_shift: *mut ::std::os::raw::c_int,
            v_shift: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a"]
        #[doc = " valid pixel format."]
        pub fn av_pix_fmt_count_planes(pix_fmt: root::AVPixelFormat) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @return the name for provided color range or NULL if unknown."]
        pub fn av_color_range_name(range: root::AVColorRange) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " @return the AVColorRange value for name or an AVError if not found."]
        pub fn av_color_range_from_name(
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @return the name for provided color primaries or NULL if unknown."]
        pub fn av_color_primaries_name(
            primaries: root::AVColorPrimaries,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " @return the AVColorPrimaries value for name or an AVError if not found."]
        pub fn av_color_primaries_from_name(
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @return the name for provided color transfer or NULL if unknown."]
        pub fn av_color_transfer_name(
            transfer: root::AVColorTransferCharacteristic,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " @return the AVColorTransferCharacteristic value for name or an AVError if not found."]
        pub fn av_color_transfer_from_name(
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @return the name for provided color space or NULL if unknown."]
        pub fn av_color_space_name(space: root::AVColorSpace) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " @return the AVColorSpace value for name or an AVError if not found."]
        pub fn av_color_space_from_name(
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @return the name for provided chroma location or NULL if unknown."]
        pub fn av_chroma_location_name(
            location: root::AVChromaLocation,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " @return the AVChromaLocation value for name or an AVError if not found."]
        pub fn av_chroma_location_from_name(
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return the pixel format corresponding to name."]
        #[doc = ""]
        #[doc = " If there is no pixel format with name name, then looks for a"]
        #[doc = " pixel format with the name corresponding to the native endian"]
        #[doc = " format of name."]
        #[doc = " For example in a little-endian system, first looks for \"gray16\","]
        #[doc = " then for \"gray16le\"."]
        #[doc = ""]
        #[doc = " Finally if no pixel format has been found, returns AV_PIX_FMT_NONE."]
        pub fn av_get_pix_fmt(name: *const ::std::os::raw::c_char) -> root::AVPixelFormat;
    }
    extern "C" {
        #[doc = " Return the short name for a pixel format, NULL in case pix_fmt is"]
        #[doc = " unknown."]
        #[doc = ""]
        #[doc = " @see av_get_pix_fmt(), av_get_pix_fmt_string()"]
        pub fn av_get_pix_fmt_name(pix_fmt: root::AVPixelFormat) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Print in buf the string corresponding to the pixel format with"]
        #[doc = " number pix_fmt, or a header if pix_fmt is negative."]
        #[doc = ""]
        #[doc = " @param buf the buffer where to write the string"]
        #[doc = " @param buf_size the size of buf"]
        #[doc = " @param pix_fmt the number of the pixel format to print the"]
        #[doc = " corresponding info string, or a negative value to print the"]
        #[doc = " corresponding header."]
        pub fn av_get_pix_fmt_string(
            buf: *mut ::std::os::raw::c_char,
            buf_size: ::std::os::raw::c_int,
            pix_fmt: root::AVPixelFormat,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Read a line from an image, and write the values of the"]
        #[doc = " pixel format component c to dst."]
        #[doc = ""]
        #[doc = " @param data the array containing the pointers to the planes of the image"]
        #[doc = " @param linesize the array containing the linesizes of the image"]
        #[doc = " @param desc the pixel format descriptor for the image"]
        #[doc = " @param x the horizontal coordinate of the first pixel to read"]
        #[doc = " @param y the vertical coordinate of the first pixel to read"]
        #[doc = " @param w the width of the line to read, that is the number of"]
        #[doc = " values to write to dst"]
        #[doc = " @param read_pal_component if not zero and the format is a paletted"]
        #[doc = " format writes the values corresponding to the palette"]
        #[doc = " component c in data[1] to dst, rather than the palette indexes in"]
        #[doc = " data[0]. The behavior is undefined if the format is not paletted."]
        #[doc = " @param dst_element_size size of elements in dst array (2 or 4 byte)"]
        pub fn av_read_image_line2(
            dst: *mut ::std::os::raw::c_void,
            data: *mut *const u8,
            linesize: *const ::std::os::raw::c_int,
            desc: *const root::AVPixFmtDescriptor,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            c: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            read_pal_component: ::std::os::raw::c_int,
            dst_element_size: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn av_read_image_line(
            dst: *mut u16,
            data: *mut *const u8,
            linesize: *const ::std::os::raw::c_int,
            desc: *const root::AVPixFmtDescriptor,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            c: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            read_pal_component: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Write the values from src to the pixel format component c of an"]
        #[doc = " image line."]
        #[doc = ""]
        #[doc = " @param src array containing the values to write"]
        #[doc = " @param data the array containing the pointers to the planes of the"]
        #[doc = " image to write into. It is supposed to be zeroed."]
        #[doc = " @param linesize the array containing the linesizes of the image"]
        #[doc = " @param desc the pixel format descriptor for the image"]
        #[doc = " @param x the horizontal coordinate of the first pixel to write"]
        #[doc = " @param y the vertical coordinate of the first pixel to write"]
        #[doc = " @param w the width of the line to write, that is the number of"]
        #[doc = " values to write to the image line"]
        #[doc = " @param src_element_size size of elements in src array (2 or 4 byte)"]
        pub fn av_write_image_line2(
            src: *const ::std::os::raw::c_void,
            data: *mut *mut u8,
            linesize: *const ::std::os::raw::c_int,
            desc: *const root::AVPixFmtDescriptor,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            c: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            src_element_size: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn av_write_image_line(
            src: *const u16,
            data: *mut *mut u8,
            linesize: *const ::std::os::raw::c_int,
            desc: *const root::AVPixFmtDescriptor,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            c: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Utility function to swap the endianness of a pixel format."]
        #[doc = ""]
        #[doc = " @param[in]  pix_fmt the pixel format"]
        #[doc = ""]
        #[doc = " @return pixel format with swapped endianness if it exists,"]
        #[doc = " otherwise AV_PIX_FMT_NONE"]
        pub fn av_pix_fmt_swap_endianness(pix_fmt: root::AVPixelFormat) -> root::AVPixelFormat;
    }
    extern "C" {
        #[doc = " Compute what kind of losses will occur when converting from one specific"]
        #[doc = " pixel format to another."]
        #[doc = " When converting from one pixel format to another, information loss may occur."]
        #[doc = " For example, when converting from RGB24 to GRAY, the color information will"]
        #[doc = " be lost. Similarly, other losses occur when converting from some formats to"]
        #[doc = " other formats. These losses can involve loss of chroma, but also loss of"]
        #[doc = " resolution, loss of color depth, loss due to the color space conversion, loss"]
        #[doc = " of the alpha bits or loss due to color quantization."]
        #[doc = " av_get_fix_fmt_loss() informs you about the various types of losses"]
        #[doc = " which will occur when converting from one pixel format to another."]
        #[doc = ""]
        #[doc = " @param[in] dst_pix_fmt destination pixel format"]
        #[doc = " @param[in] src_pix_fmt source pixel format"]
        #[doc = " @param[in] has_alpha Whether the source pixel format alpha channel is used."]
        #[doc = " @return Combination of flags informing you what kind of losses will occur"]
        #[doc = " (maximum loss for an invalid dst_pix_fmt)."]
        pub fn av_get_pix_fmt_loss(
            dst_pix_fmt: root::AVPixelFormat,
            src_pix_fmt: root::AVPixelFormat,
            has_alpha: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Compute what kind of losses will occur when converting from one specific"]
        #[doc = " pixel format to another."]
        #[doc = " When converting from one pixel format to another, information loss may occur."]
        #[doc = " For example, when converting from RGB24 to GRAY, the color information will"]
        #[doc = " be lost. Similarly, other losses occur when converting from some formats to"]
        #[doc = " other formats. These losses can involve loss of chroma, but also loss of"]
        #[doc = " resolution, loss of color depth, loss due to the color space conversion, loss"]
        #[doc = " of the alpha bits or loss due to color quantization."]
        #[doc = " av_get_fix_fmt_loss() informs you about the various types of losses"]
        #[doc = " which will occur when converting from one pixel format to another."]
        #[doc = ""]
        #[doc = " @param[in] dst_pix_fmt destination pixel format"]
        #[doc = " @param[in] src_pix_fmt source pixel format"]
        #[doc = " @param[in] has_alpha Whether the source pixel format alpha channel is used."]
        #[doc = " @return Combination of flags informing you what kind of losses will occur"]
        #[doc = " (maximum loss for an invalid dst_pix_fmt)."]
        pub fn av_find_best_pix_fmt_of_2(
            dst_pix_fmt1: root::AVPixelFormat,
            dst_pix_fmt2: root::AVPixelFormat,
            src_pix_fmt: root::AVPixelFormat,
            has_alpha: ::std::os::raw::c_int,
            loss_ptr: *mut ::std::os::raw::c_int,
        ) -> root::AVPixelFormat;
    }
    extern "C" {
        #[doc = " Decode a base64-encoded string."]
        #[doc = ""]
        #[doc = " @param out      buffer for decoded data"]
        #[doc = " @param in       null-terminated input string"]
        #[doc = " @param out_size size in bytes of the out buffer, must be at"]
        #[doc = "                 least 3/4 of the length of in, that is AV_BASE64_DECODE_SIZE(strlen(in))"]
        #[doc = " @return         number of bytes written, or a negative value in case of"]
        #[doc = "                 invalid input"]
        pub fn av_base64_decode(
            out: *mut u8,
            in_: *const ::std::os::raw::c_char,
            out_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Encode data to base64 and null-terminate."]
        #[doc = ""]
        #[doc = " @param out      buffer for encoded data"]
        #[doc = " @param out_size size in bytes of the out buffer (including the"]
        #[doc = "                 null terminator), must be at least AV_BASE64_SIZE(in_size)"]
        #[doc = " @param in       input buffer containing the data to encode"]
        #[doc = " @param in_size  size in bytes of the in buffer"]
        #[doc = " @return         out or NULL in case of error"]
        pub fn av_base64_encode(
            out: *mut ::std::os::raw::c_char,
            out_size: ::std::os::raw::c_int,
            in_: *const u8,
            in_size: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " @defgroup lavu_sha SHA"]
        #[doc = " @ingroup lavu_hash"]
        #[doc = " SHA-1 and SHA-256 (Secure Hash Algorithm) hash function implementations."]
        #[doc = ""]
        #[doc = " This module supports the following SHA hash functions:"]
        #[doc = ""]
        #[doc = " - SHA-1: 160 bits"]
        #[doc = " - SHA-224: 224 bits, as a variant of SHA-2"]
        #[doc = " - SHA-256: 256 bits, as a variant of SHA-2"]
        #[doc = ""]
        #[doc = " @see For SHA-384, SHA-512, and variants thereof, see @ref lavu_sha512."]
        #[doc = ""]
        #[doc = " @{"]
        pub static av_sha_size: ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVSHA {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVSHA context."]
        pub fn av_sha_alloc() -> *mut root::AVSHA;
    }
    extern "C" {
        #[doc = " Initialize SHA-1 or SHA-2 hashing."]
        #[doc = ""]
        #[doc = " @param context pointer to the function context (of size av_sha_size)"]
        #[doc = " @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)"]
        #[doc = " @return        zero if initialization succeeded, -1 otherwise"]
        pub fn av_sha_init(
            context: *mut root::AVSHA,
            bits: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Update hash value."]
        #[doc = ""]
        #[doc = " @param ctx     hash function context"]
        #[doc = " @param data    input data to update hash with"]
        #[doc = " @param len     input data length"]
        pub fn av_sha_update(ctx: *mut root::AVSHA, data: *const u8, len: root::size_t);
    }
    extern "C" {
        #[doc = " Finish hashing and output digest value."]
        #[doc = ""]
        #[doc = " @param context hash function context"]
        #[doc = " @param digest  buffer where output digest value is stored"]
        pub fn av_sha_final(context: *mut root::AVSHA, digest: *mut u8);
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVMotionVector {
        #[doc = " Where the current macroblock comes from; negative value when it comes"]
        #[doc = " from the past, positive value when it comes from the future."]
        #[doc = " XXX: set exact relative ref frame reference instead of a +/- 1 \"direction\"."]
        pub source: i32,
        #[doc = " Width and height of the block."]
        pub w: u8,
        #[doc = " Width and height of the block."]
        pub h: u8,
        #[doc = " Absolute source position. Can be outside the frame area."]
        pub src_x: i16,
        #[doc = " Absolute source position. Can be outside the frame area."]
        pub src_y: i16,
        #[doc = " Absolute destination position. Can be outside the frame area."]
        pub dst_x: i16,
        #[doc = " Absolute destination position. Can be outside the frame area."]
        pub dst_y: i16,
        #[doc = " Extra flag information."]
        #[doc = " Currently unused."]
        pub flags: u64,
        #[doc = " Motion vector"]
        #[doc = " src_x = dst_x + motion_x / motion_scale"]
        #[doc = " src_y = dst_y + motion_y / motion_scale"]
        pub motion_x: i32,
        #[doc = " Motion vector"]
        #[doc = " src_x = dst_x + motion_x / motion_scale"]
        #[doc = " src_y = dst_y + motion_y / motion_scale"]
        pub motion_y: i32,
        pub motion_scale: u16,
    }
    #[doc = " Context structure for the Lagged Fibonacci PRNG."]
    #[doc = " The exact layout, types and content of this struct may change and should"]
    #[doc = " not be accessed directly. Only its sizeof() is guranteed to stay the same"]
    #[doc = " to allow easy instanciation."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVLFG {
        pub state: [::std::os::raw::c_uint; 64usize],
        pub index: ::std::os::raw::c_int,
    }
    impl Default for AVLFG {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        pub fn av_lfg_init(c: *mut root::AVLFG, seed: ::std::os::raw::c_uint);
    }
    extern "C" {
        #[doc = " Seed the state of the ALFG using binary data."]
        #[doc = ""]
        #[doc = " Return value: 0 on success, negative value (AVERROR) on failure."]
        pub fn av_lfg_init_from_data(
            c: *mut root::AVLFG,
            data: *const u8,
            length: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the next two numbers generated by a Box-Muller Gaussian"]
        #[doc = " generator using the random numbers issued by lfg."]
        #[doc = ""]
        #[doc = " @param out array where the two generated numbers are placed"]
        pub fn av_bmg_get(lfg: *mut root::AVLFG, out: *mut f64);
    }
    #[doc = " @file"]
    #[doc = " @brief Public header for libavutil XTEA algorithm"]
    #[doc = " @defgroup lavu_xtea XTEA"]
    #[doc = " @ingroup lavu_crypto"]
    #[doc = " @{"]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVXTEA {
        pub key: [u32; 16usize],
    }
    extern "C" {
        #[doc = " Allocate an AVXTEA context."]
        pub fn av_xtea_alloc() -> *mut root::AVXTEA;
    }
    extern "C" {
        #[doc = " Initialize an AVXTEA context."]
        #[doc = ""]
        #[doc = " @param ctx an AVXTEA context"]
        #[doc = " @param key a key of 16 bytes used for encryption/decryption,"]
        #[doc = "            interpreted as big endian 32 bit numbers"]
        pub fn av_xtea_init(ctx: *mut root::AVXTEA, key: *const u8);
    }
    extern "C" {
        #[doc = " Initialize an AVXTEA context."]
        #[doc = ""]
        #[doc = " @param ctx an AVXTEA context"]
        #[doc = " @param key a key of 16 bytes used for encryption/decryption,"]
        #[doc = "            interpreted as little endian 32 bit numbers"]
        pub fn av_xtea_le_init(ctx: *mut root::AVXTEA, key: *const u8);
    }
    extern "C" {
        #[doc = " Encrypt or decrypt a buffer using a previously initialized context,"]
        #[doc = " in big endian format."]
        #[doc = ""]
        #[doc = " @param ctx an AVXTEA context"]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst"]
        #[doc = " @param count number of 8 byte blocks"]
        #[doc = " @param iv initialization vector for CBC mode, if NULL then ECB will be used"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_xtea_crypt(
            ctx: *mut root::AVXTEA,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            iv: *mut u8,
            decrypt: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Encrypt or decrypt a buffer using a previously initialized context,"]
        #[doc = " in little endian format."]
        #[doc = ""]
        #[doc = " @param ctx an AVXTEA context"]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst"]
        #[doc = " @param count number of 8 byte blocks"]
        #[doc = " @param iv initialization vector for CBC mode, if NULL then ECB will be used"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_xtea_le_crypt(
            ctx: *mut root::AVXTEA,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            iv: *mut u8,
            decrypt: ::std::os::raw::c_int,
        );
    }
    #[doc = " @defgroup lavu_crc32 CRC"]
    #[doc = " @ingroup lavu_hash"]
    #[doc = " CRC (Cyclic Redundancy Check) hash function implementation."]
    #[doc = ""]
    #[doc = " This module supports numerous CRC polynomials, in addition to the most"]
    #[doc = " widely used CRC-32-IEEE. See @ref AVCRCId for a list of available"]
    #[doc = " polynomials."]
    #[doc = ""]
    #[doc = " @{"]
    pub type AVCRC = u32;
    pub const AVCRCId_AV_CRC_8_ATM: root::AVCRCId = 0;
    pub const AVCRCId_AV_CRC_16_ANSI: root::AVCRCId = 1;
    pub const AVCRCId_AV_CRC_16_CCITT: root::AVCRCId = 2;
    pub const AVCRCId_AV_CRC_32_IEEE: root::AVCRCId = 3;
    pub const AVCRCId_AV_CRC_32_IEEE_LE: root::AVCRCId = 4;
    pub const AVCRCId_AV_CRC_16_ANSI_LE: root::AVCRCId = 5;
    pub const AVCRCId_AV_CRC_24_IEEE: root::AVCRCId = 6;
    pub const AVCRCId_AV_CRC_8_EBU: root::AVCRCId = 7;
    pub const AVCRCId_AV_CRC_MAX: root::AVCRCId = 8;
    pub type AVCRCId = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Initialize a CRC table."]
        #[doc = " @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024"]
        #[doc = " @param le If 1, the lowest bit represents the coefficient for the highest"]
        #[doc = "           exponent of the corresponding polynomial (both for poly and"]
        #[doc = "           actual CRC)."]
        #[doc = "           If 0, you must swap the CRC parameter and the result of av_crc"]
        #[doc = "           if you need the standard representation (can be simplified in"]
        #[doc = "           most cases to e.g. bswap16):"]
        #[doc = "           av_bswap32(crc << (32-bits))"]
        #[doc = " @param bits number of bits for the CRC"]
        #[doc = " @param poly generator polynomial without the x**bits coefficient, in the"]
        #[doc = "             representation as specified by le"]
        #[doc = " @param ctx_size size of ctx in bytes"]
        #[doc = " @return <0 on failure"]
        pub fn av_crc_init(
            ctx: *mut root::AVCRC,
            le: ::std::os::raw::c_int,
            bits: ::std::os::raw::c_int,
            poly: u32,
            ctx_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get an initialized standard CRC table."]
        #[doc = " @param crc_id ID of a standard CRC"]
        #[doc = " @return a pointer to the CRC table or NULL on failure"]
        pub fn av_crc_get_table(crc_id: root::AVCRCId) -> *const root::AVCRC;
    }
    extern "C" {
        #[doc = " Calculate the CRC of a block."]
        #[doc = " @param crc CRC of previous blocks if any or initial value for CRC"]
        #[doc = " @return CRC updated with the data from the given block"]
        #[doc = ""]
        #[doc = " @see av_crc_init() \"le\" parameter"]
        pub fn av_crc(
            ctx: *const root::AVCRC,
            crc: u32,
            buffer: *const u8,
            length: root::size_t,
        ) -> u32;
    }
    extern "C" {
        #[doc = " Read the file with name filename, and put its content in a newly"]
        #[doc = " allocated buffer or map it with mmap() when available."]
        #[doc = " In case of success set *bufptr to the read or mmapped buffer, and"]
        #[doc = " *size to the size in bytes of the buffer in *bufptr."]
        #[doc = " Unlike mmap this function succeeds with zero sized files, in this"]
        #[doc = " case *bufptr will be set to NULL and *size will be set to 0."]
        #[doc = " The returned buffer must be released with av_file_unmap()."]
        #[doc = ""]
        #[doc = " @param log_offset loglevel offset used for logging"]
        #[doc = " @param log_ctx context used for logging"]
        #[doc = " @return a non negative number in case of success, a negative value"]
        #[doc = " corresponding to an AVERROR error code in case of failure"]
        pub fn av_file_map(
            filename: *const ::std::os::raw::c_char,
            bufptr: *mut *mut u8,
            size: *mut root::size_t,
            log_offset: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Unmap or free the buffer bufptr created by av_file_map()."]
        #[doc = ""]
        #[doc = " @param size size in bytes of bufptr, must be the same as returned"]
        #[doc = " by av_file_map()"]
        pub fn av_file_unmap(bufptr: *mut u8, size: root::size_t);
    }
    extern "C" {
        #[doc = " Wrapper to work around the lack of mkstemp() on mingw."]
        #[doc = " Also, tries to create file in /tmp first, if possible."]
        #[doc = " *prefix can be a character constant; *filename will be allocated internally."]
        #[doc = " @return file descriptor of opened file (or negative value corresponding to an"]
        #[doc = " AVERROR code on error)"]
        #[doc = " and opened file name in **filename."]
        #[doc = " @note On very old libcs it is necessary to set a secure umask before"]
        #[doc = "       calling this, av_tempfile() can't call umask itself as it is used in"]
        #[doc = "       libraries and could interfere with the calling application."]
        #[doc = " @deprecated as fd numbers cannot be passed saftely between libs on some platforms"]
        pub fn av_tempfile(
            prefix: *const ::std::os::raw::c_char,
            filename: *mut *mut ::std::os::raw::c_char,
            log_offset: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @defgroup lavu_md5 MD5"]
        #[doc = " @ingroup lavu_hash"]
        #[doc = " MD5 hash function implementation."]
        #[doc = ""]
        #[doc = " @{"]
        pub static av_md5_size: ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVMD5 {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVMD5 context."]
        pub fn av_md5_alloc() -> *mut root::AVMD5;
    }
    extern "C" {
        #[doc = " Initialize MD5 hashing."]
        #[doc = ""]
        #[doc = " @param ctx pointer to the function context (of size av_md5_size)"]
        pub fn av_md5_init(ctx: *mut root::AVMD5);
    }
    extern "C" {
        #[doc = " Update hash value."]
        #[doc = ""]
        #[doc = " @param ctx hash function context"]
        #[doc = " @param src input data to update hash with"]
        #[doc = " @param len input data length"]
        pub fn av_md5_update(ctx: *mut root::AVMD5, src: *const u8, len: root::size_t);
    }
    extern "C" {
        #[doc = " Finish hashing and output digest value."]
        #[doc = ""]
        #[doc = " @param ctx hash function context"]
        #[doc = " @param dst buffer where output digest value is stored"]
        pub fn av_md5_final(ctx: *mut root::AVMD5, dst: *mut u8);
    }
    extern "C" {
        #[doc = " Hash an array of data."]
        #[doc = ""]
        #[doc = " @param dst The output buffer to write the digest into"]
        #[doc = " @param src The data to hash"]
        #[doc = " @param len The length of the data, in bytes"]
        pub fn av_md5_sum(dst: *mut u8, src: *const u8, len: root::size_t);
    }
    extern "C" {
        #[doc = " @file"]
        #[doc = " @brief Public header for libavutil CAST5 algorithm"]
        #[doc = " @defgroup lavu_cast5 CAST5"]
        #[doc = " @ingroup lavu_crypto"]
        #[doc = " @{"]
        pub static av_cast5_size: ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVCAST5 {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVCAST5 context"]
        #[doc = " To free the struct: av_free(ptr)"]
        pub fn av_cast5_alloc() -> *mut root::AVCAST5;
    }
    extern "C" {
        #[doc = " Initialize an AVCAST5 context."]
        #[doc = ""]
        #[doc = " @param ctx an AVCAST5 context"]
        #[doc = " @param key a key of 5,6,...16 bytes used for encryption/decryption"]
        #[doc = " @param key_bits number of keybits: possible are 40,48,...,128"]
        #[doc = " @return 0 on success, less than 0 on failure"]
        pub fn av_cast5_init(
            ctx: *mut root::AVCAST5,
            key: *const u8,
            key_bits: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Encrypt or decrypt a buffer using a previously initialized context, ECB mode only"]
        #[doc = ""]
        #[doc = " @param ctx an AVCAST5 context"]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst"]
        #[doc = " @param count number of 8 byte blocks"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_cast5_crypt(
            ctx: *mut root::AVCAST5,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            decrypt: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Encrypt or decrypt a buffer using a previously initialized context"]
        #[doc = ""]
        #[doc = " @param ctx an AVCAST5 context"]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst"]
        #[doc = " @param count number of 8 byte blocks"]
        #[doc = " @param iv initialization vector for CBC mode, NULL for ECB mode"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_cast5_crypt2(
            ctx: *mut root::AVCAST5,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            iv: *mut u8,
            decrypt: ::std::os::raw::c_int,
        );
    }
    #[doc = " Video represents a sphere mapped on a flat surface using"]
    #[doc = " equirectangular projection."]
    pub const AVSphericalProjection_AV_SPHERICAL_EQUIRECTANGULAR: root::AVSphericalProjection = 0;
    #[doc = " Video frame is split into 6 faces of a cube, and arranged on a"]
    #[doc = " 3x2 layout. Faces are oriented upwards for the front, left, right,"]
    #[doc = " and back faces. The up face is oriented so the top of the face is"]
    #[doc = " forwards and the down face is oriented so the top of the face is"]
    #[doc = " to the back."]
    pub const AVSphericalProjection_AV_SPHERICAL_CUBEMAP: root::AVSphericalProjection = 1;
    #[doc = " Video represents a portion of a sphere mapped on a flat surface"]
    #[doc = " using equirectangular projection. The @ref bounding fields indicate"]
    #[doc = " the position of the current video in a larger surface."]
    pub const AVSphericalProjection_AV_SPHERICAL_EQUIRECTANGULAR_TILE: root::AVSphericalProjection =
        2;
    #[doc = " Projection of the video surface(s) on a sphere."]
    pub type AVSphericalProjection = ::std::os::raw::c_uint;
    #[doc = " This structure describes how to handle spherical videos, outlining"]
    #[doc = " information about projection, initial layout, and any other view modifier."]
    #[doc = ""]
    #[doc = " @note The struct must be allocated with av_spherical_alloc() and"]
    #[doc = "       its size is not a part of the public ABI."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVSphericalMapping {
        #[doc = " Projection type."]
        pub projection: root::AVSphericalProjection,
        #[doc = "< Rotation around the up vector [-180, 180]."]
        pub yaw: i32,
        #[doc = "< Rotation around the right vector [-90, 90]."]
        pub pitch: i32,
        #[doc = "< Rotation around the forward vector [-180, 180]."]
        pub roll: i32,
        #[doc = "< Distance from the left edge"]
        pub bound_left: u32,
        #[doc = "< Distance from the top edge"]
        pub bound_top: u32,
        #[doc = "< Distance from the right edge"]
        pub bound_right: u32,
        #[doc = "< Distance from the bottom edge"]
        pub bound_bottom: u32,
        #[doc = " Number of pixels to pad from the edge of each cube face."]
        #[doc = ""]
        #[doc = " @note This value is valid for only for the cubemap projection type"]
        #[doc = "       (@ref AV_SPHERICAL_CUBEMAP), and should be ignored in all other"]
        #[doc = "       cases."]
        pub padding: u32,
    }
    impl Default for AVSphericalMapping {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Allocate a AVSphericalVideo structure and initialize its fields to default"]
        #[doc = " values."]
        #[doc = ""]
        #[doc = " @return the newly allocated struct or NULL on failure"]
        pub fn av_spherical_alloc(size: *mut root::size_t) -> *mut root::AVSphericalMapping;
    }
    extern "C" {
        #[doc = " Convert the @ref bounding fields from an AVSphericalVideo"]
        #[doc = " from 0.32 fixed point to pixels."]
        #[doc = ""]
        #[doc = " @param map    The AVSphericalVideo map to read bound values from."]
        #[doc = " @param width  Width of the current frame or stream."]
        #[doc = " @param height Height of the current frame or stream."]
        #[doc = " @param left   Pixels from the left edge."]
        #[doc = " @param top    Pixels from the top edge."]
        #[doc = " @param right  Pixels from the right edge."]
        #[doc = " @param bottom Pixels from the bottom edge."]
        pub fn av_spherical_tile_bounds(
            map: *const root::AVSphericalMapping,
            width: root::size_t,
            height: root::size_t,
            left: *mut root::size_t,
            top: *mut root::size_t,
            right: *mut root::size_t,
            bottom: *mut root::size_t,
        );
    }
    extern "C" {
        #[doc = " Provide a human-readable name of a given AVSphericalProjection."]
        #[doc = ""]
        #[doc = " @param projection The input AVSphericalProjection."]
        #[doc = ""]
        #[doc = " @return The name of the AVSphericalProjection, or \"unknown\"."]
        pub fn av_spherical_projection_name(
            projection: root::AVSphericalProjection,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the AVSphericalProjection form a human-readable name."]
        #[doc = ""]
        #[doc = " @param name The input string."]
        #[doc = ""]
        #[doc = " @return The AVSphericalProjection value, or -1 if not found."]
        pub fn av_spherical_from_name(name: *const ::std::os::raw::c_char)
            -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVAudioFifo {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Free an AVAudioFifo."]
        #[doc = ""]
        #[doc = " @param af  AVAudioFifo to free"]
        pub fn av_audio_fifo_free(af: *mut root::AVAudioFifo);
    }
    extern "C" {
        #[doc = " Allocate an AVAudioFifo."]
        #[doc = ""]
        #[doc = " @param sample_fmt  sample format"]
        #[doc = " @param channels    number of channels"]
        #[doc = " @param nb_samples  initial allocation size, in samples"]
        #[doc = " @return            newly allocated AVAudioFifo, or NULL on error"]
        pub fn av_audio_fifo_alloc(
            sample_fmt: root::AVSampleFormat,
            channels: ::std::os::raw::c_int,
            nb_samples: ::std::os::raw::c_int,
        ) -> *mut root::AVAudioFifo;
    }
    extern "C" {
        #[doc = " Reallocate an AVAudioFifo."]
        #[doc = ""]
        #[doc = " @param af          AVAudioFifo to reallocate"]
        #[doc = " @param nb_samples  new allocation size, in samples"]
        #[doc = " @return            0 if OK, or negative AVERROR code on failure"]
        pub fn av_audio_fifo_realloc(
            af: *mut root::AVAudioFifo,
            nb_samples: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Write data to an AVAudioFifo."]
        #[doc = ""]
        #[doc = " The AVAudioFifo will be reallocated automatically if the available space"]
        #[doc = " is less than nb_samples."]
        #[doc = ""]
        #[doc = " @see enum AVSampleFormat"]
        #[doc = " The documentation for AVSampleFormat describes the data layout."]
        #[doc = ""]
        #[doc = " @param af          AVAudioFifo to write to"]
        #[doc = " @param data        audio data plane pointers"]
        #[doc = " @param nb_samples  number of samples to write"]
        #[doc = " @return            number of samples actually written, or negative AVERROR"]
        #[doc = "                    code on failure. If successful, the number of samples"]
        #[doc = "                    actually written will always be nb_samples."]
        pub fn av_audio_fifo_write(
            af: *mut root::AVAudioFifo,
            data: *mut *mut ::std::os::raw::c_void,
            nb_samples: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Peek data from an AVAudioFifo."]
        #[doc = ""]
        #[doc = " @see enum AVSampleFormat"]
        #[doc = " The documentation for AVSampleFormat describes the data layout."]
        #[doc = ""]
        #[doc = " @param af          AVAudioFifo to read from"]
        #[doc = " @param data        audio data plane pointers"]
        #[doc = " @param nb_samples  number of samples to peek"]
        #[doc = " @return            number of samples actually peek, or negative AVERROR code"]
        #[doc = "                    on failure. The number of samples actually peek will not"]
        #[doc = "                    be greater than nb_samples, and will only be less than"]
        #[doc = "                    nb_samples if av_audio_fifo_size is less than nb_samples."]
        pub fn av_audio_fifo_peek(
            af: *mut root::AVAudioFifo,
            data: *mut *mut ::std::os::raw::c_void,
            nb_samples: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Peek data from an AVAudioFifo."]
        #[doc = ""]
        #[doc = " @see enum AVSampleFormat"]
        #[doc = " The documentation for AVSampleFormat describes the data layout."]
        #[doc = ""]
        #[doc = " @param af          AVAudioFifo to read from"]
        #[doc = " @param data        audio data plane pointers"]
        #[doc = " @param nb_samples  number of samples to peek"]
        #[doc = " @param offset      offset from current read position"]
        #[doc = " @return            number of samples actually peek, or negative AVERROR code"]
        #[doc = "                    on failure. The number of samples actually peek will not"]
        #[doc = "                    be greater than nb_samples, and will only be less than"]
        #[doc = "                    nb_samples if av_audio_fifo_size is less than nb_samples."]
        pub fn av_audio_fifo_peek_at(
            af: *mut root::AVAudioFifo,
            data: *mut *mut ::std::os::raw::c_void,
            nb_samples: ::std::os::raw::c_int,
            offset: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Read data from an AVAudioFifo."]
        #[doc = ""]
        #[doc = " @see enum AVSampleFormat"]
        #[doc = " The documentation for AVSampleFormat describes the data layout."]
        #[doc = ""]
        #[doc = " @param af          AVAudioFifo to read from"]
        #[doc = " @param data        audio data plane pointers"]
        #[doc = " @param nb_samples  number of samples to read"]
        #[doc = " @return            number of samples actually read, or negative AVERROR code"]
        #[doc = "                    on failure. The number of samples actually read will not"]
        #[doc = "                    be greater than nb_samples, and will only be less than"]
        #[doc = "                    nb_samples if av_audio_fifo_size is less than nb_samples."]
        pub fn av_audio_fifo_read(
            af: *mut root::AVAudioFifo,
            data: *mut *mut ::std::os::raw::c_void,
            nb_samples: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Drain data from an AVAudioFifo."]
        #[doc = ""]
        #[doc = " Removes the data without reading it."]
        #[doc = ""]
        #[doc = " @param af          AVAudioFifo to drain"]
        #[doc = " @param nb_samples  number of samples to drain"]
        #[doc = " @return            0 if OK, or negative AVERROR code on failure"]
        pub fn av_audio_fifo_drain(
            af: *mut root::AVAudioFifo,
            nb_samples: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Reset the AVAudioFifo buffer."]
        #[doc = ""]
        #[doc = " This empties all data in the buffer."]
        #[doc = ""]
        #[doc = " @param af  AVAudioFifo to reset"]
        pub fn av_audio_fifo_reset(af: *mut root::AVAudioFifo);
    }
    extern "C" {
        #[doc = " Get the current number of samples in the AVAudioFifo available for reading."]
        #[doc = ""]
        #[doc = " @param af  the AVAudioFifo to query"]
        #[doc = " @return    number of samples available for reading"]
        pub fn av_audio_fifo_size(af: *mut root::AVAudioFifo) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the current number of samples in the AVAudioFifo available for writing."]
        #[doc = ""]
        #[doc = " @param af  the AVAudioFifo to query"]
        #[doc = " @return    number of samples available for writing"]
        pub fn av_audio_fifo_space(af: *mut root::AVAudioFifo) -> ::std::os::raw::c_int;
    }
    #[doc = " @addtogroup lavu_tree AVTree"]
    #[doc = " @ingroup lavu_data"]
    #[doc = ""]
    #[doc = " Low-complexity tree container"]
    #[doc = ""]
    #[doc = " Insertion, removal, finding equal, largest which is smaller than and"]
    #[doc = " smallest which is larger than, all have O(log n) worst-case complexity."]
    #[doc = " @{"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVTreeNode {
        _unused: [u8; 0],
    }
    extern "C" {
        pub static av_tree_node_size: ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Allocate an AVTreeNode."]
        pub fn av_tree_node_alloc() -> *mut root::AVTreeNode;
    }
    extern "C" {
        #[doc = " Find an element."]
        #[doc = " @param root a pointer to the root node of the tree"]
        #[doc = " @param next If next is not NULL, then next[0] will contain the previous"]
        #[doc = "             element and next[1] the next element. If either does not exist,"]
        #[doc = "             then the corresponding entry in next is unchanged."]
        #[doc = " @param cmp compare function used to compare elements in the tree,"]
        #[doc = "            API identical to that of Standard C's qsort"]
        #[doc = "            It is guaranteed that the first and only the first argument to cmp()"]
        #[doc = "            will be the key parameter to av_tree_find(), thus it could if the"]
        #[doc = "            user wants, be a different type (like an opaque context)."]
        #[doc = " @return An element with cmp(key, elem) == 0 or NULL if no such element"]
        #[doc = "         exists in the tree."]
        pub fn av_tree_find(
            root: *const root::AVTreeNode,
            key: *mut ::std::os::raw::c_void,
            cmp: ::std::option::Option<
                unsafe extern "C" fn(
                    key: *const ::std::os::raw::c_void,
                    b: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            next: *mut *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Insert or remove an element."]
        #[doc = ""]
        #[doc = " If *next is NULL, then the supplied element will be removed if it exists."]
        #[doc = " If *next is non-NULL, then the supplied element will be inserted, unless"]
        #[doc = " it already exists in the tree."]
        #[doc = ""]
        #[doc = " @param rootp A pointer to a pointer to the root node of the tree; note that"]
        #[doc = "              the root node can change during insertions, this is required"]
        #[doc = "              to keep the tree balanced."]
        #[doc = " @param key  pointer to the element key to insert in the tree"]
        #[doc = " @param next Used to allocate and free AVTreeNodes. For insertion the user"]
        #[doc = "             must set it to an allocated and zeroed object of at least"]
        #[doc = "             av_tree_node_size bytes size. av_tree_insert() will set it to"]
        #[doc = "             NULL if it has been consumed."]
        #[doc = "             For deleting elements *next is set to NULL by the user and"]
        #[doc = "             av_tree_insert() will set it to the AVTreeNode which was"]
        #[doc = "             used for the removed element."]
        #[doc = "             This allows the use of flat arrays, which have"]
        #[doc = "             lower overhead compared to many malloced elements."]
        #[doc = "             You might want to define a function like:"]
        #[doc = "             @code"]
        #[doc = "             void *tree_insert(struct AVTreeNode **rootp, void *key,"]
        #[doc = "                               int (*cmp)(void *key, const void *b),"]
        #[doc = "                               AVTreeNode **next)"]
        #[doc = "             {"]
        #[doc = "                 if (!*next)"]
        #[doc = "                     *next = av_mallocz(av_tree_node_size);"]
        #[doc = "                 return av_tree_insert(rootp, key, cmp, next);"]
        #[doc = "             }"]
        #[doc = "             void *tree_remove(struct AVTreeNode **rootp, void *key,"]
        #[doc = "                               int (*cmp)(void *key, const void *b, AVTreeNode **next))"]
        #[doc = "             {"]
        #[doc = "                 av_freep(next);"]
        #[doc = "                 return av_tree_insert(rootp, key, cmp, next);"]
        #[doc = "             }"]
        #[doc = "             @endcode"]
        #[doc = " @param cmp compare function used to compare elements in the tree, API identical"]
        #[doc = "            to that of Standard C's qsort"]
        #[doc = " @return If no insertion happened, the found element; if an insertion or"]
        #[doc = "         removal happened, then either key or NULL will be returned."]
        #[doc = "         Which one it is depends on the tree state and the implementation. You"]
        #[doc = "         should make no assumptions that it's one or the other in the code."]
        pub fn av_tree_insert(
            rootp: *mut *mut root::AVTreeNode,
            key: *mut ::std::os::raw::c_void,
            cmp: ::std::option::Option<
                unsafe extern "C" fn(
                    key: *const ::std::os::raw::c_void,
                    b: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            next: *mut *mut root::AVTreeNode,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn av_tree_destroy(t: *mut root::AVTreeNode);
    }
    extern "C" {
        #[doc = " Apply enu(opaque, &elem) to all the elements in the tree in a given range."]
        #[doc = ""]
        #[doc = " @param cmp a comparison function that returns < 0 for an element below the"]
        #[doc = "            range, > 0 for an element above the range and == 0 for an"]
        #[doc = "            element inside the range"]
        #[doc = ""]
        #[doc = " @note The cmp function should use the same ordering used to construct the"]
        #[doc = "       tree."]
        pub fn av_tree_enumerate(
            t: *mut root::AVTreeNode,
            opaque: *mut ::std::os::raw::c_void,
            cmp: ::std::option::Option<
                unsafe extern "C" fn(
                    opaque: *mut ::std::os::raw::c_void,
                    elem: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            enu: ::std::option::Option<
                unsafe extern "C" fn(
                    opaque: *mut ::std::os::raw::c_void,
                    elem: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVThreadMessageQueue {
        _unused: [u8; 0],
    }
    #[doc = " Perform non-blocking operation."]
    #[doc = " If this flag is set, send and recv operations are non-blocking and"]
    #[doc = " return AVERROR(EAGAIN) immediately if they can not proceed."]
    pub const AVThreadMessageFlags_AV_THREAD_MESSAGE_NONBLOCK: root::AVThreadMessageFlags = 1;
    pub type AVThreadMessageFlags = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Allocate a new message queue."]
        #[doc = ""]
        #[doc = " @param mq      pointer to the message queue"]
        #[doc = " @param nelem   maximum number of elements in the queue"]
        #[doc = " @param elsize  size of each element in the queue"]
        #[doc = " @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if"]
        #[doc = "          lavu was built without thread support"]
        pub fn av_thread_message_queue_alloc(
            mq: *mut *mut root::AVThreadMessageQueue,
            nelem: ::std::os::raw::c_uint,
            elsize: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Free a message queue."]
        #[doc = ""]
        #[doc = " The message queue must no longer be in use by another thread."]
        pub fn av_thread_message_queue_free(mq: *mut *mut root::AVThreadMessageQueue);
    }
    extern "C" {
        #[doc = " Send a message on the queue."]
        pub fn av_thread_message_queue_send(
            mq: *mut root::AVThreadMessageQueue,
            msg: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Receive a message from the queue."]
        pub fn av_thread_message_queue_recv(
            mq: *mut root::AVThreadMessageQueue,
            msg: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Set the sending error code."]
        #[doc = ""]
        #[doc = " If the error code is set to non-zero, av_thread_message_queue_send() will"]
        #[doc = " return it immediately. Conventional values, such as AVERROR_EOF or"]
        #[doc = " AVERROR(EAGAIN), can be used to cause the sending thread to stop or"]
        #[doc = " suspend its operation."]
        pub fn av_thread_message_queue_set_err_send(
            mq: *mut root::AVThreadMessageQueue,
            err: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Set the receiving error code."]
        #[doc = ""]
        #[doc = " If the error code is set to non-zero, av_thread_message_queue_recv() will"]
        #[doc = " return it immediately when there are no longer available messages."]
        #[doc = " Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used"]
        #[doc = " to cause the receiving thread to stop or suspend its operation."]
        pub fn av_thread_message_queue_set_err_recv(
            mq: *mut root::AVThreadMessageQueue,
            err: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Set the optional free message callback function which will be called if an"]
        #[doc = " operation is removing messages from the queue."]
        pub fn av_thread_message_queue_set_free_func(
            mq: *mut root::AVThreadMessageQueue,
            free_func: ::std::option::Option<
                unsafe extern "C" fn(msg: *mut ::std::os::raw::c_void),
            >,
        );
    }
    extern "C" {
        #[doc = " Return the current number of messages in the queue."]
        #[doc = ""]
        #[doc = " @return the current number of messages or AVERROR(ENOSYS) if lavu was built"]
        #[doc = "         without thread support"]
        pub fn av_thread_message_queue_nb_elems(
            mq: *mut root::AVThreadMessageQueue,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Flush the message queue"]
        #[doc = ""]
        #[doc = " This function is mostly equivalent to reading and free-ing every message"]
        #[doc = " except that it will be done in a single operation (no lock/unlock between"]
        #[doc = " reads)."]
        pub fn av_thread_message_flush(mq: *mut root::AVThreadMessageQueue);
    }
    #[doc = " @defgroup lavu_adler32 Adler-32"]
    #[doc = " @ingroup lavu_hash"]
    #[doc = " Adler-32 hash function implementation."]
    #[doc = ""]
    #[doc = " @{"]
    pub type AVAdler = u32;
    extern "C" {
        #[doc = " Calculate the Adler32 checksum of a buffer."]
        #[doc = ""]
        #[doc = " Passing the return value to a subsequent av_adler32_update() call"]
        #[doc = " allows the checksum of multiple buffers to be calculated as though"]
        #[doc = " they were concatenated."]
        #[doc = ""]
        #[doc = " @param adler initial checksum value"]
        #[doc = " @param buf   pointer to input buffer"]
        #[doc = " @param len   size of input buffer"]
        #[doc = " @return      updated checksum"]
        pub fn av_adler32_update(
            adler: root::AVAdler,
            buf: *const u8,
            len: root::size_t,
        ) -> root::AVAdler;
    }
    #[doc = "< timecode is drop frame"]
    pub const AVTimecodeFlag_AV_TIMECODE_FLAG_DROPFRAME: root::AVTimecodeFlag = 1;
    #[doc = "< timecode wraps after 24 hours"]
    pub const AVTimecodeFlag_AV_TIMECODE_FLAG_24HOURSMAX: root::AVTimecodeFlag = 2;
    #[doc = "< negative time values are allowed"]
    pub const AVTimecodeFlag_AV_TIMECODE_FLAG_ALLOWNEGATIVE: root::AVTimecodeFlag = 4;
    pub type AVTimecodeFlag = ::std::os::raw::c_uint;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVTimecode {
        #[doc = "< timecode frame start (first base frame number)"]
        pub start: ::std::os::raw::c_int,
        #[doc = "< flags such as drop frame, +24 hours support, ..."]
        pub flags: u32,
        #[doc = "< frame rate in rational form"]
        pub rate: root::AVRational,
        #[doc = "< frame per second; must be consistent with the rate field"]
        pub fps: ::std::os::raw::c_uint,
    }
    extern "C" {
        #[doc = " Adjust frame number for NTSC drop frame time code."]
        #[doc = ""]
        #[doc = " @param framenum frame number to adjust"]
        #[doc = " @param fps      frame per second, multiples of 30"]
        #[doc = " @return         adjusted frame number"]
        #[doc = " @warning        adjustment is only valid for multiples of NTSC 29.97"]
        pub fn av_timecode_adjust_ntsc_framenum2(
            framenum: ::std::os::raw::c_int,
            fps: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Convert frame number to SMPTE 12M binary representation."]
        #[doc = ""]
        #[doc = " @param tc       timecode data correctly initialized"]
        #[doc = " @param framenum frame number"]
        #[doc = " @return         the SMPTE binary representation"]
        #[doc = ""]
        #[doc = " See SMPTE ST 314M-2005 Sec 4.4.2.2.1 \"Time code pack (TC)\""]
        #[doc = " the format description as follows:"]
        #[doc = " bits 0-5:   hours, in BCD(6bits)"]
        #[doc = " bits 6:     BGF1"]
        #[doc = " bits 7:     BGF2 (NTSC) or FIELD (PAL)"]
        #[doc = " bits 8-14:  minutes, in BCD(7bits)"]
        #[doc = " bits 15:    BGF0 (NTSC) or BGF2 (PAL)"]
        #[doc = " bits 16-22: seconds, in BCD(7bits)"]
        #[doc = " bits 23:    FIELD (NTSC) or BGF0 (PAL)"]
        #[doc = " bits 24-29: frames, in BCD(6bits)"]
        #[doc = " bits 30:    drop  frame flag (0: non drop,    1: drop)"]
        #[doc = " bits 31:    color frame flag (0: unsync mode, 1: sync mode)"]
        #[doc = " @note BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens."]
        #[doc = " @note Frame number adjustment is automatically done in case of drop timecode,"]
        #[doc = "       you do NOT have to call av_timecode_adjust_ntsc_framenum2()."]
        #[doc = " @note The frame number is relative to tc->start."]
        #[doc = " @note Color frame (CF) and binary group flags (BGF) bits are set to zero."]
        pub fn av_timecode_get_smpte_from_framenum(
            tc: *const root::AVTimecode,
            framenum: ::std::os::raw::c_int,
        ) -> u32;
    }
    extern "C" {
        #[doc = " Convert sei info to SMPTE 12M binary representation."]
        #[doc = ""]
        #[doc = " @param rate     frame rate in rational form"]
        #[doc = " @param drop     drop flag"]
        #[doc = " @param hh       hour"]
        #[doc = " @param mm       minute"]
        #[doc = " @param ss       second"]
        #[doc = " @param ff       frame number"]
        #[doc = " @return         the SMPTE binary representation"]
        pub fn av_timecode_get_smpte(
            rate: root::AVRational,
            drop: ::std::os::raw::c_int,
            hh: ::std::os::raw::c_int,
            mm: ::std::os::raw::c_int,
            ss: ::std::os::raw::c_int,
            ff: ::std::os::raw::c_int,
        ) -> u32;
    }
    extern "C" {
        #[doc = " Load timecode string in buf."]
        #[doc = ""]
        #[doc = " @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long"]
        #[doc = " @param tc       timecode data correctly initialized"]
        #[doc = " @param framenum frame number"]
        #[doc = " @return         the buf parameter"]
        #[doc = ""]
        #[doc = " @note Timecode representation can be a negative timecode and have more than"]
        #[doc = "       24 hours, but will only be honored if the flags are correctly set."]
        #[doc = " @note The frame number is relative to tc->start."]
        pub fn av_timecode_make_string(
            tc: *const root::AVTimecode,
            buf: *mut ::std::os::raw::c_char,
            framenum: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the timecode string from the SMPTE timecode format."]
        #[doc = ""]
        #[doc = " In contrast to av_timecode_make_smpte_tc_string this function supports 50/60"]
        #[doc = " fps timecodes by using the field bit."]
        #[doc = ""]
        #[doc = " @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long"]
        #[doc = " @param rate       frame rate of the timecode"]
        #[doc = " @param tcsmpte    the 32-bit SMPTE timecode"]
        #[doc = " @param prevent_df prevent the use of a drop flag when it is known the DF bit"]
        #[doc = "                   is arbitrary"]
        #[doc = " @param skip_field prevent the use of a field flag when it is known the field"]
        #[doc = "                   bit is arbitrary (e.g. because it is used as PC flag)"]
        #[doc = " @return           the buf parameter"]
        pub fn av_timecode_make_smpte_tc_string2(
            buf: *mut ::std::os::raw::c_char,
            rate: root::AVRational,
            tcsmpte: u32,
            prevent_df: ::std::os::raw::c_int,
            skip_field: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the timecode string from the SMPTE timecode format."]
        #[doc = ""]
        #[doc = " @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long"]
        #[doc = " @param tcsmpte    the 32-bit SMPTE timecode"]
        #[doc = " @param prevent_df prevent the use of a drop flag when it is known the DF bit"]
        #[doc = "                   is arbitrary"]
        #[doc = " @return           the buf parameter"]
        pub fn av_timecode_make_smpte_tc_string(
            buf: *mut ::std::os::raw::c_char,
            tcsmpte: u32,
            prevent_df: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the timecode string from the 25-bit timecode format (MPEG GOP format)."]
        #[doc = ""]
        #[doc = " @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long"]
        #[doc = " @param tc25bit the 25-bits timecode"]
        #[doc = " @return        the buf parameter"]
        pub fn av_timecode_make_mpeg_tc_string(
            buf: *mut ::std::os::raw::c_char,
            tc25bit: u32,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Init a timecode struct with the passed parameters."]
        #[doc = ""]
        #[doc = " @param log_ctx     a pointer to an arbitrary struct of which the first field"]
        #[doc = "                    is a pointer to an AVClass struct (used for av_log)"]
        #[doc = " @param tc          pointer to an allocated AVTimecode"]
        #[doc = " @param rate        frame rate in rational form"]
        #[doc = " @param flags       miscellaneous flags such as drop frame, +24 hours, ..."]
        #[doc = "                    (see AVTimecodeFlag)"]
        #[doc = " @param frame_start the first frame number"]
        #[doc = " @return            0 on success, AVERROR otherwise"]
        pub fn av_timecode_init(
            tc: *mut root::AVTimecode,
            rate: root::AVRational,
            flags: ::std::os::raw::c_int,
            frame_start: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Init a timecode struct from the passed timecode components."]
        #[doc = ""]
        #[doc = " @param log_ctx     a pointer to an arbitrary struct of which the first field"]
        #[doc = "                    is a pointer to an AVClass struct (used for av_log)"]
        #[doc = " @param tc          pointer to an allocated AVTimecode"]
        #[doc = " @param rate        frame rate in rational form"]
        #[doc = " @param flags       miscellaneous flags such as drop frame, +24 hours, ..."]
        #[doc = "                    (see AVTimecodeFlag)"]
        #[doc = " @param hh          hours"]
        #[doc = " @param mm          minutes"]
        #[doc = " @param ss          seconds"]
        #[doc = " @param ff          frames"]
        #[doc = " @return            0 on success, AVERROR otherwise"]
        pub fn av_timecode_init_from_components(
            tc: *mut root::AVTimecode,
            rate: root::AVRational,
            flags: ::std::os::raw::c_int,
            hh: ::std::os::raw::c_int,
            mm: ::std::os::raw::c_int,
            ss: ::std::os::raw::c_int,
            ff: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Parse timecode representation (hh:mm:ss[:;.]ff)."]
        #[doc = ""]
        #[doc = " @param log_ctx a pointer to an arbitrary struct of which the first field is a"]
        #[doc = "                pointer to an AVClass struct (used for av_log)."]
        #[doc = " @param tc      pointer to an allocated AVTimecode"]
        #[doc = " @param rate    frame rate in rational form"]
        #[doc = " @param str     timecode string which will determine the frame start"]
        #[doc = " @return        0 on success, AVERROR otherwise"]
        pub fn av_timecode_init_from_string(
            tc: *mut root::AVTimecode,
            rate: root::AVRational,
            str_: *const ::std::os::raw::c_char,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Check if the timecode feature is available for the given frame rate"]
        #[doc = ""]
        #[doc = " @return 0 if supported, <0 otherwise"]
        pub fn av_timecode_check_frame_rate(rate: root::AVRational) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVDOVIDecoderConfigurationRecord {
        pub dv_version_major: u8,
        pub dv_version_minor: u8,
        pub dv_profile: u8,
        pub dv_level: u8,
        pub rpu_present_flag: u8,
        pub el_present_flag: u8,
        pub bl_present_flag: u8,
        pub dv_bl_signal_compatibility_id: u8,
    }
    extern "C" {
        #[doc = " Allocate a AVDOVIDecoderConfigurationRecord structure and initialize its"]
        #[doc = " fields to default values."]
        #[doc = ""]
        #[doc = " @return the newly allocated struct or NULL on failure"]
        pub fn av_dovi_alloc(
            size: *mut root::size_t,
        ) -> *mut root::AVDOVIDecoderConfigurationRecord;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVTXContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVComplexFloat {
        pub re: f32,
        pub im: f32,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVComplexDouble {
        pub re: f64,
        pub im: f64,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVComplexInt32 {
        pub re: i32,
        pub im: i32,
    }
    #[doc = " Standard complex to complex FFT with sample data type AVComplexFloat."]
    #[doc = " Output is not 1/len normalized. Scaling currently unsupported."]
    #[doc = " The stride parameter is ignored."]
    pub const AVTXType_AV_TX_FLOAT_FFT: root::AVTXType = 0;
    #[doc = " Standard MDCT with sample data type of float and a scale type of"]
    #[doc = " float. Length is the frame size, not the window size (which is 2x frame)"]
    #[doc = " For forward transforms, the stride specifies the spacing between each"]
    #[doc = " sample in the output array in bytes. The input must be a flat array."]
    #[doc = ""]
    #[doc = " For inverse transforms, the stride specifies the spacing between each"]
    #[doc = " sample in the input array in bytes. The output will be a flat array."]
    #[doc = " Stride must be a non-zero multiple of sizeof(float)."]
    #[doc = ""]
    #[doc = " NOTE: the inverse transform is half-length, meaning the output will not"]
    #[doc = " contain redundant data. This is what most codecs work with. To do a full"]
    #[doc = " inverse transform, set the AV_TX_FULL_IMDCT flag on init."]
    pub const AVTXType_AV_TX_FLOAT_MDCT: root::AVTXType = 1;
    #[doc = " Same as AV_TX_FLOAT_FFT with a data type of AVComplexDouble."]
    pub const AVTXType_AV_TX_DOUBLE_FFT: root::AVTXType = 2;
    #[doc = " Same as AV_TX_FLOAT_MDCT with data and scale type of double."]
    #[doc = " Stride must be a non-zero multiple of sizeof(double)."]
    pub const AVTXType_AV_TX_DOUBLE_MDCT: root::AVTXType = 3;
    #[doc = " Same as AV_TX_FLOAT_FFT with a data type of AVComplexInt32."]
    pub const AVTXType_AV_TX_INT32_FFT: root::AVTXType = 4;
    #[doc = " Same as AV_TX_FLOAT_MDCT with data type of int32_t and scale type of float."]
    #[doc = " Only scale values less than or equal to 1.0 are supported."]
    #[doc = " Stride must be a non-zero multiple of sizeof(int32_t)."]
    pub const AVTXType_AV_TX_INT32_MDCT: root::AVTXType = 5;
    pub type AVTXType = ::std::os::raw::c_uint;
    #[doc = " Function pointer to a function to perform the transform."]
    #[doc = ""]
    #[doc = " @note Using a different context than the one allocated during av_tx_init()"]
    #[doc = " is not allowed."]
    #[doc = ""]
    #[doc = " @param s the transform context"]
    #[doc = " @param out the output array"]
    #[doc = " @param in the input array"]
    #[doc = " @param stride the input or output stride in bytes"]
    #[doc = ""]
    #[doc = " The out and in arrays must be aligned to the maximum required by the CPU"]
    #[doc = " architecture unless the AV_TX_UNALIGNED flag was set in av_tx_init()."]
    #[doc = " The stride must follow the constraints the transform type has specified."]
    pub type av_tx_fn = ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut root::AVTXContext,
            out: *mut ::std::os::raw::c_void,
            in_: *mut ::std::os::raw::c_void,
            stride: isize,
        ),
    >;
    #[doc = " Performs an in-place transformation on the input. The output argument"]
    #[doc = " of av_tn_fn() MUST match the input. May be unsupported or slower for some"]
    #[doc = " transform types."]
    pub const AVTXFlags_AV_TX_INPLACE: root::AVTXFlags = 1;
    #[doc = " Relaxes alignment requirement for the in and out arrays of av_tx_fn()."]
    #[doc = " May be slower with certain transform types."]
    pub const AVTXFlags_AV_TX_UNALIGNED: root::AVTXFlags = 2;
    #[doc = " Performs a full inverse MDCT rather than leaving out samples that can be"]
    #[doc = " derived through symmetry. Requires an output array of 'len' floats,"]
    #[doc = " rather than the usual 'len/2' floats."]
    #[doc = " Ignored for all transforms but inverse MDCTs."]
    pub const AVTXFlags_AV_TX_FULL_IMDCT: root::AVTXFlags = 4;
    #[doc = " Flags for av_tx_init()"]
    pub type AVTXFlags = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Initialize a transform context with the given configuration"]
        #[doc = " (i)MDCTs with an odd length are currently not supported."]
        #[doc = ""]
        #[doc = " @param ctx the context to allocate, will be NULL on error"]
        #[doc = " @param tx pointer to the transform function pointer to set"]
        #[doc = " @param type type the type of transform"]
        #[doc = " @param inv whether to do an inverse or a forward transform"]
        #[doc = " @param len the size of the transform in samples"]
        #[doc = " @param scale pointer to the value to scale the output if supported by type"]
        #[doc = " @param flags a bitmask of AVTXFlags or 0"]
        #[doc = ""]
        #[doc = " @return 0 on success, negative error code on failure"]
        pub fn av_tx_init(
            ctx: *mut *mut root::AVTXContext,
            tx: *mut root::av_tx_fn,
            type_: root::AVTXType,
            inv: ::std::os::raw::c_int,
            len: ::std::os::raw::c_int,
            scale: *const ::std::os::raw::c_void,
            flags: u64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Frees a context and sets ctx to NULL, does nothing when ctx == NULL"]
        pub fn av_tx_uninit(ctx: *mut *mut root::AVTXContext);
    }
    extern "C" {
        #[doc = " @defgroup lavu_sha512 SHA-512"]
        #[doc = " @ingroup lavu_hash"]
        #[doc = " SHA-512 (Secure Hash Algorithm) hash function implementations."]
        #[doc = ""]
        #[doc = " This module supports the following SHA-2 hash functions:"]
        #[doc = ""]
        #[doc = " - SHA-512/224: 224 bits"]
        #[doc = " - SHA-512/256: 256 bits"]
        #[doc = " - SHA-384: 384 bits"]
        #[doc = " - SHA-512: 512 bits"]
        #[doc = ""]
        #[doc = " @see For SHA-1, SHA-256, and variants thereof, see @ref lavu_sha."]
        #[doc = ""]
        #[doc = " @{"]
        pub static av_sha512_size: ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVSHA512 {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVSHA512 context."]
        pub fn av_sha512_alloc() -> *mut root::AVSHA512;
    }
    extern "C" {
        #[doc = " Initialize SHA-2 512 hashing."]
        #[doc = ""]
        #[doc = " @param context pointer to the function context (of size av_sha512_size)"]
        #[doc = " @param bits    number of bits in digest (224, 256, 384 or 512 bits)"]
        #[doc = " @return        zero if initialization succeeded, -1 otherwise"]
        pub fn av_sha512_init(
            context: *mut root::AVSHA512,
            bits: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Update hash value."]
        #[doc = ""]
        #[doc = " @param context hash function context"]
        #[doc = " @param data    input data to update hash with"]
        #[doc = " @param len     input data length"]
        pub fn av_sha512_update(context: *mut root::AVSHA512, data: *const u8, len: root::size_t);
    }
    extern "C" {
        #[doc = " Finish hashing and output digest value."]
        #[doc = ""]
        #[doc = " @param context hash function context"]
        #[doc = " @param digest  buffer where output digest value is stored"]
        pub fn av_sha512_final(context: *mut root::AVSHA512, digest: *mut u8);
    }
    extern "C" {
        #[doc = " Extract the rotation component of the transformation matrix."]
        #[doc = ""]
        #[doc = " @param matrix the transformation matrix"]
        #[doc = " @return the angle (in degrees) by which the transformation rotates the frame"]
        #[doc = "         counterclockwise. The angle will be in range [-180.0, 180.0],"]
        #[doc = "         or NaN if the matrix is singular."]
        #[doc = ""]
        #[doc = " @note floating point numbers are inherently inexact, so callers are"]
        #[doc = "       recommended to round the return value to nearest integer before use."]
        pub fn av_display_rotation_get(matrix: *const i32) -> f64;
    }
    extern "C" {
        #[doc = " Initialize a transformation matrix describing a pure counterclockwise"]
        #[doc = " rotation by the specified angle (in degrees)."]
        #[doc = ""]
        #[doc = " @param matrix an allocated transformation matrix (will be fully overwritten"]
        #[doc = "               by this function)"]
        #[doc = " @param angle rotation angle in degrees."]
        pub fn av_display_rotation_set(matrix: *mut i32, angle: f64);
    }
    extern "C" {
        #[doc = " Flip the input matrix horizontally and/or vertically."]
        #[doc = ""]
        #[doc = " @param matrix an allocated transformation matrix"]
        #[doc = " @param hflip whether the matrix should be flipped horizontally"]
        #[doc = " @param vflip whether the matrix should be flipped vertically"]
        pub fn av_display_matrix_flip(
            matrix: *mut i32,
            hflip: ::std::os::raw::c_int,
            vflip: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " @file"]
        #[doc = " @brief Public header for libavutil CAMELLIA algorithm"]
        #[doc = " @defgroup lavu_camellia CAMELLIA"]
        #[doc = " @ingroup lavu_crypto"]
        #[doc = " @{"]
        pub static av_camellia_size: ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVCAMELLIA {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVCAMELLIA context"]
        #[doc = " To free the struct: av_free(ptr)"]
        pub fn av_camellia_alloc() -> *mut root::AVCAMELLIA;
    }
    extern "C" {
        #[doc = " Initialize an AVCAMELLIA context."]
        #[doc = ""]
        #[doc = " @param ctx an AVCAMELLIA context"]
        #[doc = " @param key a key of 16, 24, 32 bytes used for encryption/decryption"]
        #[doc = " @param key_bits number of keybits: possible are 128, 192, 256"]
        pub fn av_camellia_init(
            ctx: *mut root::AVCAMELLIA,
            key: *const u8,
            key_bits: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Encrypt or decrypt a buffer using a previously initialized context"]
        #[doc = ""]
        #[doc = " @param ctx an AVCAMELLIA context"]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst"]
        #[doc = " @param count number of 16 byte blocks"]
        #[doc = " @paran iv initialization vector for CBC mode, NULL for ECB mode"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_camellia_crypt(
            ctx: *mut root::AVCAMELLIA,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            iv: *mut u8,
            decrypt: ::std::os::raw::c_int,
        );
    }
    #[doc = " Sum of abs(src1[x] - src2[x])"]
    pub type av_pixelutils_sad_fn = ::std::option::Option<
        unsafe extern "C" fn(
            src1: *const u8,
            stride1: isize,
            src2: *const u8,
            stride2: isize,
        ) -> ::std::os::raw::c_int,
    >;
    extern "C" {
        #[doc = " Get a potentially optimized pointer to a Sum-of-absolute-differences"]
        #[doc = " function (see the av_pixelutils_sad_fn prototype)."]
        #[doc = ""]
        #[doc = " @param w_bits  1<<w_bits is the requested width of the block size"]
        #[doc = " @param h_bits  1<<h_bits is the requested height of the block size"]
        #[doc = " @param aligned If set to 2, the returned sad function will assume src1 and"]
        #[doc = "                src2 addresses are aligned on the block size."]
        #[doc = "                If set to 1, the returned sad function will assume src1 is"]
        #[doc = "                aligned on the block size."]
        #[doc = "                If set to 0, the returned sad function assume no particular"]
        #[doc = "                alignment."]
        #[doc = " @param log_ctx context used for logging, can be NULL"]
        #[doc = ""]
        #[doc = " @return a pointer to the SAD function or NULL in case of error (because of"]
        #[doc = "         invalid parameters)"]
        pub fn av_pixelutils_get_sad_fn(
            w_bits: ::std::os::raw::c_int,
            h_bits: ::std::os::raw::c_int,
            aligned: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> root::av_pixelutils_sad_fn;
    }
    #[doc = " The maximum number of layers/planes in a DRM frame."]
    pub const AV_DRM_MAX_PLANES: ::std::os::raw::c_uint = 4;
    #[doc = " @file"]
    #[doc = " API-specific header for AV_HWDEVICE_TYPE_DRM."]
    #[doc = ""]
    #[doc = " Internal frame allocation is not currently supported - all frames"]
    #[doc = " must be allocated by the user.  Thus AVHWFramesContext is always"]
    #[doc = " NULL, though this may change if support for frame allocation is"]
    #[doc = " added in future."]
    pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
    #[doc = " DRM object descriptor."]
    #[doc = ""]
    #[doc = " Describes a single DRM object, addressing it as a PRIME file"]
    #[doc = " descriptor."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVDRMObjectDescriptor {
        #[doc = " DRM PRIME fd for the object."]
        pub fd: ::std::os::raw::c_int,
        #[doc = " Total size of the object."]
        #[doc = ""]
        #[doc = " (This includes any parts not which do not contain image data.)"]
        pub size: root::size_t,
        #[doc = " Format modifier applied to the object (DRM_FORMAT_MOD_*)."]
        #[doc = ""]
        #[doc = " If the format modifier is unknown then this should be set to"]
        #[doc = " DRM_FORMAT_MOD_INVALID."]
        pub format_modifier: u64,
    }
    #[doc = " DRM plane descriptor."]
    #[doc = ""]
    #[doc = " Describes a single plane of a layer, which is contained within"]
    #[doc = " a single object."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVDRMPlaneDescriptor {
        #[doc = " Index of the object containing this plane in the objects"]
        #[doc = " array of the enclosing frame descriptor."]
        pub object_index: ::std::os::raw::c_int,
        #[doc = " Offset within that object of this plane."]
        pub offset: isize,
        #[doc = " Pitch (linesize) of this plane."]
        pub pitch: isize,
    }
    #[doc = " DRM layer descriptor."]
    #[doc = ""]
    #[doc = " Describes a single layer within a frame.  This has the structure"]
    #[doc = " defined by its format, and will contain one or more planes."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVDRMLayerDescriptor {
        #[doc = " Format of the layer (DRM_FORMAT_*)."]
        pub format: u32,
        #[doc = " Number of planes in the layer."]
        #[doc = ""]
        #[doc = " This must match the number of planes required by format."]
        pub nb_planes: ::std::os::raw::c_int,
        #[doc = " Array of planes in this layer."]
        pub planes: [root::AVDRMPlaneDescriptor; 4usize],
    }
    #[doc = " DRM frame descriptor."]
    #[doc = ""]
    #[doc = " This is used as the data pointer for AV_PIX_FMT_DRM_PRIME frames."]
    #[doc = " It is also used by user-allocated frame pools - allocating in"]
    #[doc = " AVHWFramesContext.pool must return AVBufferRefs which contain"]
    #[doc = " an object of this type."]
    #[doc = ""]
    #[doc = " The fields of this structure should be set such it can be"]
    #[doc = " imported directly by EGL using the EGL_EXT_image_dma_buf_import"]
    #[doc = " and EGL_EXT_image_dma_buf_import_modifiers extensions."]
    #[doc = " (Note that the exact layout of a particular format may vary between"]
    #[doc = " platforms - we only specify that the same platform should be able"]
    #[doc = " to import it.)"]
    #[doc = ""]
    #[doc = " The total number of planes must not exceed AV_DRM_MAX_PLANES, and"]
    #[doc = " the order of the planes by increasing layer index followed by"]
    #[doc = " increasing plane index must be the same as the order which would"]
    #[doc = " be used for the data pointers in the equivalent software format."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVDRMFrameDescriptor {
        #[doc = " Number of DRM objects making up this frame."]
        pub nb_objects: ::std::os::raw::c_int,
        #[doc = " Array of objects making up the frame."]
        pub objects: [root::AVDRMObjectDescriptor; 4usize],
        #[doc = " Number of layers in the frame."]
        pub nb_layers: ::std::os::raw::c_int,
        #[doc = " Array of layers in the frame."]
        pub layers: [root::AVDRMLayerDescriptor; 4usize],
    }
    #[doc = " DRM device."]
    #[doc = ""]
    #[doc = " Allocated as AVHWDeviceContext.hwctx."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVDRMDeviceContext {
        #[doc = " File descriptor of DRM device."]
        #[doc = ""]
        #[doc = " This is used as the device to create frames on, and may also be"]
        #[doc = " used in some derivation and mapping operations."]
        #[doc = ""]
        #[doc = " If no device is required, set to -1."]
        pub fd: ::std::os::raw::c_int,
    }
    pub const AVHMACType_AV_HMAC_MD5: root::AVHMACType = 0;
    pub const AVHMACType_AV_HMAC_SHA1: root::AVHMACType = 1;
    pub const AVHMACType_AV_HMAC_SHA224: root::AVHMACType = 2;
    pub const AVHMACType_AV_HMAC_SHA256: root::AVHMACType = 3;
    pub const AVHMACType_AV_HMAC_SHA384: root::AVHMACType = 4;
    pub const AVHMACType_AV_HMAC_SHA512: root::AVHMACType = 5;
    #[doc = " @defgroup lavu_hmac HMAC"]
    #[doc = " @ingroup lavu_crypto"]
    #[doc = " @{"]
    pub type AVHMACType = ::std::os::raw::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVHMAC {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVHMAC context."]
        #[doc = " @param type The hash function used for the HMAC."]
        pub fn av_hmac_alloc(type_: root::AVHMACType) -> *mut root::AVHMAC;
    }
    extern "C" {
        #[doc = " Free an AVHMAC context."]
        #[doc = " @param ctx The context to free, may be NULL"]
        pub fn av_hmac_free(ctx: *mut root::AVHMAC);
    }
    extern "C" {
        #[doc = " Initialize an AVHMAC context with an authentication key."]
        #[doc = " @param ctx    The HMAC context"]
        #[doc = " @param key    The authentication key"]
        #[doc = " @param keylen The length of the key, in bytes"]
        pub fn av_hmac_init(ctx: *mut root::AVHMAC, key: *const u8, keylen: ::std::os::raw::c_uint);
    }
    extern "C" {
        #[doc = " Hash data with the HMAC."]
        #[doc = " @param ctx  The HMAC context"]
        #[doc = " @param data The data to hash"]
        #[doc = " @param len  The length of the data, in bytes"]
        pub fn av_hmac_update(ctx: *mut root::AVHMAC, data: *const u8, len: ::std::os::raw::c_uint);
    }
    extern "C" {
        #[doc = " Finish hashing and output the HMAC digest."]
        #[doc = " @param ctx    The HMAC context"]
        #[doc = " @param out    The output buffer to write the digest into"]
        #[doc = " @param outlen The length of the out buffer, in bytes"]
        #[doc = " @return       The number of bytes written to out, or a negative error code."]
        pub fn av_hmac_final(
            ctx: *mut root::AVHMAC,
            out: *mut u8,
            outlen: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Hash an array of data with a key."]
        #[doc = " @param ctx    The HMAC context"]
        #[doc = " @param data   The data to hash"]
        #[doc = " @param len    The length of the data, in bytes"]
        #[doc = " @param key    The authentication key"]
        #[doc = " @param keylen The length of the key, in bytes"]
        #[doc = " @param out    The output buffer to write the digest into"]
        #[doc = " @param outlen The length of the out buffer, in bytes"]
        #[doc = " @return       The number of bytes written to out, or a negative error code."]
        pub fn av_hmac_calc(
            ctx: *mut root::AVHMAC,
            data: *const u8,
            len: ::std::os::raw::c_uint,
            key: *const u8,
            keylen: ::std::os::raw::c_uint,
            out: *mut u8,
            outlen: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVExpr {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Parse and evaluate an expression."]
        #[doc = " Note, this is significantly slower than av_expr_eval()."]
        #[doc = ""]
        #[doc = " @param res a pointer to a double where is put the result value of"]
        #[doc = " the expression, or NAN in case of error"]
        #[doc = " @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\""]
        #[doc = " @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}"]
        #[doc = " @param const_values a zero terminated array of values for the identifiers from const_names"]
        #[doc = " @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers"]
        #[doc = " @param funcs1 NULL terminated array of function pointers for functions which take 1 argument"]
        #[doc = " @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers"]
        #[doc = " @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments"]
        #[doc = " @param opaque a pointer which will be passed to all functions from funcs1 and funcs2"]
        #[doc = " @param log_ctx parent logging context"]
        #[doc = " @return >= 0 in case of success, a negative value corresponding to an"]
        #[doc = " AVERROR code otherwise"]
        pub fn av_expr_parse_and_eval(
            res: *mut f64,
            s: *const ::std::os::raw::c_char,
            const_names: *const *const ::std::os::raw::c_char,
            const_values: *const f64,
            func1_names: *const *const ::std::os::raw::c_char,
            funcs1: *const ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: f64) -> f64,
            >,
            func2_names: *const *const ::std::os::raw::c_char,
            funcs2: *const ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: f64,
                    arg3: f64,
                ) -> f64,
            >,
            opaque: *mut ::std::os::raw::c_void,
            log_offset: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Parse an expression."]
        #[doc = ""]
        #[doc = " @param expr a pointer where is put an AVExpr containing the parsed"]
        #[doc = " value in case of successful parsing, or NULL otherwise."]
        #[doc = " The pointed to AVExpr must be freed with av_expr_free() by the user"]
        #[doc = " when it is not needed anymore."]
        #[doc = " @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\""]
        #[doc = " @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}"]
        #[doc = " @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers"]
        #[doc = " @param funcs1 NULL terminated array of function pointers for functions which take 1 argument"]
        #[doc = " @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers"]
        #[doc = " @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments"]
        #[doc = " @param log_ctx parent logging context"]
        #[doc = " @return >= 0 in case of success, a negative value corresponding to an"]
        #[doc = " AVERROR code otherwise"]
        pub fn av_expr_parse(
            expr: *mut *mut root::AVExpr,
            s: *const ::std::os::raw::c_char,
            const_names: *const *const ::std::os::raw::c_char,
            func1_names: *const *const ::std::os::raw::c_char,
            funcs1: *const ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: f64) -> f64,
            >,
            func2_names: *const *const ::std::os::raw::c_char,
            funcs2: *const ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: f64,
                    arg3: f64,
                ) -> f64,
            >,
            log_offset: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Evaluate a previously parsed expression."]
        #[doc = ""]
        #[doc = " @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names"]
        #[doc = " @param opaque a pointer which will be passed to all functions from funcs1 and funcs2"]
        #[doc = " @return the value of the expression"]
        pub fn av_expr_eval(
            e: *mut root::AVExpr,
            const_values: *const f64,
            opaque: *mut ::std::os::raw::c_void,
        ) -> f64;
    }
    extern "C" {
        #[doc = " Track the presence of variables and their number of occurrences in a parsed expression"]
        #[doc = ""]
        #[doc = " @param counter a zero-initialized array where the count of each variable will be stored"]
        #[doc = " @param size size of array"]
        #[doc = " @return 0 on success, a negative value indicates that no expression or array was passed"]
        #[doc = " or size was zero"]
        pub fn av_expr_count_vars(
            e: *mut root::AVExpr,
            counter: *mut ::std::os::raw::c_uint,
            size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Track the presence of user provided functions and their number of occurrences"]
        #[doc = " in a parsed expression."]
        #[doc = ""]
        #[doc = " @param counter a zero-initialized array where the count of each function will be stored"]
        #[doc = "                if you passed 5 functions with 2 arguments to av_expr_parse()"]
        #[doc = "                then for arg=2 this will use upto 5 entries."]
        #[doc = " @param size size of array"]
        #[doc = " @param arg number of arguments the counted functions have"]
        #[doc = " @return 0 on success, a negative value indicates that no expression or array was passed"]
        #[doc = " or size was zero"]
        pub fn av_expr_count_func(
            e: *mut root::AVExpr,
            counter: *mut ::std::os::raw::c_uint,
            size: ::std::os::raw::c_int,
            arg: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Free a parsed expression previously created with av_expr_parse()."]
        pub fn av_expr_free(e: *mut root::AVExpr);
    }
    extern "C" {
        #[doc = " Parse the string in numstr and return its value as a double. If"]
        #[doc = " the string is empty, contains only whitespaces, or does not contain"]
        #[doc = " an initial substring that has the expected syntax for a"]
        #[doc = " floating-point number, no conversion is performed. In this case,"]
        #[doc = " returns a value of zero and the value returned in tail is the value"]
        #[doc = " of numstr."]
        #[doc = ""]
        #[doc = " @param numstr a string representing a number, may contain one of"]
        #[doc = " the International System number postfixes, for example 'K', 'M',"]
        #[doc = " 'G'. If 'i' is appended after the postfix, powers of 2 are used"]
        #[doc = " instead of powers of 10. The 'B' postfix multiplies the value by"]
        #[doc = " 8, and can be appended after another postfix or used alone. This"]
        #[doc = " allows using for example 'KB', 'MiB', 'G' and 'B' as postfix."]
        #[doc = " @param tail if non-NULL puts here the pointer to the char next"]
        #[doc = " after the last parsed character"]
        pub fn av_strtod(
            numstr: *const ::std::os::raw::c_char,
            tail: *mut *mut ::std::os::raw::c_char,
        ) -> f64;
    }
    extern "C" {
        #[doc = " Get a seed to use in conjunction with random functions."]
        #[doc = " This function tries to provide a good seed at a best effort bases."]
        #[doc = " Its possible to call this function multiple times if more bits are needed."]
        #[doc = " It can be quite slow, which is why it should only be used as seed for a faster"]
        #[doc = " PRNG. The quality of the seed depends on the platform."]
        pub fn av_get_random_seed() -> u32;
    }
    pub const AVOptionType_AV_OPT_TYPE_FLAGS: root::AVOptionType = 0;
    pub const AVOptionType_AV_OPT_TYPE_INT: root::AVOptionType = 1;
    pub const AVOptionType_AV_OPT_TYPE_INT64: root::AVOptionType = 2;
    pub const AVOptionType_AV_OPT_TYPE_DOUBLE: root::AVOptionType = 3;
    pub const AVOptionType_AV_OPT_TYPE_FLOAT: root::AVOptionType = 4;
    pub const AVOptionType_AV_OPT_TYPE_STRING: root::AVOptionType = 5;
    pub const AVOptionType_AV_OPT_TYPE_RATIONAL: root::AVOptionType = 6;
    #[doc = "< offset must point to a pointer immediately followed by an int for the length"]
    pub const AVOptionType_AV_OPT_TYPE_BINARY: root::AVOptionType = 7;
    pub const AVOptionType_AV_OPT_TYPE_DICT: root::AVOptionType = 8;
    pub const AVOptionType_AV_OPT_TYPE_UINT64: root::AVOptionType = 9;
    pub const AVOptionType_AV_OPT_TYPE_CONST: root::AVOptionType = 10;
    #[doc = "< offset must point to two consecutive integers"]
    pub const AVOptionType_AV_OPT_TYPE_IMAGE_SIZE: root::AVOptionType = 11;
    pub const AVOptionType_AV_OPT_TYPE_PIXEL_FMT: root::AVOptionType = 12;
    pub const AVOptionType_AV_OPT_TYPE_SAMPLE_FMT: root::AVOptionType = 13;
    #[doc = "< offset must point to AVRational"]
    pub const AVOptionType_AV_OPT_TYPE_VIDEO_RATE: root::AVOptionType = 14;
    pub const AVOptionType_AV_OPT_TYPE_DURATION: root::AVOptionType = 15;
    pub const AVOptionType_AV_OPT_TYPE_COLOR: root::AVOptionType = 16;
    pub const AVOptionType_AV_OPT_TYPE_CHANNEL_LAYOUT: root::AVOptionType = 17;
    pub const AVOptionType_AV_OPT_TYPE_BOOL: root::AVOptionType = 18;
    #[doc = " @defgroup avoptions AVOptions"]
    #[doc = " @ingroup lavu_data"]
    #[doc = " @{"]
    #[doc = " AVOptions provide a generic system to declare options on arbitrary structs"]
    #[doc = " (\"objects\"). An option can have a help text, a type and a range of possible"]
    #[doc = " values. Options may then be enumerated, read and written to."]
    #[doc = ""]
    #[doc = " @section avoptions_implement Implementing AVOptions"]
    #[doc = " This section describes how to add AVOptions capabilities to a struct."]
    #[doc = ""]
    #[doc = " All AVOptions-related information is stored in an AVClass. Therefore"]
    #[doc = " the first member of the struct should be a pointer to an AVClass describing it."]
    #[doc = " The option field of the AVClass must be set to a NULL-terminated static array"]
    #[doc = " of AVOptions. Each AVOption must have a non-empty name, a type, a default"]
    #[doc = " value and for number-type AVOptions also a range of allowed values. It must"]
    #[doc = " also declare an offset in bytes from the start of the struct, where the field"]
    #[doc = " associated with this AVOption is located. Other fields in the AVOption struct"]
    #[doc = " should also be set when applicable, but are not required."]
    #[doc = ""]
    #[doc = " The following example illustrates an AVOptions-enabled struct:"]
    #[doc = " @code"]
    #[doc = " typedef struct test_struct {"]
    #[doc = "     const AVClass *class;"]
    #[doc = "     int      int_opt;"]
    #[doc = "     char    *str_opt;"]
    #[doc = "     uint8_t *bin_opt;"]
    #[doc = "     int      bin_len;"]
    #[doc = " } test_struct;"]
    #[doc = ""]
    #[doc = " static const AVOption test_options[] = {"]
    #[doc = "   { \"test_int\", \"This is a test option of int type.\", offsetof(test_struct, int_opt),"]
    #[doc = "     AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },"]
    #[doc = "   { \"test_str\", \"This is a test option of string type.\", offsetof(test_struct, str_opt),"]
    #[doc = "     AV_OPT_TYPE_STRING },"]
    #[doc = "   { \"test_bin\", \"This is a test option of binary type.\", offsetof(test_struct, bin_opt),"]
    #[doc = "     AV_OPT_TYPE_BINARY },"]
    #[doc = "   { NULL },"]
    #[doc = " };"]
    #[doc = ""]
    #[doc = " static const AVClass test_class = {"]
    #[doc = "     .class_name = \"test class\","]
    #[doc = "     .item_name  = av_default_item_name,"]
    #[doc = "     .option     = test_options,"]
    #[doc = "     .version    = LIBAVUTIL_VERSION_INT,"]
    #[doc = " };"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " Next, when allocating your struct, you must ensure that the AVClass pointer"]
    #[doc = " is set to the correct value. Then, av_opt_set_defaults() can be called to"]
    #[doc = " initialize defaults. After that the struct is ready to be used with the"]
    #[doc = " AVOptions API."]
    #[doc = ""]
    #[doc = " When cleaning up, you may use the av_opt_free() function to automatically"]
    #[doc = " free all the allocated string and binary options."]
    #[doc = ""]
    #[doc = " Continuing with the above example:"]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = " test_struct *alloc_test_struct(void)"]
    #[doc = " {"]
    #[doc = "     test_struct *ret = av_mallocz(sizeof(*ret));"]
    #[doc = "     ret->class = &test_class;"]
    #[doc = "     av_opt_set_defaults(ret);"]
    #[doc = "     return ret;"]
    #[doc = " }"]
    #[doc = " void free_test_struct(test_struct **foo)"]
    #[doc = " {"]
    #[doc = "     av_opt_free(*foo);"]
    #[doc = "     av_freep(foo);"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @subsection avoptions_implement_nesting Nesting"]
    #[doc = "      It may happen that an AVOptions-enabled struct contains another"]
    #[doc = "      AVOptions-enabled struct as a member (e.g. AVCodecContext in"]
    #[doc = "      libavcodec exports generic options, while its priv_data field exports"]
    #[doc = "      codec-specific options). In such a case, it is possible to set up the"]
    #[doc = "      parent struct to export a child's options. To do that, simply"]
    #[doc = "      implement AVClass.child_next() and AVClass.child_class_iterate() in the"]
    #[doc = "      parent struct's AVClass."]
    #[doc = "      Assuming that the test_struct from above now also contains a"]
    #[doc = "      child_struct field:"]
    #[doc = ""]
    #[doc = "      @code"]
    #[doc = "      typedef struct child_struct {"]
    #[doc = "          AVClass *class;"]
    #[doc = "          int flags_opt;"]
    #[doc = "      } child_struct;"]
    #[doc = "      static const AVOption child_opts[] = {"]
    #[doc = "          { \"test_flags\", \"This is a test option of flags type.\","]
    #[doc = "            offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },"]
    #[doc = "          { NULL },"]
    #[doc = "      };"]
    #[doc = "      static const AVClass child_class = {"]
    #[doc = "          .class_name = \"child class\","]
    #[doc = "          .item_name  = av_default_item_name,"]
    #[doc = "          .option     = child_opts,"]
    #[doc = "          .version    = LIBAVUTIL_VERSION_INT,"]
    #[doc = "      };"]
    #[doc = ""]
    #[doc = "      void *child_next(void *obj, void *prev)"]
    #[doc = "      {"]
    #[doc = "          test_struct *t = obj;"]
    #[doc = "          if (!prev && t->child_struct)"]
    #[doc = "              return t->child_struct;"]
    #[doc = "          return NULL"]
    #[doc = "      }"]
    #[doc = "      const AVClass child_class_iterate(void **iter)"]
    #[doc = "      {"]
    #[doc = "          const AVClass *c = *iter ? NULL : &child_class;"]
    #[doc = "          *iter = (void*)(uintptr_t)c;"]
    #[doc = "          return c;"]
    #[doc = "      }"]
    #[doc = "      @endcode"]
    #[doc = "      Putting child_next() and child_class_iterate() as defined above into"]
    #[doc = "      test_class will now make child_struct's options accessible through"]
    #[doc = "      test_struct (again, proper setup as described above needs to be done on"]
    #[doc = "      child_struct right after it is created)."]
    #[doc = ""]
    #[doc = "      From the above example it might not be clear why both child_next()"]
    #[doc = "      and child_class_iterate() are needed. The distinction is that child_next()"]
    #[doc = "      iterates over actually existing objects, while child_class_iterate()"]
    #[doc = "      iterates over all possible child classes. E.g. if an AVCodecContext"]
    #[doc = "      was initialized to use a codec which has private options, then its"]
    #[doc = "      child_next() will return AVCodecContext.priv_data and finish"]
    #[doc = "      iterating. OTOH child_class_iterate() on AVCodecContext.av_class will"]
    #[doc = "      iterate over all available codecs with private options."]
    #[doc = ""]
    #[doc = " @subsection avoptions_implement_named_constants Named constants"]
    #[doc = "      It is possible to create named constants for options. Simply set the unit"]
    #[doc = "      field of the option the constants should apply to a string and"]
    #[doc = "      create the constants themselves as options of type AV_OPT_TYPE_CONST"]
    #[doc = "      with their unit field set to the same string."]
    #[doc = "      Their default_val field should contain the value of the named"]
    #[doc = "      constant."]
    #[doc = "      For example, to add some named constants for the test_flags option"]
    #[doc = "      above, put the following into the child_opts array:"]
    #[doc = "      @code"]
    #[doc = "      { \"test_flags\", \"This is a test option of flags type.\","]
    #[doc = "        offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, \"test_unit\" },"]
    #[doc = "      { \"flag1\", \"This is a flag with value 16\", 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, \"test_unit\" },"]
    #[doc = "      @endcode"]
    #[doc = ""]
    #[doc = " @section avoptions_use Using AVOptions"]
    #[doc = " This section deals with accessing options in an AVOptions-enabled struct."]
    #[doc = " Such structs in FFmpeg are e.g. AVCodecContext in libavcodec or"]
    #[doc = " AVFormatContext in libavformat."]
    #[doc = ""]
    #[doc = " @subsection avoptions_use_examine Examining AVOptions"]
    #[doc = " The basic functions for examining options are av_opt_next(), which iterates"]
    #[doc = " over all options defined for one object, and av_opt_find(), which searches"]
    #[doc = " for an option with the given name."]
    #[doc = ""]
    #[doc = " The situation is more complicated with nesting. An AVOptions-enabled struct"]
    #[doc = " may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN flag"]
    #[doc = " to av_opt_find() will make the function search children recursively."]
    #[doc = ""]
    #[doc = " For enumerating there are basically two cases. The first is when you want to"]
    #[doc = " get all options that may potentially exist on the struct and its children"]
    #[doc = " (e.g.  when constructing documentation). In that case you should call"]
    #[doc = " av_opt_child_class_iterate() recursively on the parent struct's AVClass.  The"]
    #[doc = " second case is when you have an already initialized struct with all its"]
    #[doc = " children and you want to get all options that can be actually written or read"]
    #[doc = " from it. In that case you should call av_opt_child_next() recursively (and"]
    #[doc = " av_opt_next() on each result)."]
    #[doc = ""]
    #[doc = " @subsection avoptions_use_get_set Reading and writing AVOptions"]
    #[doc = " When setting options, you often have a string read directly from the"]
    #[doc = " user. In such a case, simply passing it to av_opt_set() is enough. For"]
    #[doc = " non-string type options, av_opt_set() will parse the string according to the"]
    #[doc = " option type."]
    #[doc = ""]
    #[doc = " Similarly av_opt_get() will read any option type and convert it to a string"]
    #[doc = " which will be returned. Do not forget that the string is allocated, so you"]
    #[doc = " have to free it with av_free()."]
    #[doc = ""]
    #[doc = " In some cases it may be more convenient to put all options into an"]
    #[doc = " AVDictionary and call av_opt_set_dict() on it. A specific case of this"]
    #[doc = " are the format/codec open functions in lavf/lavc which take a dictionary"]
    #[doc = " filled with option as a parameter. This makes it possible to set some options"]
    #[doc = " that cannot be set otherwise, since e.g. the input file format is not known"]
    #[doc = " before the file is actually opened."]
    pub type AVOptionType = ::std::os::raw::c_uint;
    #[doc = " AVOption"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct AVOption {
        pub name: *const ::std::os::raw::c_char,
        #[doc = " short English help text"]
        #[doc = " @todo What about other languages?"]
        pub help: *const ::std::os::raw::c_char,
        #[doc = " The offset relative to the context structure where the option"]
        #[doc = " value is stored. It should be 0 for named constants."]
        pub offset: ::std::os::raw::c_int,
        pub type_: root::AVOptionType,
        pub default_val: root::AVOption__bindgen_ty_1,
        #[doc = "< minimum valid value for the option"]
        pub min: f64,
        #[doc = "< maximum valid value for the option"]
        pub max: f64,
        pub flags: ::std::os::raw::c_int,
        #[doc = " The logical unit to which the option belongs. Non-constant"]
        #[doc = " options and corresponding named constants share the same"]
        #[doc = " unit. May be NULL."]
        pub unit: *const ::std::os::raw::c_char,
    }
    #[doc = " the default value for scalar options"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union AVOption__bindgen_ty_1 {
        pub i64_: i64,
        pub dbl: f64,
        pub str_: *const ::std::os::raw::c_char,
        pub q: root::AVRational,
    }
    impl Default for AVOption__bindgen_ty_1 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    impl Default for AVOption {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = " A single allowed range of values, or a single allowed value."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVOptionRange {
        pub str_: *const ::std::os::raw::c_char,
        #[doc = " Value range."]
        #[doc = " For string ranges this represents the min/max length."]
        #[doc = " For dimensions this represents the min/max pixel count or width/height in multi-component case."]
        pub value_min: f64,
        #[doc = " Value range."]
        #[doc = " For string ranges this represents the min/max length."]
        #[doc = " For dimensions this represents the min/max pixel count or width/height in multi-component case."]
        pub value_max: f64,
        #[doc = " Value's component range."]
        #[doc = " For string this represents the unicode range for chars, 0-127 limits to ASCII."]
        pub component_min: f64,
        #[doc = " Value's component range."]
        #[doc = " For string this represents the unicode range for chars, 0-127 limits to ASCII."]
        pub component_max: f64,
        #[doc = " Range flag."]
        #[doc = " If set to 1 the struct encodes a range, if set to 0 a single value."]
        pub is_range: ::std::os::raw::c_int,
    }
    impl Default for AVOptionRange {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = " List of AVOptionRange structs."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVOptionRanges {
        #[doc = " Array of option ranges."]
        #[doc = ""]
        #[doc = " Most of option types use just one component."]
        #[doc = " Following describes multi-component option types:"]
        #[doc = ""]
        #[doc = " AV_OPT_TYPE_IMAGE_SIZE:"]
        #[doc = " component index 0: range of pixel count (width * height)."]
        #[doc = " component index 1: range of width."]
        #[doc = " component index 2: range of height."]
        #[doc = ""]
        #[doc = " @note To obtain multi-component version of this structure, user must"]
        #[doc = "       provide AV_OPT_MULTI_COMPONENT_RANGE to av_opt_query_ranges or"]
        #[doc = "       av_opt_query_ranges_default function."]
        #[doc = ""]
        #[doc = " Multi-component range can be read as in following example:"]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " int range_index, component_index;"]
        #[doc = " AVOptionRanges *ranges;"]
        #[doc = " AVOptionRange *range[3]; //may require more than 3 in the future."]
        #[doc = " av_opt_query_ranges(&ranges, obj, key, AV_OPT_MULTI_COMPONENT_RANGE);"]
        #[doc = " for (range_index = 0; range_index < ranges->nb_ranges; range_index++) {"]
        #[doc = "     for (component_index = 0; component_index < ranges->nb_components; component_index++)"]
        #[doc = "         range[component_index] = ranges->range[ranges->nb_ranges * component_index + range_index];"]
        #[doc = "     //do something with range here."]
        #[doc = " }"]
        #[doc = " av_opt_freep_ranges(&ranges);"]
        #[doc = " @endcode"]
        pub range: *mut *mut root::AVOptionRange,
        #[doc = " Number of ranges per component."]
        pub nb_ranges: ::std::os::raw::c_int,
        #[doc = " Number of componentes."]
        pub nb_components: ::std::os::raw::c_int,
    }
    impl Default for AVOptionRanges {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Show the obj options."]
        #[doc = ""]
        #[doc = " @param req_flags requested flags for the options to show. Show only the"]
        #[doc = " options for which it is opt->flags & req_flags."]
        #[doc = " @param rej_flags rejected flags for the options to show. Show only the"]
        #[doc = " options for which it is !(opt->flags & req_flags)."]
        #[doc = " @param av_log_obj log context to use for showing the options"]
        pub fn av_opt_show2(
            obj: *mut ::std::os::raw::c_void,
            av_log_obj: *mut ::std::os::raw::c_void,
            req_flags: ::std::os::raw::c_int,
            rej_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Set the values of all AVOption fields to their default values."]
        #[doc = ""]
        #[doc = " @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)"]
        pub fn av_opt_set_defaults(s: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " Set the values of all AVOption fields to their default values. Only these"]
        #[doc = " AVOption fields for which (opt->flags & mask) == flags will have their"]
        #[doc = " default applied to s."]
        #[doc = ""]
        #[doc = " @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)"]
        #[doc = " @param mask combination of AV_OPT_FLAG_*"]
        #[doc = " @param flags combination of AV_OPT_FLAG_*"]
        pub fn av_opt_set_defaults2(
            s: *mut ::std::os::raw::c_void,
            mask: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Parse the key/value pairs list in opts. For each key/value pair"]
        #[doc = " found, stores the value in the field in ctx that is named like the"]
        #[doc = " key. ctx must be an AVClass context, storing is done using"]
        #[doc = " AVOptions."]
        #[doc = ""]
        #[doc = " @param opts options string to parse, may be NULL"]
        #[doc = " @param key_val_sep a 0-terminated list of characters used to"]
        #[doc = " separate key from value"]
        #[doc = " @param pairs_sep a 0-terminated list of characters used to separate"]
        #[doc = " two pairs from each other"]
        #[doc = " @return the number of successfully set key/value pairs, or a negative"]
        #[doc = " value corresponding to an AVERROR code in case of error:"]
        #[doc = " AVERROR(EINVAL) if opts cannot be parsed,"]
        #[doc = " the error code issued by av_opt_set() if a key/value pair"]
        #[doc = " cannot be set"]
        pub fn av_set_options_string(
            ctx: *mut ::std::os::raw::c_void,
            opts: *const ::std::os::raw::c_char,
            key_val_sep: *const ::std::os::raw::c_char,
            pairs_sep: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Parse the key-value pairs list in opts. For each key=value pair found,"]
        #[doc = " set the value of the corresponding option in ctx."]
        #[doc = ""]
        #[doc = " @param ctx          the AVClass object to set options on"]
        #[doc = " @param opts         the options string, key-value pairs separated by a"]
        #[doc = "                     delimiter"]
        #[doc = " @param shorthand    a NULL-terminated array of options names for shorthand"]
        #[doc = "                     notation: if the first field in opts has no key part,"]
        #[doc = "                     the key is taken from the first element of shorthand;"]
        #[doc = "                     then again for the second, etc., until either opts is"]
        #[doc = "                     finished, shorthand is finished or a named option is"]
        #[doc = "                     found; after that, all options must be named"]
        #[doc = " @param key_val_sep  a 0-terminated list of characters used to separate"]
        #[doc = "                     key from value, for example '='"]
        #[doc = " @param pairs_sep    a 0-terminated list of characters used to separate"]
        #[doc = "                     two pairs from each other, for example ':' or ','"]
        #[doc = " @return  the number of successfully set key=value pairs, or a negative"]
        #[doc = "          value corresponding to an AVERROR code in case of error:"]
        #[doc = "          AVERROR(EINVAL) if opts cannot be parsed,"]
        #[doc = "          the error code issued by av_set_string3() if a key/value pair"]
        #[doc = "          cannot be set"]
        #[doc = ""]
        #[doc = " Options names must use only the following characters: a-z A-Z 0-9 - . / _"]
        #[doc = " Separators must use characters distinct from option names and from each"]
        #[doc = " other."]
        pub fn av_opt_set_from_string(
            ctx: *mut ::std::os::raw::c_void,
            opts: *const ::std::os::raw::c_char,
            shorthand: *const *const ::std::os::raw::c_char,
            key_val_sep: *const ::std::os::raw::c_char,
            pairs_sep: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Free all allocated objects in obj."]
        pub fn av_opt_free(obj: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " Check whether a particular flag is set in a flags field."]
        #[doc = ""]
        #[doc = " @param field_name the name of the flag field option"]
        #[doc = " @param flag_name the name of the flag to check"]
        #[doc = " @return non-zero if the flag is set, zero if the flag isn't set,"]
        #[doc = "         isn't of the right type, or the flags field doesn't exist."]
        pub fn av_opt_flag_is_set(
            obj: *mut ::std::os::raw::c_void,
            field_name: *const ::std::os::raw::c_char,
            flag_name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Set all the options from a given dictionary on an object."]
        #[doc = ""]
        #[doc = " @param obj a struct whose first element is a pointer to AVClass"]
        #[doc = " @param options options to process. This dictionary will be freed and replaced"]
        #[doc = "                by a new one containing all options not found in obj."]
        #[doc = "                Of course this new dictionary needs to be freed by caller"]
        #[doc = "                with av_dict_free()."]
        #[doc = ""]
        #[doc = " @return 0 on success, a negative AVERROR if some option was found in obj,"]
        #[doc = "         but could not be set."]
        #[doc = ""]
        #[doc = " @see av_dict_copy()"]
        pub fn av_opt_set_dict(
            obj: *mut ::std::os::raw::c_void,
            options: *mut *mut root::AVDictionary,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Set all the options from a given dictionary on an object."]
        #[doc = ""]
        #[doc = " @param obj a struct whose first element is a pointer to AVClass"]
        #[doc = " @param options options to process. This dictionary will be freed and replaced"]
        #[doc = "                by a new one containing all options not found in obj."]
        #[doc = "                Of course this new dictionary needs to be freed by caller"]
        #[doc = "                with av_dict_free()."]
        #[doc = " @param search_flags A combination of AV_OPT_SEARCH_*."]
        #[doc = ""]
        #[doc = " @return 0 on success, a negative AVERROR if some option was found in obj,"]
        #[doc = "         but could not be set."]
        #[doc = ""]
        #[doc = " @see av_dict_copy()"]
        pub fn av_opt_set_dict2(
            obj: *mut ::std::os::raw::c_void,
            options: *mut *mut root::AVDictionary,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Extract a key-value pair from the beginning of a string."]
        #[doc = ""]
        #[doc = " @param ropts        pointer to the options string, will be updated to"]
        #[doc = "                     point to the rest of the string (one of the pairs_sep"]
        #[doc = "                     or the final NUL)"]
        #[doc = " @param key_val_sep  a 0-terminated list of characters used to separate"]
        #[doc = "                     key from value, for example '='"]
        #[doc = " @param pairs_sep    a 0-terminated list of characters used to separate"]
        #[doc = "                     two pairs from each other, for example ':' or ','"]
        #[doc = " @param flags        flags; see the AV_OPT_FLAG_* values below"]
        #[doc = " @param rkey         parsed key; must be freed using av_free()"]
        #[doc = " @param rval         parsed value; must be freed using av_free()"]
        #[doc = ""]
        #[doc = " @return  >=0 for success, or a negative value corresponding to an"]
        #[doc = "          AVERROR code in case of error; in particular:"]
        #[doc = "          AVERROR(EINVAL) if no key is present"]
        #[doc = ""]
        pub fn av_opt_get_key_value(
            ropts: *mut *const ::std::os::raw::c_char,
            key_val_sep: *const ::std::os::raw::c_char,
            pairs_sep: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_uint,
            rkey: *mut *mut ::std::os::raw::c_char,
            rval: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " Accept to parse a value without a key; the key will then be returned"]
    #[doc = " as NULL."]
    pub const AV_OPT_FLAG_IMPLICIT_KEY: ::std::os::raw::c_uint = 1;
    pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " @defgroup opt_eval_funcs Evaluating option strings"]
        #[doc = " @{"]
        #[doc = " This group of functions can be used to evaluate option strings"]
        #[doc = " and get numbers out of them. They do the same thing as av_opt_set(),"]
        #[doc = " except the result is written into the caller-supplied pointer."]
        #[doc = ""]
        #[doc = " @param obj a struct whose first element is a pointer to AVClass."]
        #[doc = " @param o an option for which the string is to be evaluated."]
        #[doc = " @param val string to be evaluated."]
        #[doc = " @param *_out value of the string will be written here."]
        #[doc = ""]
        #[doc = " @return 0 on success, a negative number on failure."]
        pub fn av_opt_eval_flags(
            obj: *mut ::std::os::raw::c_void,
            o: *const root::AVOption,
            val: *const ::std::os::raw::c_char,
            flags_out: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_eval_int(
            obj: *mut ::std::os::raw::c_void,
            o: *const root::AVOption,
            val: *const ::std::os::raw::c_char,
            int_out: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_eval_int64(
            obj: *mut ::std::os::raw::c_void,
            o: *const root::AVOption,
            val: *const ::std::os::raw::c_char,
            int64_out: *mut i64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_eval_float(
            obj: *mut ::std::os::raw::c_void,
            o: *const root::AVOption,
            val: *const ::std::os::raw::c_char,
            float_out: *mut f32,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_eval_double(
            obj: *mut ::std::os::raw::c_void,
            o: *const root::AVOption,
            val: *const ::std::os::raw::c_char,
            double_out: *mut f64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_eval_q(
            obj: *mut ::std::os::raw::c_void,
            o: *const root::AVOption,
            val: *const ::std::os::raw::c_char,
            q_out: *mut root::AVRational,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Look for an option in an object. Consider only options which"]
        #[doc = " have all the specified flags set."]
        #[doc = ""]
        #[doc = " @param[in] obj A pointer to a struct whose first element is a"]
        #[doc = "                pointer to an AVClass."]
        #[doc = "                Alternatively a double pointer to an AVClass, if"]
        #[doc = "                AV_OPT_SEARCH_FAKE_OBJ search flag is set."]
        #[doc = " @param[in] name The name of the option to look for."]
        #[doc = " @param[in] unit When searching for named constants, name of the unit"]
        #[doc = "                 it belongs to."]
        #[doc = " @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG)."]
        #[doc = " @param search_flags A combination of AV_OPT_SEARCH_*."]
        #[doc = ""]
        #[doc = " @return A pointer to the option found, or NULL if no option"]
        #[doc = "         was found."]
        #[doc = ""]
        #[doc = " @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable"]
        #[doc = " directly with av_opt_set(). Use special calls which take an options"]
        #[doc = " AVDictionary (e.g. avformat_open_input()) to set options found with this"]
        #[doc = " flag."]
        pub fn av_opt_find(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            unit: *const ::std::os::raw::c_char,
            opt_flags: ::std::os::raw::c_int,
            search_flags: ::std::os::raw::c_int,
        ) -> *const root::AVOption;
    }
    extern "C" {
        #[doc = " Look for an option in an object. Consider only options which"]
        #[doc = " have all the specified flags set."]
        #[doc = ""]
        #[doc = " @param[in] obj A pointer to a struct whose first element is a"]
        #[doc = "                pointer to an AVClass."]
        #[doc = "                Alternatively a double pointer to an AVClass, if"]
        #[doc = "                AV_OPT_SEARCH_FAKE_OBJ search flag is set."]
        #[doc = " @param[in] name The name of the option to look for."]
        #[doc = " @param[in] unit When searching for named constants, name of the unit"]
        #[doc = "                 it belongs to."]
        #[doc = " @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG)."]
        #[doc = " @param search_flags A combination of AV_OPT_SEARCH_*."]
        #[doc = " @param[out] target_obj if non-NULL, an object to which the option belongs will be"]
        #[doc = " written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present"]
        #[doc = " in search_flags. This parameter is ignored if search_flags contain"]
        #[doc = " AV_OPT_SEARCH_FAKE_OBJ."]
        #[doc = ""]
        #[doc = " @return A pointer to the option found, or NULL if no option"]
        #[doc = "         was found."]
        pub fn av_opt_find2(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            unit: *const ::std::os::raw::c_char,
            opt_flags: ::std::os::raw::c_int,
            search_flags: ::std::os::raw::c_int,
            target_obj: *mut *mut ::std::os::raw::c_void,
        ) -> *const root::AVOption;
    }
    extern "C" {
        #[doc = " Iterate over all AVOptions belonging to obj."]
        #[doc = ""]
        #[doc = " @param obj an AVOptions-enabled struct or a double pointer to an"]
        #[doc = "            AVClass describing it."]
        #[doc = " @param prev result of the previous call to av_opt_next() on this object"]
        #[doc = "             or NULL"]
        #[doc = " @return next AVOption or NULL"]
        pub fn av_opt_next(
            obj: *const ::std::os::raw::c_void,
            prev: *const root::AVOption,
        ) -> *const root::AVOption;
    }
    extern "C" {
        #[doc = " Iterate over AVOptions-enabled children of obj."]
        #[doc = ""]
        #[doc = " @param prev result of a previous call to this function or NULL"]
        #[doc = " @return next AVOptions-enabled child or NULL"]
        pub fn av_opt_child_next(
            obj: *mut ::std::os::raw::c_void,
            prev: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Iterate over potential AVOptions-enabled children of parent."]
        #[doc = ""]
        #[doc = " @param iter a pointer where iteration state is stored."]
        #[doc = " @return AVClass corresponding to next potential child or NULL"]
        pub fn av_opt_child_class_iterate(
            parent: *const root::AVClass,
            iter: *mut *mut ::std::os::raw::c_void,
        ) -> *const root::AVClass;
    }
    extern "C" {
        #[doc = " @defgroup opt_set_funcs Option setting functions"]
        #[doc = " @{"]
        #[doc = " Those functions set the field of obj with the given name to value."]
        #[doc = ""]
        #[doc = " @param[in] obj A struct whose first element is a pointer to an AVClass."]
        #[doc = " @param[in] name the name of the field to set"]
        #[doc = " @param[in] val The value to set. In case of av_opt_set() if the field is not"]
        #[doc = " of a string type, then the given string is parsed."]
        #[doc = " SI postfixes and some named scalars are supported."]
        #[doc = " If the field is of a numeric type, it has to be a numeric or named"]
        #[doc = " scalar. Behavior with more than one scalar and +- infix operators"]
        #[doc = " is undefined."]
        #[doc = " If the field is of a flags type, it has to be a sequence of numeric"]
        #[doc = " scalars or named flags separated by '+' or '-'. Prefixing a flag"]
        #[doc = " with '+' causes it to be set without affecting the other flags;"]
        #[doc = " similarly, '-' unsets a flag."]
        #[doc = " If the field is of a dictionary type, it has to be a ':' separated list of"]
        #[doc = " key=value parameters. Values containing ':' special characters must be"]
        #[doc = " escaped."]
        #[doc = " @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN"]
        #[doc = " is passed here, then the option may be set on a child of obj."]
        #[doc = ""]
        #[doc = " @return 0 if the value has been set, or an AVERROR code in case of"]
        #[doc = " error:"]
        #[doc = " AVERROR_OPTION_NOT_FOUND if no matching option exists"]
        #[doc = " AVERROR(ERANGE) if the value is out of range"]
        #[doc = " AVERROR(EINVAL) if the value is not valid"]
        pub fn av_opt_set(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            val: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_set_int(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            val: i64,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_set_double(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            val: f64,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_set_q(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            val: root::AVRational,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_set_bin(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            val: *const u8,
            size: ::std::os::raw::c_int,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_set_image_size(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_set_pixel_fmt(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            fmt: root::AVPixelFormat,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_set_sample_fmt(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            fmt: root::AVSampleFormat,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_set_video_rate(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            val: root::AVRational,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_set_channel_layout(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            ch_layout: i64,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @note Any old dictionary present is discarded and replaced with a copy of the new one. The"]
        #[doc = " caller still owns val is and responsible for freeing it."]
        pub fn av_opt_set_dict_val(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            val: *const root::AVDictionary,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @defgroup opt_get_funcs Option getting functions"]
        #[doc = " @{"]
        #[doc = " Those functions get a value of the option with the given name from an object."]
        #[doc = ""]
        #[doc = " @param[in] obj a struct whose first element is a pointer to an AVClass."]
        #[doc = " @param[in] name name of the option to get."]
        #[doc = " @param[in] search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN"]
        #[doc = " is passed here, then the option may be found in a child of obj."]
        #[doc = " @param[out] out_val value of the option will be written here"]
        #[doc = " @return >=0 on success, a negative error code otherwise"]
        #[doc = " @note the returned string will be av_malloc()ed and must be av_free()ed by the caller"]
        #[doc = ""]
        #[doc = " @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the"]
        #[doc = " option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT"]
        #[doc = " and is set to NULL, *out_val will be set to NULL instead of an allocated"]
        #[doc = " empty string."]
        pub fn av_opt_get(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
            out_val: *mut *mut u8,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_get_int(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
            out_val: *mut i64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_get_double(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
            out_val: *mut f64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_get_q(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
            out_val: *mut root::AVRational,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_get_image_size(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
            w_out: *mut ::std::os::raw::c_int,
            h_out: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_get_pixel_fmt(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
            out_fmt: *mut root::AVPixelFormat,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_get_sample_fmt(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
            out_fmt: *mut root::AVSampleFormat,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_get_video_rate(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
            out_val: *mut root::AVRational,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn av_opt_get_channel_layout(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
            ch_layout: *mut i64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @param[out] out_val The returned dictionary is a copy of the actual value and must"]
        #[doc = " be freed with av_dict_free() by the caller"]
        pub fn av_opt_get_dict_val(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
            out_val: *mut *mut root::AVDictionary,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @}"]
        #[doc = " Gets a pointer to the requested field in a struct."]
        #[doc = " This function allows accessing a struct even when its fields are moved or"]
        #[doc = " renamed since the application making the access has been compiled,"]
        #[doc = ""]
        #[doc = " @returns a pointer to the field, it can be cast to the correct type and read"]
        #[doc = "          or written to."]
        pub fn av_opt_ptr(
            avclass: *const root::AVClass,
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Free an AVOptionRanges struct and set it to NULL."]
        pub fn av_opt_freep_ranges(ranges: *mut *mut root::AVOptionRanges);
    }
    extern "C" {
        #[doc = " Get a list of allowed ranges for the given option."]
        #[doc = ""]
        #[doc = " The returned list may depend on other fields in obj like for example profile."]
        #[doc = ""]
        #[doc = " @param flags is a bitmask of flags, undefined flags should not be set and should be ignored"]
        #[doc = "              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance"]
        #[doc = "              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges"]
        #[doc = ""]
        #[doc = " The result must be freed with av_opt_freep_ranges."]
        #[doc = ""]
        #[doc = " @return number of compontents returned on success, a negative errro code otherwise"]
        pub fn av_opt_query_ranges(
            arg1: *mut *mut root::AVOptionRanges,
            obj: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Copy options from src object into dest object."]
        #[doc = ""]
        #[doc = " The underlying AVClass of both src and dest must coincide. The guarantee"]
        #[doc = " below does not apply if this is not fulfilled."]
        #[doc = ""]
        #[doc = " Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object."]
        #[doc = " Original memory allocated for such options is freed unless both src and dest options points to the same memory."]
        #[doc = ""]
        #[doc = " Even on error it is guaranteed that allocated options from src and dest"]
        #[doc = " no longer alias each other afterwards; in particular calling av_opt_free()"]
        #[doc = " on both src and dest is safe afterwards if dest has been memdup'ed from src."]
        #[doc = ""]
        #[doc = " @param dest Object to copy from"]
        #[doc = " @param src  Object to copy into"]
        #[doc = " @return 0 on success, negative on error"]
        pub fn av_opt_copy(
            dest: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get a default list of allowed ranges for the given option."]
        #[doc = ""]
        #[doc = " This list is constructed without using the AVClass.query_ranges() callback"]
        #[doc = " and can be used as fallback from within the callback."]
        #[doc = ""]
        #[doc = " @param flags is a bitmask of flags, undefined flags should not be set and should be ignored"]
        #[doc = "              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance"]
        #[doc = "              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges"]
        #[doc = ""]
        #[doc = " The result must be freed with av_opt_free_ranges."]
        #[doc = ""]
        #[doc = " @return number of compontents returned on success, a negative errro code otherwise"]
        pub fn av_opt_query_ranges_default(
            arg1: *mut *mut root::AVOptionRanges,
            obj: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Check if given option is set to its default value."]
        #[doc = ""]
        #[doc = " Options o must belong to the obj. This function must not be called to check child's options state."]
        #[doc = " @see av_opt_is_set_to_default_by_name()."]
        #[doc = ""]
        #[doc = " @param obj  AVClass object to check option on"]
        #[doc = " @param o    option to be checked"]
        #[doc = " @return     >0 when option is set to its default,"]
        #[doc = "              0 when option is not set its default,"]
        #[doc = "             <0 on error"]
        pub fn av_opt_is_set_to_default(
            obj: *mut ::std::os::raw::c_void,
            o: *const root::AVOption,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Check if given option is set to its default value."]
        #[doc = ""]
        #[doc = " @param obj          AVClass object to check option on"]
        #[doc = " @param name         option name"]
        #[doc = " @param search_flags combination of AV_OPT_SEARCH_*"]
        #[doc = " @return             >0 when option is set to its default,"]
        #[doc = "                     0 when option is not set its default,"]
        #[doc = "                     <0 on error"]
        pub fn av_opt_is_set_to_default_by_name(
            obj: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            search_flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Serialize object's options."]
        #[doc = ""]
        #[doc = " Create a string containing object's serialized options."]
        #[doc = " Such string may be passed back to av_opt_set_from_string() in order to restore option values."]
        #[doc = " A key/value or pairs separator occurring in the serialized value or"]
        #[doc = " name string are escaped through the av_escape() function."]
        #[doc = ""]
        #[doc = " @param[in]  obj           AVClass object to serialize"]
        #[doc = " @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)"]
        #[doc = " @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags"]
        #[doc = " @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options."]
        #[doc = "                           Buffer must be freed by the caller when is no longer needed."]
        #[doc = " @param[in]  key_val_sep   character used to separate key from value"]
        #[doc = " @param[in]  pairs_sep     character used to separate two pairs from each other"]
        #[doc = " @return                   >= 0 on success, negative on error"]
        #[doc = " @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same."]
        pub fn av_opt_serialize(
            obj: *mut ::std::os::raw::c_void,
            opt_flags: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
            buffer: *mut *mut ::std::os::raw::c_char,
            key_val_sep: ::std::os::raw::c_char,
            pairs_sep: ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " Mastering display metadata capable of representing the color volume of"]
    #[doc = " the display used to master the content (SMPTE 2086:2014)."]
    #[doc = ""]
    #[doc = " To be used as payload of a AVFrameSideData or AVPacketSideData with the"]
    #[doc = " appropriate type."]
    #[doc = ""]
    #[doc = " @note The struct should be allocated with av_mastering_display_metadata_alloc()"]
    #[doc = "       and its size is not a part of the public ABI."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVMasteringDisplayMetadata {
        #[doc = " CIE 1931 xy chromaticity coords of color primaries (r, g, b order)."]
        pub display_primaries: [[root::AVRational; 2usize]; 3usize],
        #[doc = " CIE 1931 xy chromaticity coords of white point."]
        pub white_point: [root::AVRational; 2usize],
        #[doc = " Min luminance of mastering display (cd/m^2)."]
        pub min_luminance: root::AVRational,
        #[doc = " Max luminance of mastering display (cd/m^2)."]
        pub max_luminance: root::AVRational,
        #[doc = " Flag indicating whether the display primaries (and white point) are set."]
        pub has_primaries: ::std::os::raw::c_int,
        #[doc = " Flag indicating whether the luminance (min_ and max_) have been set."]
        pub has_luminance: ::std::os::raw::c_int,
    }
    extern "C" {
        #[doc = " Allocate an AVMasteringDisplayMetadata structure and set its fields to"]
        #[doc = " default values. The resulting struct can be freed using av_freep()."]
        #[doc = ""]
        #[doc = " @return An AVMasteringDisplayMetadata filled with default values or NULL"]
        #[doc = "         on failure."]
        pub fn av_mastering_display_metadata_alloc() -> *mut root::AVMasteringDisplayMetadata;
    }
    extern "C" {
        #[doc = " Allocate a complete AVMasteringDisplayMetadata and add it to the frame."]
        #[doc = ""]
        #[doc = " @param frame The frame which side data is added to."]
        #[doc = ""]
        #[doc = " @return The AVMasteringDisplayMetadata structure to be filled by caller."]
        pub fn av_mastering_display_metadata_create_side_data(
            frame: *mut root::AVFrame,
        ) -> *mut root::AVMasteringDisplayMetadata;
    }
    #[doc = " Content light level needed by to transmit HDR over HDMI (CTA-861.3)."]
    #[doc = ""]
    #[doc = " To be used as payload of a AVFrameSideData or AVPacketSideData with the"]
    #[doc = " appropriate type."]
    #[doc = ""]
    #[doc = " @note The struct should be allocated with av_content_light_metadata_alloc()"]
    #[doc = "       and its size is not a part of the public ABI."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVContentLightMetadata {
        #[doc = " Max content light level (cd/m^2)."]
        pub MaxCLL: ::std::os::raw::c_uint,
        #[doc = " Max average light level per frame (cd/m^2)."]
        pub MaxFALL: ::std::os::raw::c_uint,
    }
    extern "C" {
        #[doc = " Allocate an AVContentLightMetadata structure and set its fields to"]
        #[doc = " default values. The resulting struct can be freed using av_freep()."]
        #[doc = ""]
        #[doc = " @return An AVContentLightMetadata filled with default values or NULL"]
        #[doc = "         on failure."]
        pub fn av_content_light_metadata_alloc(
            size: *mut root::size_t,
        ) -> *mut root::AVContentLightMetadata;
    }
    extern "C" {
        #[doc = " Allocate a complete AVContentLightMetadata and add it to the frame."]
        #[doc = ""]
        #[doc = " @param frame The frame which side data is added to."]
        #[doc = ""]
        #[doc = " @return The AVContentLightMetadata structure to be filled by caller."]
        pub fn av_content_light_metadata_create_side_data(
            frame: *mut root::AVFrame,
        ) -> *mut root::AVContentLightMetadata;
    }
    extern "C" {
        #[doc = " @defgroup lavu_aes AES"]
        #[doc = " @ingroup lavu_crypto"]
        #[doc = " @{"]
        pub static av_aes_size: ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVAES {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVAES context."]
        pub fn av_aes_alloc() -> *mut root::AVAES;
    }
    extern "C" {
        #[doc = " Initialize an AVAES context."]
        #[doc = " @param key_bits 128, 192 or 256"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_aes_init(
            a: *mut root::AVAES,
            key: *const u8,
            key_bits: ::std::os::raw::c_int,
            decrypt: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Encrypt or decrypt a buffer using a previously initialized context."]
        #[doc = " @param count number of 16 byte blocks"]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst"]
        #[doc = " @param iv initialization vector for CBC mode, if NULL then ECB will be used"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_aes_crypt(
            a: *mut root::AVAES,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            iv: *mut u8,
            decrypt: ::std::os::raw::c_int,
        );
    }
    #[doc = " @defgroup lavu_rc4 RC4"]
    #[doc = " @ingroup lavu_crypto"]
    #[doc = " @{"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVRC4 {
        pub state: [u8; 256usize],
        pub x: ::std::os::raw::c_int,
        pub y: ::std::os::raw::c_int,
    }
    impl Default for AVRC4 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Allocate an AVRC4 context."]
        pub fn av_rc4_alloc() -> *mut root::AVRC4;
    }
    extern "C" {
        #[doc = " @brief Initializes an AVRC4 context."]
        #[doc = ""]
        #[doc = " @param key_bits must be a multiple of 8"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption, currently has no effect"]
        #[doc = " @return zero on success, negative value otherwise"]
        pub fn av_rc4_init(
            d: *mut root::AVRC4,
            key: *const u8,
            key_bits: ::std::os::raw::c_int,
            decrypt: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @brief Encrypts / decrypts using the RC4 algorithm."]
        #[doc = ""]
        #[doc = " @param count number of bytes"]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst, may be NULL"]
        #[doc = " @param iv not (yet) used for RC4, should be NULL"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption, not (yet) used"]
        pub fn av_rc4_crypt(
            d: *mut root::AVRC4,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            iv: *mut u8,
            decrypt: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " @file"]
        #[doc = " @brief Public header for libavutil TEA algorithm"]
        #[doc = " @defgroup lavu_tea TEA"]
        #[doc = " @ingroup lavu_crypto"]
        #[doc = " @{"]
        pub static av_tea_size: ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVTEA {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVTEA context"]
        #[doc = " To free the struct: av_free(ptr)"]
        pub fn av_tea_alloc() -> *mut root::AVTEA;
    }
    extern "C" {
        #[doc = " Initialize an AVTEA context."]
        #[doc = ""]
        #[doc = " @param ctx an AVTEA context"]
        #[doc = " @param key a key of 16 bytes used for encryption/decryption"]
        #[doc = " @param rounds the number of rounds in TEA (64 is the \"standard\")"]
        pub fn av_tea_init(ctx: *mut root::AVTEA, key: *const u8, rounds: ::std::os::raw::c_int);
    }
    extern "C" {
        #[doc = " Encrypt or decrypt a buffer using a previously initialized context."]
        #[doc = ""]
        #[doc = " @param ctx an AVTEA context"]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst"]
        #[doc = " @param count number of 8 byte blocks"]
        #[doc = " @param iv initialization vector for CBC mode, if NULL then ECB will be used"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_tea_crypt(
            ctx: *mut root::AVTEA,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            iv: *mut u8,
            decrypt: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Return the flags which specify extensions supported by the CPU."]
        #[doc = " The returned value is affected by av_force_cpu_flags() if that was used"]
        #[doc = " before. So av_get_cpu_flags() can easily be used in an application to"]
        #[doc = " detect the enabled cpu flags."]
        pub fn av_get_cpu_flags() -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Disables cpu detection and forces the specified flags."]
        #[doc = " -1 is a special case that disables forcing of specific flags."]
        pub fn av_force_cpu_flags(flags: ::std::os::raw::c_int);
    }
    extern "C" {
        #[doc = " Parse CPU caps from a string and update the given AV_CPU_* flags based on that."]
        #[doc = ""]
        #[doc = " @return negative on error."]
        pub fn av_parse_cpu_caps(
            flags: *mut ::std::os::raw::c_uint,
            s: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @return the number of logical CPU cores present."]
        pub fn av_cpu_count() -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Overrides cpu count detection and forces the specified count."]
        #[doc = " Count < 1 disables forcing of specific count."]
        pub fn av_cpu_force_count(count: ::std::os::raw::c_int);
    }
    extern "C" {
        #[doc = " Get the maximum data alignment that may be required by FFmpeg."]
        #[doc = ""]
        #[doc = " Note that this is affected by the build configuration and the CPU flags mask,"]
        #[doc = " so e.g. if the CPU supports AVX, but libavutil has been built with"]
        #[doc = " --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through"]
        #[doc = "  av_set_cpu_flags_mask(), then this function will behave as if AVX is not"]
        #[doc = "  present."]
        pub fn av_cpu_max_align() -> root::size_t;
    }
    #[doc = " @defgroup lavu_des DES"]
    #[doc = " @ingroup lavu_crypto"]
    #[doc = " @{"]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVDES {
        pub round_keys: [[u64; 16usize]; 3usize],
        pub triple_des: ::std::os::raw::c_int,
    }
    extern "C" {
        #[doc = " Allocate an AVDES context."]
        pub fn av_des_alloc() -> *mut root::AVDES;
    }
    extern "C" {
        #[doc = " @brief Initializes an AVDES context."]
        #[doc = ""]
        #[doc = " @param key_bits must be 64 or 192"]
        #[doc = " @param decrypt 0 for encryption/CBC-MAC, 1 for decryption"]
        #[doc = " @return zero on success, negative value otherwise"]
        pub fn av_des_init(
            d: *mut root::AVDES,
            key: *const u8,
            key_bits: ::std::os::raw::c_int,
            decrypt: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " @brief Encrypts / decrypts using the DES algorithm."]
        #[doc = ""]
        #[doc = " @param count number of 8 byte blocks"]
        #[doc = " @param dst destination array, can be equal to src, must be 8-byte aligned"]
        #[doc = " @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL"]
        #[doc = " @param iv initialization vector for CBC mode, if NULL then ECB will be used,"]
        #[doc = "           must be 8-byte aligned"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_des_crypt(
            d: *mut root::AVDES,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            iv: *mut u8,
            decrypt: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " @brief Calculates CBC-MAC using the DES algorithm."]
        #[doc = ""]
        #[doc = " @param count number of 8 byte blocks"]
        #[doc = " @param dst destination array, can be equal to src, must be 8-byte aligned"]
        #[doc = " @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL"]
        pub fn av_des_mac(
            d: *mut root::AVDES,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
        );
    }
    pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NONE: root::AVMatrixEncoding = 0;
    pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBY: root::AVMatrixEncoding = 1;
    pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLII: root::AVMatrixEncoding = 2;
    pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIX: root::AVMatrixEncoding = 3;
    pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIZ: root::AVMatrixEncoding = 4;
    pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYEX: root::AVMatrixEncoding = 5;
    pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYHEADPHONE: root::AVMatrixEncoding = 6;
    pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NB: root::AVMatrixEncoding = 7;
    pub type AVMatrixEncoding = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Return a channel layout id that matches name, or 0 if no match is found."]
        #[doc = ""]
        #[doc = " name can be one or several of the following notations,"]
        #[doc = " separated by '+' or '|':"]
        #[doc = " - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,"]
        #[doc = "   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);"]
        #[doc = " - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,"]
        #[doc = "   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);"]
        #[doc = " - a number of channels, in decimal, followed by 'c', yielding"]
        #[doc = "   the default channel layout for that number of channels (@see"]
        #[doc = "   av_get_default_channel_layout);"]
        #[doc = " - a channel layout mask, in hexadecimal starting with \"0x\" (see the"]
        #[doc = "   AV_CH_* macros)."]
        #[doc = ""]
        #[doc = " Example: \"stereo+FC\" = \"2c+FC\" = \"2c+1c\" = \"0x7\""]
        pub fn av_get_channel_layout(name: *const ::std::os::raw::c_char) -> u64;
    }
    extern "C" {
        #[doc = " Return a channel layout and the number of channels based on the specified name."]
        #[doc = ""]
        #[doc = " This function is similar to (@see av_get_channel_layout), but can also parse"]
        #[doc = " unknown channel layout specifications."]
        #[doc = ""]
        #[doc = " @param[in]  name             channel layout specification string"]
        #[doc = " @param[out] channel_layout   parsed channel layout (0 if unknown)"]
        #[doc = " @param[out] nb_channels      number of channels"]
        #[doc = ""]
        #[doc = " @return 0 on success, AVERROR(EINVAL) if the parsing fails."]
        pub fn av_get_extended_channel_layout(
            name: *const ::std::os::raw::c_char,
            channel_layout: *mut u64,
            nb_channels: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return a description of a channel layout."]
        #[doc = " If nb_channels is <= 0, it is guessed from the channel_layout."]
        #[doc = ""]
        #[doc = " @param buf put here the string containing the channel layout"]
        #[doc = " @param buf_size size in bytes of the buffer"]
        pub fn av_get_channel_layout_string(
            buf: *mut ::std::os::raw::c_char,
            buf_size: ::std::os::raw::c_int,
            nb_channels: ::std::os::raw::c_int,
            channel_layout: u64,
        );
    }
    extern "C" {
        #[doc = " Append a description of a channel layout to a bprint buffer."]
        pub fn av_bprint_channel_layout(
            bp: *mut root::AVBPrint,
            nb_channels: ::std::os::raw::c_int,
            channel_layout: u64,
        );
    }
    extern "C" {
        #[doc = " Return the number of channels in the channel layout."]
        pub fn av_get_channel_layout_nb_channels(channel_layout: u64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return default channel layout for a given number of channels."]
        pub fn av_get_default_channel_layout(nb_channels: ::std::os::raw::c_int) -> i64;
    }
    extern "C" {
        #[doc = " Get the index of a channel in channel_layout."]
        #[doc = ""]
        #[doc = " @param channel a channel layout describing exactly one channel which must be"]
        #[doc = "                present in channel_layout."]
        #[doc = ""]
        #[doc = " @return index of channel in channel_layout on success, a negative AVERROR"]
        #[doc = "         on error."]
        pub fn av_get_channel_layout_channel_index(
            channel_layout: u64,
            channel: u64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the channel with the given index in channel_layout."]
        pub fn av_channel_layout_extract_channel(
            channel_layout: u64,
            index: ::std::os::raw::c_int,
        ) -> u64;
    }
    extern "C" {
        #[doc = " Get the name of a given channel."]
        #[doc = ""]
        #[doc = " @return channel name on success, NULL on error."]
        pub fn av_get_channel_name(channel: u64) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the description of a given channel."]
        #[doc = ""]
        #[doc = " @param channel  a channel layout with a single channel"]
        #[doc = " @return  channel description on success, NULL on error"]
        pub fn av_get_channel_description(channel: u64) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the value and name of a standard channel layout."]
        #[doc = ""]
        #[doc = " @param[in]  index   index in an internal list, starting at 0"]
        #[doc = " @param[out] layout  channel layout mask"]
        #[doc = " @param[out] name    name of the layout"]
        #[doc = " @return  0  if the layout exists,"]
        #[doc = "          <0 if index is beyond the limits"]
        pub fn av_get_standard_channel_layout(
            index: ::std::os::raw::c_uint,
            layout: *mut u64,
            name: *mut *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVSubsampleEncryptionInfo {
        #[doc = " The number of bytes that are clear."]
        pub bytes_of_clear_data: ::std::os::raw::c_uint,
        #[doc = " The number of bytes that are protected.  If using pattern encryption,"]
        #[doc = " the pattern applies to only the protected bytes; if not using pattern"]
        #[doc = " encryption, all these bytes are encrypted."]
        pub bytes_of_protected_data: ::std::os::raw::c_uint,
    }
    #[doc = " This describes encryption info for a packet.  This contains frame-specific"]
    #[doc = " info for how to decrypt the packet before passing it to the decoder."]
    #[doc = ""]
    #[doc = " The size of this struct is not part of the public ABI."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVEncryptionInfo {
        #[doc = " The fourcc encryption scheme, in big-endian byte order."]
        pub scheme: u32,
        #[doc = " Only used for pattern encryption.  This is the number of 16-byte blocks"]
        #[doc = " that are encrypted."]
        pub crypt_byte_block: u32,
        #[doc = " Only used for pattern encryption.  This is the number of 16-byte blocks"]
        #[doc = " that are clear."]
        pub skip_byte_block: u32,
        #[doc = " The ID of the key used to encrypt the packet.  This should always be"]
        #[doc = " 16 bytes long, but may be changed in the future."]
        pub key_id: *mut u8,
        pub key_id_size: u32,
        #[doc = " The initialization vector.  This may have been zero-filled to be the"]
        #[doc = " correct block size.  This should always be 16 bytes long, but may be"]
        #[doc = " changed in the future."]
        pub iv: *mut u8,
        pub iv_size: u32,
        #[doc = " An array of subsample encryption info specifying how parts of the sample"]
        #[doc = " are encrypted.  If there are no subsamples, then the whole sample is"]
        #[doc = " encrypted."]
        pub subsamples: *mut root::AVSubsampleEncryptionInfo,
        pub subsample_count: u32,
    }
    impl Default for AVEncryptionInfo {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = " This describes info used to initialize an encryption key system."]
    #[doc = ""]
    #[doc = " The size of this struct is not part of the public ABI."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVEncryptionInitInfo {
        #[doc = " A unique identifier for the key system this is for, can be NULL if it"]
        #[doc = " is not known.  This should always be 16 bytes, but may change in the"]
        #[doc = " future."]
        pub system_id: *mut u8,
        pub system_id_size: u32,
        #[doc = " An array of key IDs this initialization data is for.  All IDs are the"]
        #[doc = " same length.  Can be NULL if there are no known key IDs."]
        pub key_ids: *mut *mut u8,
        #[doc = " The number of key IDs."]
        pub num_key_ids: u32,
        #[doc = " The number of bytes in each key ID.  This should always be 16, but may"]
        #[doc = " change in the future."]
        pub key_id_size: u32,
        #[doc = " Key-system specific initialization data.  This data is copied directly"]
        #[doc = " from the file and the format depends on the specific key system.  This"]
        #[doc = " can be NULL if there is no initialization data; in that case, there"]
        #[doc = " will be at least one key ID."]
        pub data: *mut u8,
        pub data_size: u32,
        #[doc = " An optional pointer to the next initialization info in the list."]
        pub next: *mut root::AVEncryptionInitInfo,
    }
    impl Default for AVEncryptionInitInfo {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Allocates an AVEncryptionInfo structure and sub-pointers to hold the given"]
        #[doc = " number of subsamples.  This will allocate pointers for the key ID, IV,"]
        #[doc = " and subsample entries, set the size members, and zero-initialize the rest."]
        #[doc = ""]
        #[doc = " @param subsample_count The number of subsamples."]
        #[doc = " @param key_id_size The number of bytes in the key ID, should be 16."]
        #[doc = " @param iv_size The number of bytes in the IV, should be 16."]
        #[doc = ""]
        #[doc = " @return The new AVEncryptionInfo structure, or NULL on error."]
        pub fn av_encryption_info_alloc(
            subsample_count: u32,
            key_id_size: u32,
            iv_size: u32,
        ) -> *mut root::AVEncryptionInfo;
    }
    extern "C" {
        #[doc = " Allocates an AVEncryptionInfo structure with a copy of the given data."]
        #[doc = " @return The new AVEncryptionInfo structure, or NULL on error."]
        pub fn av_encryption_info_clone(
            info: *const root::AVEncryptionInfo,
        ) -> *mut root::AVEncryptionInfo;
    }
    extern "C" {
        #[doc = " Frees the given encryption info object.  This MUST NOT be used to free the"]
        #[doc = " side-data data pointer, that should use normal side-data methods."]
        pub fn av_encryption_info_free(info: *mut root::AVEncryptionInfo);
    }
    extern "C" {
        #[doc = " Creates a copy of the AVEncryptionInfo that is contained in the given side"]
        #[doc = " data.  The resulting object should be passed to av_encryption_info_free()"]
        #[doc = " when done."]
        #[doc = ""]
        #[doc = " @return The new AVEncryptionInfo structure, or NULL on error."]
        pub fn av_encryption_info_get_side_data(
            side_data: *const u8,
            side_data_size: root::size_t,
        ) -> *mut root::AVEncryptionInfo;
    }
    extern "C" {
        #[doc = " Allocates and initializes side data that holds a copy of the given encryption"]
        #[doc = " info.  The resulting pointer should be either freed using av_free or given"]
        #[doc = " to av_packet_add_side_data()."]
        #[doc = ""]
        #[doc = " @return The new side-data pointer, or NULL."]
        pub fn av_encryption_info_add_side_data(
            info: *const root::AVEncryptionInfo,
            side_data_size: *mut root::size_t,
        ) -> *mut u8;
    }
    extern "C" {
        #[doc = " Allocates an AVEncryptionInitInfo structure and sub-pointers to hold the"]
        #[doc = " given sizes.  This will allocate pointers and set all the fields."]
        #[doc = ""]
        #[doc = " @return The new AVEncryptionInitInfo structure, or NULL on error."]
        pub fn av_encryption_init_info_alloc(
            system_id_size: u32,
            num_key_ids: u32,
            key_id_size: u32,
            data_size: u32,
        ) -> *mut root::AVEncryptionInitInfo;
    }
    extern "C" {
        #[doc = " Frees the given encryption init info object.  This MUST NOT be used to free"]
        #[doc = " the side-data data pointer, that should use normal side-data methods."]
        pub fn av_encryption_init_info_free(info: *mut root::AVEncryptionInitInfo);
    }
    extern "C" {
        #[doc = " Creates a copy of the AVEncryptionInitInfo that is contained in the given"]
        #[doc = " side data.  The resulting object should be passed to"]
        #[doc = " av_encryption_init_info_free() when done."]
        #[doc = ""]
        #[doc = " @return The new AVEncryptionInitInfo structure, or NULL on error."]
        pub fn av_encryption_init_info_get_side_data(
            side_data: *const u8,
            side_data_size: root::size_t,
        ) -> *mut root::AVEncryptionInitInfo;
    }
    extern "C" {
        #[doc = " Allocates and initializes side data that holds a copy of the given encryption"]
        #[doc = " init info.  The resulting pointer should be either freed using av_free or"]
        #[doc = " given to av_packet_add_side_data()."]
        #[doc = ""]
        #[doc = " @return The new side-data pointer, or NULL."]
        pub fn av_encryption_init_info_add_side_data(
            info: *const root::AVEncryptionInitInfo,
            side_data_size: *mut root::size_t,
        ) -> *mut u8;
    }
    extern "C" {
        #[doc = " @file"]
        #[doc = " @brief Public header for libavutil TWOFISH algorithm"]
        #[doc = " @defgroup lavu_twofish TWOFISH"]
        #[doc = " @ingroup lavu_crypto"]
        #[doc = " @{"]
        pub static av_twofish_size: ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVTWOFISH {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVTWOFISH context"]
        #[doc = " To free the struct: av_free(ptr)"]
        pub fn av_twofish_alloc() -> *mut root::AVTWOFISH;
    }
    extern "C" {
        #[doc = " Initialize an AVTWOFISH context."]
        #[doc = ""]
        #[doc = " @param ctx an AVTWOFISH context"]
        #[doc = " @param key a key of size ranging from 1 to 32 bytes used for encryption/decryption"]
        #[doc = " @param key_bits number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise"]
        pub fn av_twofish_init(
            ctx: *mut root::AVTWOFISH,
            key: *const u8,
            key_bits: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Encrypt or decrypt a buffer using a previously initialized context"]
        #[doc = ""]
        #[doc = " @param ctx an AVTWOFISH context"]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst"]
        #[doc = " @param count number of 16 byte blocks"]
        #[doc = " @paran iv initialization vector for CBC mode, NULL for ECB mode"]
        #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
        pub fn av_twofish_crypt(
            ctx: *mut root::AVTWOFISH,
            dst: *mut u8,
            src: *const u8,
            count: ::std::os::raw::c_int,
            iv: *mut u8,
            decrypt: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Compute the max pixel step for each plane of an image with a"]
        #[doc = " format described by pixdesc."]
        #[doc = ""]
        #[doc = " The pixel step is the distance in bytes between the first byte of"]
        #[doc = " the group of bytes which describe a pixel component and the first"]
        #[doc = " byte of the successive group in the same plane for the same"]
        #[doc = " component."]
        #[doc = ""]
        #[doc = " @param max_pixsteps an array which is filled with the max pixel step"]
        #[doc = " for each plane. Since a plane may contain different pixel"]
        #[doc = " components, the computed max_pixsteps[plane] is relative to the"]
        #[doc = " component in the plane with the max pixel step."]
        #[doc = " @param max_pixstep_comps an array which is filled with the component"]
        #[doc = " for each plane which has the max pixel step. May be NULL."]
        pub fn av_image_fill_max_pixsteps(
            max_pixsteps: *mut ::std::os::raw::c_int,
            max_pixstep_comps: *mut ::std::os::raw::c_int,
            pixdesc: *const root::AVPixFmtDescriptor,
        );
    }
    extern "C" {
        #[doc = " Compute the size of an image line with format pix_fmt and width"]
        #[doc = " width for the plane plane."]
        #[doc = ""]
        #[doc = " @return the computed size in bytes"]
        pub fn av_image_get_linesize(
            pix_fmt: root::AVPixelFormat,
            width: ::std::os::raw::c_int,
            plane: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Fill plane linesizes for an image with pixel format pix_fmt and"]
        #[doc = " width width."]
        #[doc = ""]
        #[doc = " @param linesizes array to be filled with the linesize for each plane"]
        #[doc = " @return >= 0 in case of success, a negative error code otherwise"]
        pub fn av_image_fill_linesizes(
            linesizes: *mut ::std::os::raw::c_int,
            pix_fmt: root::AVPixelFormat,
            width: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Fill plane sizes for an image with pixel format pix_fmt and height height."]
        #[doc = ""]
        #[doc = " @param size the array to be filled with the size of each image plane"]
        #[doc = " @param linesizes the array containing the linesize for each"]
        #[doc = "        plane, should be filled by av_image_fill_linesizes()"]
        #[doc = " @return >= 0 in case of success, a negative error code otherwise"]
        #[doc = ""]
        #[doc = " @note The linesize parameters have the type ptrdiff_t here, while they are"]
        #[doc = "       int for av_image_fill_linesizes()."]
        pub fn av_image_fill_plane_sizes(
            size: *mut root::size_t,
            pix_fmt: root::AVPixelFormat,
            height: ::std::os::raw::c_int,
            linesizes: *const isize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Fill plane data pointers for an image with pixel format pix_fmt and"]
        #[doc = " height height."]
        #[doc = ""]
        #[doc = " @param data pointers array to be filled with the pointer for each image plane"]
        #[doc = " @param ptr the pointer to a buffer which will contain the image"]
        #[doc = " @param linesizes the array containing the linesize for each"]
        #[doc = " plane, should be filled by av_image_fill_linesizes()"]
        #[doc = " @return the size in bytes required for the image buffer, a negative"]
        #[doc = " error code in case of failure"]
        pub fn av_image_fill_pointers(
            data: *mut *mut u8,
            pix_fmt: root::AVPixelFormat,
            height: ::std::os::raw::c_int,
            ptr: *mut u8,
            linesizes: *const ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Allocate an image with size w and h and pixel format pix_fmt, and"]
        #[doc = " fill pointers and linesizes accordingly."]
        #[doc = " The allocated image buffer has to be freed by using"]
        #[doc = " av_freep(&pointers[0])."]
        #[doc = ""]
        #[doc = " @param align the value to use for buffer size alignment"]
        #[doc = " @return the size in bytes required for the image buffer, a negative"]
        #[doc = " error code in case of failure"]
        pub fn av_image_alloc(
            pointers: *mut *mut u8,
            linesizes: *mut ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            pix_fmt: root::AVPixelFormat,
            align: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Copy image plane from src to dst."]
        #[doc = " That is, copy \"height\" number of lines of \"bytewidth\" bytes each."]
        #[doc = " The first byte of each successive line is separated by *_linesize"]
        #[doc = " bytes."]
        #[doc = ""]
        #[doc = " bytewidth must be contained by both absolute values of dst_linesize"]
        #[doc = " and src_linesize, otherwise the function behavior is undefined."]
        #[doc = ""]
        #[doc = " @param dst_linesize linesize for the image plane in dst"]
        #[doc = " @param src_linesize linesize for the image plane in src"]
        pub fn av_image_copy_plane(
            dst: *mut u8,
            dst_linesize: ::std::os::raw::c_int,
            src: *const u8,
            src_linesize: ::std::os::raw::c_int,
            bytewidth: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Copy image data located in uncacheable (e.g. GPU mapped) memory. Where"]
        #[doc = " available, this function will use special functionality for reading from such"]
        #[doc = " memory, which may result in greatly improved performance compared to plain"]
        #[doc = " av_image_copy_plane()."]
        #[doc = ""]
        #[doc = " bytewidth must be contained by both absolute values of dst_linesize"]
        #[doc = " and src_linesize, otherwise the function behavior is undefined."]
        #[doc = ""]
        #[doc = " @note The linesize parameters have the type ptrdiff_t here, while they are"]
        #[doc = "       int for av_image_copy_plane()."]
        #[doc = " @note On x86, the linesizes currently need to be aligned to the cacheline"]
        #[doc = "       size (i.e. 64) to get improved performance."]
        pub fn av_image_copy_plane_uc_from(
            dst: *mut u8,
            dst_linesize: isize,
            src: *const u8,
            src_linesize: isize,
            bytewidth: isize,
            height: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Copy image in src_data to dst_data."]
        #[doc = ""]
        #[doc = " @param dst_linesizes linesizes for the image in dst_data"]
        #[doc = " @param src_linesizes linesizes for the image in src_data"]
        pub fn av_image_copy(
            dst_data: *mut *mut u8,
            dst_linesizes: *mut ::std::os::raw::c_int,
            src_data: *mut *const u8,
            src_linesizes: *const ::std::os::raw::c_int,
            pix_fmt: root::AVPixelFormat,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Copy image data located in uncacheable (e.g. GPU mapped) memory. Where"]
        #[doc = " available, this function will use special functionality for reading from such"]
        #[doc = " memory, which may result in greatly improved performance compared to plain"]
        #[doc = " av_image_copy()."]
        #[doc = ""]
        #[doc = " The data pointers and the linesizes must be aligned to the maximum required"]
        #[doc = " by the CPU architecture."]
        #[doc = ""]
        #[doc = " @note The linesize parameters have the type ptrdiff_t here, while they are"]
        #[doc = "       int for av_image_copy()."]
        #[doc = " @note On x86, the linesizes currently need to be aligned to the cacheline"]
        #[doc = "       size (i.e. 64) to get improved performance."]
        pub fn av_image_copy_uc_from(
            dst_data: *mut *mut u8,
            dst_linesizes: *const isize,
            src_data: *mut *const u8,
            src_linesizes: *const isize,
            pix_fmt: root::AVPixelFormat,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Setup the data pointers and linesizes based on the specified image"]
        #[doc = " parameters and the provided array."]
        #[doc = ""]
        #[doc = " The fields of the given image are filled in by using the src"]
        #[doc = " address which points to the image data buffer. Depending on the"]
        #[doc = " specified pixel format, one or multiple image data pointers and"]
        #[doc = " line sizes will be set.  If a planar format is specified, several"]
        #[doc = " pointers will be set pointing to the different picture planes and"]
        #[doc = " the line sizes of the different planes will be stored in the"]
        #[doc = " lines_sizes array. Call with src == NULL to get the required"]
        #[doc = " size for the src buffer."]
        #[doc = ""]
        #[doc = " To allocate the buffer and fill in the dst_data and dst_linesize in"]
        #[doc = " one call, use av_image_alloc()."]
        #[doc = ""]
        #[doc = " @param dst_data      data pointers to be filled in"]
        #[doc = " @param dst_linesize  linesizes for the image in dst_data to be filled in"]
        #[doc = " @param src           buffer which will contain or contains the actual image data, can be NULL"]
        #[doc = " @param pix_fmt       the pixel format of the image"]
        #[doc = " @param width         the width of the image in pixels"]
        #[doc = " @param height        the height of the image in pixels"]
        #[doc = " @param align         the value used in src for linesize alignment"]
        #[doc = " @return the size in bytes required for src, a negative error code"]
        #[doc = " in case of failure"]
        pub fn av_image_fill_arrays(
            dst_data: *mut *mut u8,
            dst_linesize: *mut ::std::os::raw::c_int,
            src: *const u8,
            pix_fmt: root::AVPixelFormat,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            align: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return the size in bytes of the amount of data required to store an"]
        #[doc = " image with the given parameters."]
        #[doc = ""]
        #[doc = " @param pix_fmt  the pixel format of the image"]
        #[doc = " @param width    the width of the image in pixels"]
        #[doc = " @param height   the height of the image in pixels"]
        #[doc = " @param align    the assumed linesize alignment"]
        #[doc = " @return the buffer size in bytes, a negative error code in case of failure"]
        pub fn av_image_get_buffer_size(
            pix_fmt: root::AVPixelFormat,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            align: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Copy image data from an image into a buffer."]
        #[doc = ""]
        #[doc = " av_image_get_buffer_size() can be used to compute the required size"]
        #[doc = " for the buffer to fill."]
        #[doc = ""]
        #[doc = " @param dst           a buffer into which picture data will be copied"]
        #[doc = " @param dst_size      the size in bytes of dst"]
        #[doc = " @param src_data      pointers containing the source image data"]
        #[doc = " @param src_linesize  linesizes for the image in src_data"]
        #[doc = " @param pix_fmt       the pixel format of the source image"]
        #[doc = " @param width         the width of the source image in pixels"]
        #[doc = " @param height        the height of the source image in pixels"]
        #[doc = " @param align         the assumed linesize alignment for dst"]
        #[doc = " @return the number of bytes written to dst, or a negative value"]
        #[doc = " (error code) on error"]
        pub fn av_image_copy_to_buffer(
            dst: *mut u8,
            dst_size: ::std::os::raw::c_int,
            src_data: *const *const u8,
            src_linesize: *const ::std::os::raw::c_int,
            pix_fmt: root::AVPixelFormat,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            align: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Check if the given dimension of an image is valid, meaning that all"]
        #[doc = " bytes of the image can be addressed with a signed int."]
        #[doc = ""]
        #[doc = " @param w the width of the picture"]
        #[doc = " @param h the height of the picture"]
        #[doc = " @param log_offset the offset to sum to the log level for logging with log_ctx"]
        #[doc = " @param log_ctx the parent logging context, it may be NULL"]
        #[doc = " @return >= 0 if valid, a negative error code otherwise"]
        pub fn av_image_check_size(
            w: ::std::os::raw::c_uint,
            h: ::std::os::raw::c_uint,
            log_offset: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Check if the given dimension of an image is valid, meaning that all"]
        #[doc = " bytes of a plane of an image with the specified pix_fmt can be addressed"]
        #[doc = " with a signed int."]
        #[doc = ""]
        #[doc = " @param w the width of the picture"]
        #[doc = " @param h the height of the picture"]
        #[doc = " @param max_pixels the maximum number of pixels the user wants to accept"]
        #[doc = " @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown."]
        #[doc = " @param log_offset the offset to sum to the log level for logging with log_ctx"]
        #[doc = " @param log_ctx the parent logging context, it may be NULL"]
        #[doc = " @return >= 0 if valid, a negative error code otherwise"]
        pub fn av_image_check_size2(
            w: ::std::os::raw::c_uint,
            h: ::std::os::raw::c_uint,
            max_pixels: i64,
            pix_fmt: root::AVPixelFormat,
            log_offset: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Check if the given sample aspect ratio of an image is valid."]
        #[doc = ""]
        #[doc = " It is considered invalid if the denominator is 0 or if applying the ratio"]
        #[doc = " to the image size would make the smaller dimension less than 1. If the"]
        #[doc = " sar numerator is 0, it is considered unknown and will return as valid."]
        #[doc = ""]
        #[doc = " @param w width of the image"]
        #[doc = " @param h height of the image"]
        #[doc = " @param sar sample aspect ratio of the image"]
        #[doc = " @return 0 if valid, a negative AVERROR code otherwise"]
        pub fn av_image_check_sar(
            w: ::std::os::raw::c_uint,
            h: ::std::os::raw::c_uint,
            sar: root::AVRational,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Overwrite the image data with black. This is suitable for filling a"]
        #[doc = " sub-rectangle of an image, meaning the padding between the right most pixel"]
        #[doc = " and the left most pixel on the next line will not be overwritten. For some"]
        #[doc = " formats, the image size might be rounded up due to inherent alignment."]
        #[doc = ""]
        #[doc = " If the pixel format has alpha, the alpha is cleared to opaque."]
        #[doc = ""]
        #[doc = " This can return an error if the pixel format is not supported. Normally, all"]
        #[doc = " non-hwaccel pixel formats should be supported."]
        #[doc = ""]
        #[doc = " Passing NULL for dst_data is allowed. Then the function returns whether the"]
        #[doc = " operation would have succeeded. (It can return an error if the pix_fmt is"]
        #[doc = " not supported.)"]
        #[doc = ""]
        #[doc = " @param dst_data      data pointers to destination image"]
        #[doc = " @param dst_linesize  linesizes for the destination image"]
        #[doc = " @param pix_fmt       the pixel format of the image"]
        #[doc = " @param range         the color range of the image (important for colorspaces such as YUV)"]
        #[doc = " @param width         the width of the image in pixels"]
        #[doc = " @param height        the height of the image in pixels"]
        #[doc = " @return 0 if the image data was cleared, a negative AVERROR code otherwise"]
        pub fn av_image_fill_black(
            dst_data: *mut *mut u8,
            dst_linesize: *const isize,
            pix_fmt: root::AVPixelFormat,
            range: root::AVColorRange,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    pub const AVVideoEncParamsType_AV_VIDEO_ENC_PARAMS_NONE: root::AVVideoEncParamsType = -1;
    #[doc = " VP9 stores:"]
    #[doc = " - per-frame base (luma AC) quantizer index, exported as AVVideoEncParams.qp"]
    #[doc = " - deltas for luma DC, chroma AC and chroma DC, exported in the"]
    #[doc = "   corresponding entries in AVVideoEncParams.delta_qp"]
    #[doc = " - per-segment delta, exported as for each block as AVVideoBlockParams.delta_qp"]
    #[doc = ""]
    #[doc = " To compute the resulting quantizer index for a block:"]
    #[doc = " - for luma AC, add the base qp and the per-block delta_qp, saturating to"]
    #[doc = "   unsigned 8-bit."]
    #[doc = " - for luma DC and chroma AC/DC, add the corresponding"]
    #[doc = "   AVVideoBlockParams.delta_qp to the luma AC index, again saturating to"]
    #[doc = "   unsigned 8-bit."]
    pub const AVVideoEncParamsType_AV_VIDEO_ENC_PARAMS_VP9: root::AVVideoEncParamsType = 0;
    #[doc = " H.264 stores:"]
    #[doc = " - in PPS (per-picture):"]
    #[doc = "   * initial QP_Y (luma) value, exported as AVVideoEncParams.qp"]
    #[doc = "   * delta(s) for chroma QP values (same for both, or each separately),"]
    #[doc = "     exported as in the corresponding entries in AVVideoEncParams.delta_qp"]
    #[doc = " - per-slice QP delta, not exported directly, added to the per-MB value"]
    #[doc = " - per-MB delta; not exported directly; the final per-MB quantizer"]
    #[doc = "   parameter - QP_Y - minus the value in AVVideoEncParams.qp is exported"]
    #[doc = "   as AVVideoBlockParams.qp_delta."]
    pub const AVVideoEncParamsType_AV_VIDEO_ENC_PARAMS_H264: root::AVVideoEncParamsType = 1;
    #[doc = " H.264 stores:"]
    #[doc = " - in PPS (per-picture):"]
    #[doc = "   * initial QP_Y (luma) value, exported as AVVideoEncParams.qp"]
    #[doc = "   * delta(s) for chroma QP values (same for both, or each separately),"]
    #[doc = "     exported as in the corresponding entries in AVVideoEncParams.delta_qp"]
    #[doc = " - per-slice QP delta, not exported directly, added to the per-MB value"]
    #[doc = " - per-MB delta; not exported directly; the final per-MB quantizer"]
    #[doc = "   parameter - QP_Y - minus the value in AVVideoEncParams.qp is exported"]
    #[doc = "   as AVVideoBlockParams.qp_delta."]
    pub const AVVideoEncParamsType_AV_VIDEO_ENC_PARAMS_MPEG2: root::AVVideoEncParamsType = 2;
    pub type AVVideoEncParamsType = ::std::os::raw::c_int;
    #[doc = " Video encoding parameters for a given frame. This struct is allocated along"]
    #[doc = " with an optional array of per-block AVVideoBlockParams descriptors."]
    #[doc = " Must be allocated with av_video_enc_params_alloc()."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVVideoEncParams {
        #[doc = " Number of blocks in the array."]
        #[doc = ""]
        #[doc = " May be 0, in which case no per-block information is present. In this case"]
        #[doc = " the values of blocks_offset / block_size are unspecified and should not"]
        #[doc = " be accessed."]
        pub nb_blocks: ::std::os::raw::c_uint,
        #[doc = " Offset in bytes from the beginning of this structure at which the array"]
        #[doc = " of blocks starts."]
        pub blocks_offset: root::size_t,
        pub block_size: root::size_t,
        #[doc = " Type of the parameters (the codec they are used with)."]
        pub type_: root::AVVideoEncParamsType,
        #[doc = " Base quantisation parameter for the frame. The final quantiser for a"]
        #[doc = " given block in a given plane is obtained from this value, possibly"]
        #[doc = " combined with {@code delta_qp} and the per-block delta in a manner"]
        #[doc = " documented for each type."]
        pub qp: i32,
        #[doc = " Quantisation parameter offset from the base (per-frame) qp for a given"]
        #[doc = " plane (first index) and AC/DC coefficients (second index)."]
        pub delta_qp: [[i32; 2usize]; 4usize],
    }
    impl Default for AVVideoEncParams {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = " Data structure for storing block-level encoding information."]
    #[doc = " It is allocated as a part of AVVideoEncParams and should be retrieved with"]
    #[doc = " av_video_enc_params_block()."]
    #[doc = ""]
    #[doc = " sizeof(AVVideoBlockParams) is not a part of the ABI and new fields may be"]
    #[doc = " added to it."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVVideoBlockParams {
        #[doc = " Distance in luma pixels from the top-left corner of the visible frame"]
        #[doc = " to the top-left corner of the block."]
        #[doc = " Can be negative if top/right padding is present on the coded frame."]
        pub src_x: ::std::os::raw::c_int,
        #[doc = " Distance in luma pixels from the top-left corner of the visible frame"]
        #[doc = " to the top-left corner of the block."]
        #[doc = " Can be negative if top/right padding is present on the coded frame."]
        pub src_y: ::std::os::raw::c_int,
        #[doc = " Width and height of the block in luma pixels."]
        pub w: ::std::os::raw::c_int,
        #[doc = " Width and height of the block in luma pixels."]
        pub h: ::std::os::raw::c_int,
        #[doc = " Difference between this block's final quantization parameter and the"]
        #[doc = " corresponding per-frame value."]
        pub delta_qp: i32,
    }
    extern "C" {
        #[doc = " Allocates memory for AVVideoEncParams of the given type, plus an array of"]
        #[doc = " {@code nb_blocks} AVVideoBlockParams and initializes the variables. Can be"]
        #[doc = " freed with a normal av_free() call."]
        #[doc = ""]
        #[doc = " @param out_size if non-NULL, the size in bytes of the resulting data array is"]
        #[doc = " written here."]
        pub fn av_video_enc_params_alloc(
            type_: root::AVVideoEncParamsType,
            nb_blocks: ::std::os::raw::c_uint,
            out_size: *mut root::size_t,
        ) -> *mut root::AVVideoEncParams;
    }
    extern "C" {
        #[doc = " Allocates memory for AVEncodeInfoFrame plus an array of"]
        #[doc = " {@code nb_blocks} AVEncodeInfoBlock in the given AVFrame {@code frame}"]
        #[doc = " as AVFrameSideData of type AV_FRAME_DATA_VIDEO_ENC_PARAMS"]
        #[doc = " and initializes the variables."]
        pub fn av_video_enc_params_create_side_data(
            frame: *mut root::AVFrame,
            type_: root::AVVideoEncParamsType,
            nb_blocks: ::std::os::raw::c_uint,
        ) -> *mut root::AVVideoEncParams;
    }
    pub type clock_t = root::__darwin_clock_t;
    pub type time_t = root::__darwin_time_t;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct timespec {
        pub tv_sec: root::__darwin_time_t,
        pub tv_nsec: ::std::os::raw::c_long,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tm {
        pub tm_sec: ::std::os::raw::c_int,
        pub tm_min: ::std::os::raw::c_int,
        pub tm_hour: ::std::os::raw::c_int,
        pub tm_mday: ::std::os::raw::c_int,
        pub tm_mon: ::std::os::raw::c_int,
        pub tm_year: ::std::os::raw::c_int,
        pub tm_wday: ::std::os::raw::c_int,
        pub tm_yday: ::std::os::raw::c_int,
        pub tm_isdst: ::std::os::raw::c_int,
        pub tm_gmtoff: ::std::os::raw::c_long,
        pub tm_zone: *mut ::std::os::raw::c_char,
    }
    impl Default for tm {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
    }
    extern "C" {
        pub static mut getdate_err: ::std::os::raw::c_int;
    }
    extern "C" {
        pub static mut timezone: ::std::os::raw::c_long;
    }
    extern "C" {
        pub static mut daylight: ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn asctime(arg1: *const root::tm) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn clock() -> root::clock_t;
    }
    extern "C" {
        pub fn ctime(arg1: *const root::time_t) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn difftime(arg1: root::time_t, arg2: root::time_t) -> f64;
    }
    extern "C" {
        pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut root::tm;
    }
    extern "C" {
        pub fn gmtime(arg1: *const root::time_t) -> *mut root::tm;
    }
    extern "C" {
        pub fn localtime(arg1: *const root::time_t) -> *mut root::tm;
    }
    extern "C" {
        pub fn mktime(arg1: *mut root::tm) -> root::time_t;
    }
    extern "C" {
        pub fn strftime(
            arg1: *mut ::std::os::raw::c_char,
            arg2: root::size_t,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const root::tm,
        ) -> root::size_t;
    }
    extern "C" {
        pub fn strptime(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut root::tm,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn time(arg1: *mut root::time_t) -> root::time_t;
    }
    extern "C" {
        pub fn tzset();
    }
    extern "C" {
        pub fn asctime_r(
            arg1: *const root::tm,
            arg2: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn ctime_r(
            arg1: *const root::time_t,
            arg2: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn gmtime_r(arg1: *const root::time_t, arg2: *mut root::tm) -> *mut root::tm;
    }
    extern "C" {
        pub fn localtime_r(arg1: *const root::time_t, arg2: *mut root::tm) -> *mut root::tm;
    }
    extern "C" {
        pub fn posix2time(arg1: root::time_t) -> root::time_t;
    }
    extern "C" {
        pub fn tzsetwall();
    }
    extern "C" {
        pub fn time2posix(arg1: root::time_t) -> root::time_t;
    }
    extern "C" {
        pub fn timelocal(arg1: *mut root::tm) -> root::time_t;
    }
    extern "C" {
        pub fn timegm(arg1: *mut root::tm) -> root::time_t;
    }
    extern "C" {
        pub fn nanosleep(
            __rqtp: *const root::timespec,
            __rmtp: *mut root::timespec,
        ) -> ::std::os::raw::c_int;
    }
    pub const clockid_t__CLOCK_REALTIME: root::clockid_t = 0;
    pub const clockid_t__CLOCK_MONOTONIC: root::clockid_t = 6;
    pub const clockid_t__CLOCK_MONOTONIC_RAW: root::clockid_t = 4;
    pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: root::clockid_t = 5;
    pub const clockid_t__CLOCK_UPTIME_RAW: root::clockid_t = 8;
    pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: root::clockid_t = 9;
    pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: root::clockid_t = 12;
    pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: root::clockid_t = 16;
    pub type clockid_t = ::std::os::raw::c_uint;
    extern "C" {
        pub fn clock_getres(
            __clock_id: root::clockid_t,
            __res: *mut root::timespec,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn clock_gettime(
            __clock_id: root::clockid_t,
            __tp: *mut root::timespec,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn clock_gettime_nsec_np(__clock_id: root::clockid_t) -> root::__uint64_t;
    }
    extern "C" {
        pub fn clock_settime(
            __clock_id: root::clockid_t,
            __tp: *const root::timespec,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn timespec_get(
            ts: *mut root::timespec,
            base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Parse str and store the parsed ratio in q."]
        #[doc = ""]
        #[doc = " Note that a ratio with infinite (1/0) or negative value is"]
        #[doc = " considered valid, so you should check on the returned value if you"]
        #[doc = " want to exclude those values."]
        #[doc = ""]
        #[doc = " The undefined value can be expressed using the \"0:0\" string."]
        #[doc = ""]
        #[doc = " @param[in,out] q pointer to the AVRational which will contain the ratio"]
        #[doc = " @param[in] str the string to parse: it has to be a string in the format"]
        #[doc = " num:den, a float number or an expression"]
        #[doc = " @param[in] max the maximum allowed numerator and denominator"]
        #[doc = " @param[in] log_offset log level offset which is applied to the log"]
        #[doc = " level of log_ctx"]
        #[doc = " @param[in] log_ctx parent logging context"]
        #[doc = " @return >= 0 on success, a negative error code otherwise"]
        pub fn av_parse_ratio(
            q: *mut root::AVRational,
            str_: *const ::std::os::raw::c_char,
            max: ::std::os::raw::c_int,
            log_offset: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Parse str and put in width_ptr and height_ptr the detected values."]
        #[doc = ""]
        #[doc = " @param[in,out] width_ptr pointer to the variable which will contain the detected"]
        #[doc = " width value"]
        #[doc = " @param[in,out] height_ptr pointer to the variable which will contain the detected"]
        #[doc = " height value"]
        #[doc = " @param[in] str the string to parse: it has to be a string in the format"]
        #[doc = " width x height or a valid video size abbreviation."]
        #[doc = " @return >= 0 on success, a negative error code otherwise"]
        pub fn av_parse_video_size(
            width_ptr: *mut ::std::os::raw::c_int,
            height_ptr: *mut ::std::os::raw::c_int,
            str_: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Parse str and store the detected values in *rate."]
        #[doc = ""]
        #[doc = " @param[in,out] rate pointer to the AVRational which will contain the detected"]
        #[doc = " frame rate"]
        #[doc = " @param[in] str the string to parse: it has to be a string in the format"]
        #[doc = " rate_num / rate_den, a float number or a valid video rate abbreviation"]
        #[doc = " @return >= 0 on success, a negative error code otherwise"]
        pub fn av_parse_video_rate(
            rate: *mut root::AVRational,
            str_: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Put the RGBA values that correspond to color_string in rgba_color."]
        #[doc = ""]
        #[doc = " @param color_string a string specifying a color. It can be the name of"]
        #[doc = " a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,"]
        #[doc = " possibly followed by \"@\" and a string representing the alpha"]
        #[doc = " component."]
        #[doc = " The alpha component may be a string composed by \"0x\" followed by an"]
        #[doc = " hexadecimal number or a decimal number between 0.0 and 1.0, which"]
        #[doc = " represents the opacity value (0x00/0.0 means completely transparent,"]
        #[doc = " 0xff/1.0 completely opaque)."]
        #[doc = " If the alpha component is not specified then 0xff is assumed."]
        #[doc = " The string \"random\" will result in a random color."]
        #[doc = " @param slen length of the initial part of color_string containing the"]
        #[doc = " color. It can be set to -1 if color_string is a null terminated string"]
        #[doc = " containing nothing else than the color."]
        #[doc = " @return >= 0 in case of success, a negative value in case of"]
        #[doc = " failure (for example if color_string cannot be parsed)."]
        pub fn av_parse_color(
            rgba_color: *mut u8,
            color_string: *const ::std::os::raw::c_char,
            slen: ::std::os::raw::c_int,
            log_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the name of a color from the internal table of hard-coded named"]
        #[doc = " colors."]
        #[doc = ""]
        #[doc = " This function is meant to enumerate the color names recognized by"]
        #[doc = " av_parse_color()."]
        #[doc = ""]
        #[doc = " @param color_idx index of the requested color, starting from 0"]
        #[doc = " @param rgbp      if not NULL, will point to a 3-elements array with the color value in RGB"]
        #[doc = " @return the color name string or NULL if color_idx is not in the array"]
        pub fn av_get_known_color_name(
            color_idx: ::std::os::raw::c_int,
            rgb: *mut *const u8,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Parse timestr and return in *time a corresponding number of"]
        #[doc = " microseconds."]
        #[doc = ""]
        #[doc = " @param timeval puts here the number of microseconds corresponding"]
        #[doc = " to the string in timestr. If the string represents a duration, it"]
        #[doc = " is the number of microseconds contained in the time interval.  If"]
        #[doc = " the string is a date, is the number of microseconds since 1st of"]
        #[doc = " January, 1970 up to the time of the parsed date.  If timestr cannot"]
        #[doc = " be successfully parsed, set *time to INT64_MIN."]
        #[doc = ""]
        #[doc = " @param timestr a string representing a date or a duration."]
        #[doc = " - If a date the syntax is:"]
        #[doc = " @code"]
        #[doc = " [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]"]
        #[doc = " now"]
        #[doc = " @endcode"]
        #[doc = " If the value is \"now\" it takes the current time."]
        #[doc = " Time is local time unless Z is appended, in which case it is"]
        #[doc = " interpreted as UTC."]
        #[doc = " If the year-month-day part is not specified it takes the current"]
        #[doc = " year-month-day."]
        #[doc = " - If a duration the syntax is:"]
        #[doc = " @code"]
        #[doc = " [-][HH:]MM:SS[.m...]"]
        #[doc = " [-]S+[.m...]"]
        #[doc = " @endcode"]
        #[doc = " @param duration flag which tells how to interpret timestr, if not"]
        #[doc = " zero timestr is interpreted as a duration, otherwise as a date"]
        #[doc = " @return >= 0 in case of success, a negative value corresponding to an"]
        #[doc = " AVERROR code otherwise"]
        pub fn av_parse_time(
            timeval: *mut i64,
            timestr: *const ::std::os::raw::c_char,
            duration: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Attempt to find a specific tag in a URL."]
        #[doc = ""]
        #[doc = " syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done."]
        #[doc = " Return 1 if found."]
        pub fn av_find_info_tag(
            arg: *mut ::std::os::raw::c_char,
            arg_size: ::std::os::raw::c_int,
            tag1: *const ::std::os::raw::c_char,
            info: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Simplified version of strptime"]
        #[doc = ""]
        #[doc = " Parse the input string p according to the format string fmt and"]
        #[doc = " store its results in the structure dt."]
        #[doc = " This implementation supports only a subset of the formats supported"]
        #[doc = " by the standard strptime()."]
        #[doc = ""]
        #[doc = " The supported input field descriptors are listed below."]
        #[doc = " - %H: the hour as a decimal number, using a 24-hour clock, in the"]
        #[doc = "   range '00' through '23'"]
        #[doc = " - %J: hours as a decimal number, in the range '0' through INT_MAX"]
        #[doc = " - %M: the minute as a decimal number, using a 24-hour clock, in the"]
        #[doc = "   range '00' through '59'"]
        #[doc = " - %S: the second as a decimal number, using a 24-hour clock, in the"]
        #[doc = "   range '00' through '59'"]
        #[doc = " - %Y: the year as a decimal number, using the Gregorian calendar"]
        #[doc = " - %m: the month as a decimal number, in the range '1' through '12'"]
        #[doc = " - %d: the day of the month as a decimal number, in the range '1'"]
        #[doc = "   through '31'"]
        #[doc = " - %T: alias for '%H:%M:%S'"]
        #[doc = " - %%: a literal '%'"]
        #[doc = ""]
        #[doc = " @return a pointer to the first character not processed in this function"]
        #[doc = "         call. In case the input string contains more characters than"]
        #[doc = "         required by the format string the return value points right after"]
        #[doc = "         the last consumed input character. In case the whole input string"]
        #[doc = "         is consumed the return value points to the null byte at the end of"]
        #[doc = "         the string. On failure NULL is returned."]
        pub fn av_small_strptime(
            p: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            dt: *mut root::tm,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Convert the decomposed UTC time in tm to a time_t value."]
        pub fn av_timegm(tm: *mut root::tm) -> root::time_t;
    }
    extern "C" {
        #[doc = " @defgroup lavu_ripemd RIPEMD"]
        #[doc = " @ingroup lavu_hash"]
        #[doc = " RIPEMD hash function implementation."]
        #[doc = ""]
        #[doc = " @{"]
        pub static av_ripemd_size: ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVRIPEMD {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVRIPEMD context."]
        pub fn av_ripemd_alloc() -> *mut root::AVRIPEMD;
    }
    extern "C" {
        #[doc = " Initialize RIPEMD hashing."]
        #[doc = ""]
        #[doc = " @param context pointer to the function context (of size av_ripemd_size)"]
        #[doc = " @param bits    number of bits in digest (128, 160, 256 or 320 bits)"]
        #[doc = " @return        zero if initialization succeeded, -1 otherwise"]
        pub fn av_ripemd_init(
            context: *mut root::AVRIPEMD,
            bits: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Update hash value."]
        #[doc = ""]
        #[doc = " @param context hash function context"]
        #[doc = " @param data    input data to update hash with"]
        #[doc = " @param len     input data length"]
        pub fn av_ripemd_update(context: *mut root::AVRIPEMD, data: *const u8, len: root::size_t);
    }
    extern "C" {
        #[doc = " Finish hashing and output digest value."]
        #[doc = ""]
        #[doc = " @param context hash function context"]
        #[doc = " @param digest  buffer where output digest value is stored"]
        pub fn av_ripemd_final(context: *mut root::AVRIPEMD, digest: *mut u8);
    }
    extern "C" {
        #[doc = " Return non-zero if pfx is a prefix of str. If it is, *ptr is set to"]
        #[doc = " the address of the first character in str after the prefix."]
        #[doc = ""]
        #[doc = " @param str input string"]
        #[doc = " @param pfx prefix to test"]
        #[doc = " @param ptr updated if the prefix is matched inside str"]
        #[doc = " @return non-zero if the prefix matches, zero otherwise"]
        pub fn av_strstart(
            str_: *const ::std::os::raw::c_char,
            pfx: *const ::std::os::raw::c_char,
            ptr: *mut *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return non-zero if pfx is a prefix of str independent of case. If"]
        #[doc = " it is, *ptr is set to the address of the first character in str"]
        #[doc = " after the prefix."]
        #[doc = ""]
        #[doc = " @param str input string"]
        #[doc = " @param pfx prefix to test"]
        #[doc = " @param ptr updated if the prefix is matched inside str"]
        #[doc = " @return non-zero if the prefix matches, zero otherwise"]
        pub fn av_stristart(
            str_: *const ::std::os::raw::c_char,
            pfx: *const ::std::os::raw::c_char,
            ptr: *mut *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Locate the first case-independent occurrence in the string haystack"]
        #[doc = " of the string needle.  A zero-length string needle is considered to"]
        #[doc = " match at the start of haystack."]
        #[doc = ""]
        #[doc = " This function is a case-insensitive version of the standard strstr()."]
        #[doc = ""]
        #[doc = " @param haystack string to search in"]
        #[doc = " @param needle   string to search for"]
        #[doc = " @return         pointer to the located match within haystack"]
        #[doc = "                 or a null pointer if no match"]
        pub fn av_stristr(
            haystack: *const ::std::os::raw::c_char,
            needle: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Locate the first occurrence of the string needle in the string haystack"]
        #[doc = " where not more than hay_length characters are searched. A zero-length"]
        #[doc = " string needle is considered to match at the start of haystack."]
        #[doc = ""]
        #[doc = " This function is a length-limited version of the standard strstr()."]
        #[doc = ""]
        #[doc = " @param haystack   string to search in"]
        #[doc = " @param needle     string to search for"]
        #[doc = " @param hay_length length of string to search in"]
        #[doc = " @return           pointer to the located match within haystack"]
        #[doc = "                   or a null pointer if no match"]
        pub fn av_strnstr(
            haystack: *const ::std::os::raw::c_char,
            needle: *const ::std::os::raw::c_char,
            hay_length: root::size_t,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Copy the string src to dst, but no more than size - 1 bytes, and"]
        #[doc = " null-terminate dst."]
        #[doc = ""]
        #[doc = " This function is the same as BSD strlcpy()."]
        #[doc = ""]
        #[doc = " @param dst destination buffer"]
        #[doc = " @param src source string"]
        #[doc = " @param size size of destination buffer"]
        #[doc = " @return the length of src"]
        #[doc = ""]
        #[doc = " @warning since the return value is the length of src, src absolutely"]
        #[doc = " _must_ be a properly 0-terminated string, otherwise this will read beyond"]
        #[doc = " the end of the buffer and possibly crash."]
        pub fn av_strlcpy(
            dst: *mut ::std::os::raw::c_char,
            src: *const ::std::os::raw::c_char,
            size: root::size_t,
        ) -> root::size_t;
    }
    extern "C" {
        #[doc = " Append the string src to the string dst, but to a total length of"]
        #[doc = " no more than size - 1 bytes, and null-terminate dst."]
        #[doc = ""]
        #[doc = " This function is similar to BSD strlcat(), but differs when"]
        #[doc = " size <= strlen(dst)."]
        #[doc = ""]
        #[doc = " @param dst destination buffer"]
        #[doc = " @param src source string"]
        #[doc = " @param size size of destination buffer"]
        #[doc = " @return the total length of src and dst"]
        #[doc = ""]
        #[doc = " @warning since the return value use the length of src and dst, these"]
        #[doc = " absolutely _must_ be a properly 0-terminated strings, otherwise this"]
        #[doc = " will read beyond the end of the buffer and possibly crash."]
        pub fn av_strlcat(
            dst: *mut ::std::os::raw::c_char,
            src: *const ::std::os::raw::c_char,
            size: root::size_t,
        ) -> root::size_t;
    }
    extern "C" {
        #[doc = " Append output to a string, according to a format. Never write out of"]
        #[doc = " the destination buffer, and always put a terminating 0 within"]
        #[doc = " the buffer."]
        #[doc = " @param dst destination buffer (string to which the output is"]
        #[doc = "  appended)"]
        #[doc = " @param size total size of the destination buffer"]
        #[doc = " @param fmt printf-compatible format string, specifying how the"]
        #[doc = "  following parameters are used"]
        #[doc = " @return the length of the string that would have been generated"]
        #[doc = "  if enough space had been available"]
        pub fn av_strlcatf(
            dst: *mut ::std::os::raw::c_char,
            size: root::size_t,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> root::size_t;
    }
    extern "C" {
        #[doc = " Print arguments following specified format into a large enough auto"]
        #[doc = " allocated buffer. It is similar to GNU asprintf()."]
        #[doc = " @param fmt printf-compatible format string, specifying how the"]
        #[doc = "            following parameters are used."]
        #[doc = " @return the allocated string"]
        #[doc = " @note You have to free the string yourself with av_free()."]
        pub fn av_asprintf(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Convert a number to an av_malloced string."]
        #[doc = " @deprecated  use av_asprintf() with \"%f\" or a more specific format"]
        pub fn av_d2str(d: f64) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Unescape the given string until a non escaped terminating char,"]
        #[doc = " and return the token corresponding to the unescaped string."]
        #[doc = ""]
        #[doc = " The normal \\ and ' escaping is supported. Leading and trailing"]
        #[doc = " whitespaces are removed, unless they are escaped with '\\' or are"]
        #[doc = " enclosed between ''."]
        #[doc = ""]
        #[doc = " @param buf the buffer to parse, buf will be updated to point to the"]
        #[doc = " terminating char"]
        #[doc = " @param term a 0-terminated list of terminating chars"]
        #[doc = " @return the malloced unescaped string, which must be av_freed by"]
        #[doc = " the user, NULL in case of allocation failure"]
        pub fn av_get_token(
            buf: *mut *const ::std::os::raw::c_char,
            term: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Split the string into several tokens which can be accessed by"]
        #[doc = " successive calls to av_strtok()."]
        #[doc = ""]
        #[doc = " A token is defined as a sequence of characters not belonging to the"]
        #[doc = " set specified in delim."]
        #[doc = ""]
        #[doc = " On the first call to av_strtok(), s should point to the string to"]
        #[doc = " parse, and the value of saveptr is ignored. In subsequent calls, s"]
        #[doc = " should be NULL, and saveptr should be unchanged since the previous"]
        #[doc = " call."]
        #[doc = ""]
        #[doc = " This function is similar to strtok_r() defined in POSIX.1."]
        #[doc = ""]
        #[doc = " @param s the string to parse, may be NULL"]
        #[doc = " @param delim 0-terminated list of token delimiters, must be non-NULL"]
        #[doc = " @param saveptr user-provided pointer which points to stored"]
        #[doc = " information necessary for av_strtok() to continue scanning the same"]
        #[doc = " string. saveptr is updated to point to the next character after the"]
        #[doc = " first delimiter found, or to NULL if the string was terminated"]
        #[doc = " @return the found token, or NULL when no token is found"]
        pub fn av_strtok(
            s: *mut ::std::os::raw::c_char,
            delim: *const ::std::os::raw::c_char,
            saveptr: *mut *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Locale-independent case-insensitive compare."]
        #[doc = " @note This means only ASCII-range characters are case-insensitive"]
        pub fn av_strcasecmp(
            a: *const ::std::os::raw::c_char,
            b: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Locale-independent case-insensitive compare."]
        #[doc = " @note This means only ASCII-range characters are case-insensitive"]
        pub fn av_strncasecmp(
            a: *const ::std::os::raw::c_char,
            b: *const ::std::os::raw::c_char,
            n: root::size_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Locale-independent strings replace."]
        #[doc = " @note This means only ASCII-range characters are replace"]
        pub fn av_strireplace(
            str_: *const ::std::os::raw::c_char,
            from: *const ::std::os::raw::c_char,
            to: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Thread safe basename."]
        #[doc = " @param path the string to parse, on DOS both \\ and / are considered separators."]
        #[doc = " @return pointer to the basename substring."]
        #[doc = " If path does not contain a slash, the function returns a copy of path."]
        #[doc = " If path is a NULL pointer or points to an empty string, a pointer"]
        #[doc = " to a string \".\" is returned."]
        pub fn av_basename(path: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Thread safe dirname."]
        #[doc = " @param path the string to parse, on DOS both \\ and / are considered separators."]
        #[doc = " @return A pointer to a string that's the parent directory of path."]
        #[doc = " If path is a NULL pointer or points to an empty string, a pointer"]
        #[doc = " to a string \".\" is returned."]
        #[doc = " @note the function may modify the contents of the path, so copies should be passed."]
        pub fn av_dirname(path: *mut ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Match instances of a name in a comma-separated list of names."]
        #[doc = " List entries are checked from the start to the end of the names list,"]
        #[doc = " the first match ends further processing. If an entry prefixed with '-'"]
        #[doc = " matches, then 0 is returned. The \"ALL\" list entry is considered to"]
        #[doc = " match all names."]
        #[doc = ""]
        #[doc = " @param name  Name to look for."]
        #[doc = " @param names List of names."]
        #[doc = " @return 1 on match, 0 otherwise."]
        pub fn av_match_name(
            name: *const ::std::os::raw::c_char,
            names: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Append path component to the existing path."]
        #[doc = " Path separator '/' is placed between when needed."]
        #[doc = " Resulting string have to be freed with av_free()."]
        #[doc = " @param path      base path"]
        #[doc = " @param component component to be appended"]
        #[doc = " @return new path or NULL on error."]
        pub fn av_append_path_component(
            path: *const ::std::os::raw::c_char,
            component: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    #[doc = "< Use auto-selected escaping mode."]
    pub const AVEscapeMode_AV_ESCAPE_MODE_AUTO: root::AVEscapeMode = 0;
    #[doc = "< Use backslash escaping."]
    pub const AVEscapeMode_AV_ESCAPE_MODE_BACKSLASH: root::AVEscapeMode = 1;
    #[doc = "< Use single-quote escaping."]
    pub const AVEscapeMode_AV_ESCAPE_MODE_QUOTE: root::AVEscapeMode = 2;
    #[doc = "< Use XML non-markup character data escaping."]
    pub const AVEscapeMode_AV_ESCAPE_MODE_XML: root::AVEscapeMode = 3;
    pub type AVEscapeMode = ::std::os::raw::c_uint;
    extern "C" {
        #[doc = " Escape string in src, and put the escaped string in an allocated"]
        #[doc = " string in *dst, which must be freed with av_free()."]
        #[doc = ""]
        #[doc = " @param dst           pointer where an allocated string is put"]
        #[doc = " @param src           string to escape, must be non-NULL"]
        #[doc = " @param special_chars string containing the special characters which"]
        #[doc = "                      need to be escaped, can be NULL"]
        #[doc = " @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros."]
        #[doc = "                      Any unknown value for mode will be considered equivalent to"]
        #[doc = "                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without"]
        #[doc = "                      notice."]
        #[doc = " @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros"]
        #[doc = " @return the length of the allocated string, or a negative error code in case of error"]
        #[doc = " @see av_bprint_escape()"]
        pub fn av_escape(
            dst: *mut *mut ::std::os::raw::c_char,
            src: *const ::std::os::raw::c_char,
            special_chars: *const ::std::os::raw::c_char,
            mode: root::AVEscapeMode,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Read and decode a single UTF-8 code point (character) from the"]
        #[doc = " buffer in *buf, and update *buf to point to the next byte to"]
        #[doc = " decode."]
        #[doc = ""]
        #[doc = " In case of an invalid byte sequence, the pointer will be updated to"]
        #[doc = " the next byte after the invalid sequence and the function will"]
        #[doc = " return an error code."]
        #[doc = ""]
        #[doc = " Depending on the specified flags, the function will also fail in"]
        #[doc = " case the decoded code point does not belong to a valid range."]
        #[doc = ""]
        #[doc = " @note For speed-relevant code a carefully implemented use of"]
        #[doc = " GET_UTF8() may be preferred."]
        #[doc = ""]
        #[doc = " @param codep   pointer used to return the parsed code in case of success."]
        #[doc = "                The value in *codep is set even in case the range check fails."]
        #[doc = " @param bufp    pointer to the address the first byte of the sequence"]
        #[doc = "                to decode, updated by the function to point to the"]
        #[doc = "                byte next after the decoded sequence"]
        #[doc = " @param buf_end pointer to the end of the buffer, points to the next"]
        #[doc = "                byte past the last in the buffer. This is used to"]
        #[doc = "                avoid buffer overreads (in case of an unfinished"]
        #[doc = "                UTF-8 sequence towards the end of the buffer)."]
        #[doc = " @param flags   a collection of AV_UTF8_FLAG_* flags"]
        #[doc = " @return >= 0 in case a sequence was successfully read, a negative"]
        #[doc = " value in case of invalid sequence"]
        pub fn av_utf8_decode(
            codep: *mut i32,
            bufp: *mut *const u8,
            buf_end: *const u8,
            flags: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Check if a name is in a list."]
        #[doc = " @returns 0 if not found, or the 1 based index where it has been found in the"]
        #[doc = "            list."]
        pub fn av_match_list(
            name: *const ::std::os::raw::c_char,
            list: *const ::std::os::raw::c_char,
            separator: ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " See libc sscanf manual for more information."]
        #[doc = " Locale-independent sscanf implementation."]
        pub fn av_sscanf(
            string: *const ::std::os::raw::c_char,
            format: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ff_pad_helper_AVBPrint {
        pub str_: *mut ::std::os::raw::c_char,
        pub len: ::std::os::raw::c_uint,
        pub size: ::std::os::raw::c_uint,
        pub size_max: ::std::os::raw::c_uint,
        pub reserved_internal_buffer: [::std::os::raw::c_char; 1usize],
    }
    impl Default for ff_pad_helper_AVBPrint {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = " Buffer to print data progressively"]
    #[doc = ""]
    #[doc = " The string buffer grows as necessary and is always 0-terminated."]
    #[doc = " The content of the string is never accessed, and thus is"]
    #[doc = " encoding-agnostic and can even hold binary data."]
    #[doc = ""]
    #[doc = " Small buffers are kept in the structure itself, and thus require no"]
    #[doc = " memory allocation at all (unless the contents of the buffer is needed"]
    #[doc = " after the structure goes out of scope). This is almost as lightweight as"]
    #[doc = " declaring a local \"char buf[512]\"."]
    #[doc = ""]
    #[doc = " The length of the string can go beyond the allocated size: the buffer is"]
    #[doc = " then truncated, but the functions still keep account of the actual total"]
    #[doc = " length."]
    #[doc = ""]
    #[doc = " In other words, buf->len can be greater than buf->size and records the"]
    #[doc = " total length of what would have been to the buffer if there had been"]
    #[doc = " enough memory."]
    #[doc = ""]
    #[doc = " Append operations do not need to be tested for failure: if a memory"]
    #[doc = " allocation fails, data stop being appended to the buffer, but the length"]
    #[doc = " is still updated. This situation can be tested with"]
    #[doc = " av_bprint_is_complete()."]
    #[doc = ""]
    #[doc = " The size_max field determines several possible behaviours:"]
    #[doc = ""]
    #[doc = " size_max = -1 (= UINT_MAX) or any large value will let the buffer be"]
    #[doc = " reallocated as necessary, with an amortized linear cost."]
    #[doc = ""]
    #[doc = " size_max = 0 prevents writing anything to the buffer: only the total"]
    #[doc = " length is computed. The write operations can then possibly be repeated in"]
    #[doc = " a buffer with exactly the necessary size"]
    #[doc = " (using size_init = size_max = len + 1)."]
    #[doc = ""]
    #[doc = " size_max = 1 is automatically replaced by the exact size available in the"]
    #[doc = " structure itself, thus ensuring no dynamic memory allocation. The"]
    #[doc = " internal buffer is large enough to hold a reasonable paragraph of text,"]
    #[doc = " such as the current paragraph."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVBPrint {
        pub str_: *mut ::std::os::raw::c_char,
        pub len: ::std::os::raw::c_uint,
        pub size: ::std::os::raw::c_uint,
        pub size_max: ::std::os::raw::c_uint,
        pub reserved_internal_buffer: [::std::os::raw::c_char; 1usize],
        pub reserved_padding: [::std::os::raw::c_char; 1000usize],
    }
    impl Default for AVBPrint {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Init a print buffer."]
        #[doc = ""]
        #[doc = " @param buf        buffer to init"]
        #[doc = " @param size_init  initial size (including the final 0)"]
        #[doc = " @param size_max   maximum size;"]
        #[doc = "                   0 means do not write anything, just count the length;"]
        #[doc = "                   1 is replaced by the maximum value for automatic storage;"]
        #[doc = "                   any large value means that the internal buffer will be"]
        #[doc = "                   reallocated as needed up to that limit; -1 is converted to"]
        #[doc = "                   UINT_MAX, the largest limit possible."]
        #[doc = "                   Check also AV_BPRINT_SIZE_* macros."]
        pub fn av_bprint_init(
            buf: *mut root::AVBPrint,
            size_init: ::std::os::raw::c_uint,
            size_max: ::std::os::raw::c_uint,
        );
    }
    extern "C" {
        #[doc = " Init a print buffer using a pre-existing buffer."]
        #[doc = ""]
        #[doc = " The buffer will not be reallocated."]
        #[doc = ""]
        #[doc = " @param buf     buffer structure to init"]
        #[doc = " @param buffer  byte buffer to use for the string data"]
        #[doc = " @param size    size of buffer"]
        pub fn av_bprint_init_for_buffer(
            buf: *mut root::AVBPrint,
            buffer: *mut ::std::os::raw::c_char,
            size: ::std::os::raw::c_uint,
        );
    }
    extern "C" {
        #[doc = " Append a formatted string to a print buffer."]
        pub fn av_bprintf(buf: *mut root::AVBPrint, fmt: *const ::std::os::raw::c_char, ...);
    }
    extern "C" {
        #[doc = " Append a formatted string to a print buffer."]
        pub fn av_vbprintf(
            buf: *mut root::AVBPrint,
            fmt: *const ::std::os::raw::c_char,
            vl_arg: root::va_list,
        );
    }
    extern "C" {
        #[doc = " Append char c n times to a print buffer."]
        pub fn av_bprint_chars(
            buf: *mut root::AVBPrint,
            c: ::std::os::raw::c_char,
            n: ::std::os::raw::c_uint,
        );
    }
    extern "C" {
        #[doc = " Append data to a print buffer."]
        #[doc = ""]
        #[doc = " param buf  bprint buffer to use"]
        #[doc = " param data pointer to data"]
        #[doc = " param size size of data"]
        pub fn av_bprint_append_data(
            buf: *mut root::AVBPrint,
            data: *const ::std::os::raw::c_char,
            size: ::std::os::raw::c_uint,
        );
    }
    extern "C" {
        #[doc = " Append a formatted date and time to a print buffer."]
        #[doc = ""]
        #[doc = " param buf  bprint buffer to use"]
        #[doc = " param fmt  date and time format string, see strftime()"]
        #[doc = " param tm   broken-down time structure to translate"]
        #[doc = ""]
        #[doc = " @note due to poor design of the standard strftime function, it may"]
        #[doc = " produce poor results if the format string expands to a very long text and"]
        #[doc = " the bprint buffer is near the limit stated by the size_max option."]
        pub fn av_bprint_strftime(
            buf: *mut root::AVBPrint,
            fmt: *const ::std::os::raw::c_char,
            tm: *const root::tm,
        );
    }
    extern "C" {
        #[doc = " Allocate bytes in the buffer for external use."]
        #[doc = ""]
        #[doc = " @param[in]  buf          buffer structure"]
        #[doc = " @param[in]  size         required size"]
        #[doc = " @param[out] mem          pointer to the memory area"]
        #[doc = " @param[out] actual_size  size of the memory area after allocation;"]
        #[doc = "                          can be larger or smaller than size"]
        pub fn av_bprint_get_buffer(
            buf: *mut root::AVBPrint,
            size: ::std::os::raw::c_uint,
            mem: *mut *mut ::std::os::raw::c_uchar,
            actual_size: *mut ::std::os::raw::c_uint,
        );
    }
    extern "C" {
        #[doc = " Reset the string to \"\" but keep internal allocated data."]
        pub fn av_bprint_clear(buf: *mut root::AVBPrint);
    }
    extern "C" {
        #[doc = " Finalize a print buffer."]
        #[doc = ""]
        #[doc = " The print buffer can no longer be used afterwards,"]
        #[doc = " but the len and size fields are still valid."]
        #[doc = ""]
        #[doc = " @arg[out] ret_str  if not NULL, used to return a permanent copy of the"]
        #[doc = "                    buffer contents, or NULL if memory allocation fails;"]
        #[doc = "                    if NULL, the buffer is discarded and freed"]
        #[doc = " @return  0 for success or error code (probably AVERROR(ENOMEM))"]
        pub fn av_bprint_finalize(
            buf: *mut root::AVBPrint,
            ret_str: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Escape the content in src and append it to dstbuf."]
        #[doc = ""]
        #[doc = " @param dstbuf        already inited destination bprint buffer"]
        #[doc = " @param src           string containing the text to escape"]
        #[doc = " @param special_chars string containing the special characters which"]
        #[doc = "                      need to be escaped, can be NULL"]
        #[doc = " @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros."]
        #[doc = "                      Any unknown value for mode will be considered equivalent to"]
        #[doc = "                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without"]
        #[doc = "                      notice."]
        #[doc = " @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros"]
        pub fn av_bprint_escape(
            dstbuf: *mut root::AVBPrint,
            src: *const ::std::os::raw::c_char,
            special_chars: *const ::std::os::raw::c_char,
            mode: root::AVEscapeMode,
            flags: ::std::os::raw::c_int,
        );
    }
    pub const AVHDRPlusOverlapProcessOption_AV_HDR_PLUS_OVERLAP_PROCESS_WEIGHTED_AVERAGING:
        root::AVHDRPlusOverlapProcessOption = 0;
    pub const AVHDRPlusOverlapProcessOption_AV_HDR_PLUS_OVERLAP_PROCESS_LAYERING:
        root::AVHDRPlusOverlapProcessOption = 1;
    #[doc = " Option for overlapping elliptical pixel selectors in an image."]
    pub type AVHDRPlusOverlapProcessOption = ::std::os::raw::c_uint;
    #[doc = " Represents the percentile at a specific percentage in"]
    #[doc = " a distribution."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVHDRPlusPercentile {
        #[doc = " The percentage value corresponding to a specific percentile linearized"]
        #[doc = " RGB value in the processing window in the scene. The value shall be in"]
        #[doc = " the range of 0 to100, inclusive."]
        pub percentage: u8,
        #[doc = " The linearized maxRGB value at a specific percentile in the processing"]
        #[doc = " window in the scene. The value shall be in the range of 0 to 1, inclusive"]
        #[doc = " and in multiples of 0.00001."]
        pub percentile: root::AVRational,
    }
    #[doc = " Color transform parameters at a processing window in a dynamic metadata for"]
    #[doc = " SMPTE 2094-40."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVHDRPlusColorTransformParams {
        #[doc = " The relative x coordinate of the top left pixel of the processing"]
        #[doc = " window. The value shall be in the range of 0 and 1, inclusive and"]
        #[doc = " in multiples of 1/(width of Picture - 1). The value 1 corresponds"]
        #[doc = " to the absolute coordinate of width of Picture - 1. The value for"]
        #[doc = " first processing window shall be 0."]
        pub window_upper_left_corner_x: root::AVRational,
        #[doc = " The relative y coordinate of the top left pixel of the processing"]
        #[doc = " window. The value shall be in the range of 0 and 1, inclusive and"]
        #[doc = " in multiples of 1/(height of Picture - 1). The value 1 corresponds"]
        #[doc = " to the absolute coordinate of height of Picture - 1. The value for"]
        #[doc = " first processing window shall be 0."]
        pub window_upper_left_corner_y: root::AVRational,
        #[doc = " The relative x coordinate of the bottom right pixel of the processing"]
        #[doc = " window. The value shall be in the range of 0 and 1, inclusive and"]
        #[doc = " in multiples of 1/(width of Picture - 1). The value 1 corresponds"]
        #[doc = " to the absolute coordinate of width of Picture - 1. The value for"]
        #[doc = " first processing window shall be 1."]
        pub window_lower_right_corner_x: root::AVRational,
        #[doc = " The relative y coordinate of the bottom right pixel of the processing"]
        #[doc = " window. The value shall be in the range of 0 and 1, inclusive and"]
        #[doc = " in multiples of 1/(height of Picture - 1). The value 1 corresponds"]
        #[doc = " to the absolute coordinate of height of Picture - 1. The value for"]
        #[doc = " first processing window shall be 1."]
        pub window_lower_right_corner_y: root::AVRational,
        #[doc = " The x coordinate of the center position of the concentric internal and"]
        #[doc = " external ellipses of the elliptical pixel selector in the processing"]
        #[doc = " window. The value shall be in the range of 0 to (width of Picture - 1),"]
        #[doc = " inclusive and in multiples of 1 pixel."]
        pub center_of_ellipse_x: u16,
        #[doc = " The y coordinate of the center position of the concentric internal and"]
        #[doc = " external ellipses of the elliptical pixel selector in the processing"]
        #[doc = " window. The value shall be in the range of 0 to (height of Picture - 1),"]
        #[doc = " inclusive and in multiples of 1 pixel."]
        pub center_of_ellipse_y: u16,
        #[doc = " The clockwise rotation angle in degree of arc with respect to the"]
        #[doc = " positive direction of the x-axis of the concentric internal and external"]
        #[doc = " ellipses of the elliptical pixel selector in the processing window. The"]
        #[doc = " value shall be in the range of 0 to 180, inclusive and in multiples of 1."]
        pub rotation_angle: u8,
        #[doc = " The semi-major axis value of the internal ellipse of the elliptical pixel"]
        #[doc = " selector in amount of pixels in the processing window. The value shall be"]
        #[doc = " in the range of 1 to 65535, inclusive and in multiples of 1 pixel."]
        pub semimajor_axis_internal_ellipse: u16,
        #[doc = " The semi-major axis value of the external ellipse of the elliptical pixel"]
        #[doc = " selector in amount of pixels in the processing window. The value"]
        #[doc = " shall not be less than semimajor_axis_internal_ellipse of the current"]
        #[doc = " processing window. The value shall be in the range of 1 to 65535,"]
        #[doc = " inclusive and in multiples of 1 pixel."]
        pub semimajor_axis_external_ellipse: u16,
        #[doc = " The semi-minor axis value of the external ellipse of the elliptical pixel"]
        #[doc = " selector in amount of pixels in the processing window. The value shall be"]
        #[doc = " in the range of 1 to 65535, inclusive and in multiples of 1 pixel."]
        pub semiminor_axis_external_ellipse: u16,
        #[doc = " Overlap process option indicates one of the two methods of combining"]
        #[doc = " rendered pixels in the processing window in an image with at least one"]
        #[doc = " elliptical pixel selector. For overlapping elliptical pixel selectors"]
        #[doc = " in an image, overlap_process_option shall have the same value."]
        pub overlap_process_option: root::AVHDRPlusOverlapProcessOption,
        #[doc = " The maximum of the color components of linearized RGB values in the"]
        #[doc = " processing window in the scene. The values should be in the range of 0 to"]
        #[doc = " 1, inclusive and in multiples of 0.00001. maxscl[ 0 ], maxscl[ 1 ], and"]
        #[doc = " maxscl[ 2 ] are corresponding to R, G, B color components respectively."]
        pub maxscl: [root::AVRational; 3usize],
        #[doc = " The average of linearized maxRGB values in the processing window in the"]
        #[doc = " scene. The value should be in the range of 0 to 1, inclusive and in"]
        #[doc = " multiples of 0.00001."]
        pub average_maxrgb: root::AVRational,
        #[doc = " The number of linearized maxRGB values at given percentiles in the"]
        #[doc = " processing window in the scene. The maximum value shall be 15."]
        pub num_distribution_maxrgb_percentiles: u8,
        #[doc = " The linearized maxRGB values at given percentiles in the"]
        #[doc = " processing window in the scene."]
        pub distribution_maxrgb: [root::AVHDRPlusPercentile; 15usize],
        #[doc = " The fraction of selected pixels in the image that contains the brightest"]
        #[doc = " pixel in the scene. The value shall be in the range of 0 to 1, inclusive"]
        #[doc = " and in multiples of 0.001."]
        pub fraction_bright_pixels: root::AVRational,
        #[doc = " This flag indicates that the metadata for the tone mapping function in"]
        #[doc = " the processing window is present (for value of 1)."]
        pub tone_mapping_flag: u8,
        #[doc = " The x coordinate of the separation point between the linear part and the"]
        #[doc = " curved part of the tone mapping function. The value shall be in the range"]
        #[doc = " of 0 to 1, excluding 0 and in multiples of 1/4095."]
        pub knee_point_x: root::AVRational,
        #[doc = " The y coordinate of the separation point between the linear part and the"]
        #[doc = " curved part of the tone mapping function. The value shall be in the range"]
        #[doc = " of 0 to 1, excluding 0 and in multiples of 1/4095."]
        pub knee_point_y: root::AVRational,
        #[doc = " The number of the intermediate anchor parameters of the tone mapping"]
        #[doc = " function in the processing window. The maximum value shall be 15."]
        pub num_bezier_curve_anchors: u8,
        #[doc = " The intermediate anchor parameters of the tone mapping function in the"]
        #[doc = " processing window in the scene. The values should be in the range of 0"]
        #[doc = " to 1, inclusive and in multiples of 1/1023."]
        pub bezier_curve_anchors: [root::AVRational; 15usize],
        #[doc = " This flag shall be equal to 0 in bitstreams conforming to this version of"]
        #[doc = " this Specification. Other values are reserved for future use."]
        pub color_saturation_mapping_flag: u8,
        #[doc = " The color saturation gain in the processing window in the scene. The"]
        #[doc = " value shall be in the range of 0 to 63/8, inclusive and in multiples of"]
        #[doc = " 1/8. The default value shall be 1."]
        pub color_saturation_weight: root::AVRational,
    }
    impl Default for AVHDRPlusColorTransformParams {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = " This struct represents dynamic metadata for color volume transform -"]
    #[doc = " application 4 of SMPTE 2094-40:2016 standard."]
    #[doc = ""]
    #[doc = " To be used as payload of a AVFrameSideData or AVPacketSideData with the"]
    #[doc = " appropriate type."]
    #[doc = ""]
    #[doc = " @note The struct should be allocated with"]
    #[doc = " av_dynamic_hdr_plus_alloc() and its size is not a part of"]
    #[doc = " the public ABI."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVDynamicHDRPlus {
        #[doc = " Country code by Rec. ITU-T T.35 Annex A. The value shall be 0xB5."]
        pub itu_t_t35_country_code: u8,
        #[doc = " Application version in the application defining document in ST-2094"]
        #[doc = " suite. The value shall be set to 0."]
        pub application_version: u8,
        #[doc = " The number of processing windows. The value shall be in the range"]
        #[doc = " of 1 to 3, inclusive."]
        pub num_windows: u8,
        #[doc = " The color transform parameters for every processing window."]
        pub params: [root::AVHDRPlusColorTransformParams; 3usize],
        #[doc = " The nominal maximum display luminance of the targeted system display,"]
        #[doc = " in units of 0.0001 candelas per square metre. The value shall be in"]
        #[doc = " the range of 0 to 10000, inclusive."]
        pub targeted_system_display_maximum_luminance: root::AVRational,
        #[doc = " This flag shall be equal to 0 in bit streams conforming to this version"]
        #[doc = " of this Specification. The value 1 is reserved for future use."]
        pub targeted_system_display_actual_peak_luminance_flag: u8,
        #[doc = " The number of rows in the targeted system_display_actual_peak_luminance"]
        #[doc = " array. The value shall be in the range of 2 to 25, inclusive."]
        pub num_rows_targeted_system_display_actual_peak_luminance: u8,
        #[doc = " The number of columns in the"]
        #[doc = " targeted_system_display_actual_peak_luminance array. The value shall be"]
        #[doc = " in the range of 2 to 25, inclusive."]
        pub num_cols_targeted_system_display_actual_peak_luminance: u8,
        #[doc = " The normalized actual peak luminance of the targeted system display. The"]
        #[doc = " values should be in the range of 0 to 1, inclusive and in multiples of"]
        #[doc = " 1/15."]
        pub targeted_system_display_actual_peak_luminance: [[root::AVRational; 25usize]; 25usize],
        #[doc = " This flag shall be equal to 0 in bitstreams conforming to this version of"]
        #[doc = " this Specification. The value 1 is reserved for future use."]
        pub mastering_display_actual_peak_luminance_flag: u8,
        #[doc = " The number of rows in the mastering_display_actual_peak_luminance array."]
        #[doc = " The value shall be in the range of 2 to 25, inclusive."]
        pub num_rows_mastering_display_actual_peak_luminance: u8,
        #[doc = " The number of columns in the mastering_display_actual_peak_luminance"]
        #[doc = " array. The value shall be in the range of 2 to 25, inclusive."]
        pub num_cols_mastering_display_actual_peak_luminance: u8,
        #[doc = " The normalized actual peak luminance of the mastering display used for"]
        #[doc = " mastering the image essence. The values should be in the range of 0 to 1,"]
        #[doc = " inclusive and in multiples of 1/15."]
        pub mastering_display_actual_peak_luminance: [[root::AVRational; 25usize]; 25usize],
    }
    impl Default for AVDynamicHDRPlus {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Allocate an AVDynamicHDRPlus structure and set its fields to"]
        #[doc = " default values. The resulting struct can be freed using av_freep()."]
        #[doc = ""]
        #[doc = " @return An AVDynamicHDRPlus filled with default values or NULL"]
        #[doc = "         on failure."]
        pub fn av_dynamic_hdr_plus_alloc(size: *mut root::size_t) -> *mut root::AVDynamicHDRPlus;
    }
    extern "C" {
        #[doc = " Allocate a complete AVDynamicHDRPlus and add it to the frame."]
        #[doc = " @param frame The frame which side data is added to."]
        #[doc = ""]
        #[doc = " @return The AVDynamicHDRPlus structure to be filled by caller or NULL"]
        #[doc = "         on failure."]
        pub fn av_dynamic_hdr_plus_create_side_data(
            frame: *mut root::AVFrame,
        ) -> *mut root::AVDynamicHDRPlus;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVAESCTR {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate an AVAESCTR context."]
        pub fn av_aes_ctr_alloc() -> *mut root::AVAESCTR;
    }
    extern "C" {
        #[doc = " Initialize an AVAESCTR context."]
        #[doc = " @param key encryption key, must have a length of AES_CTR_KEY_SIZE"]
        pub fn av_aes_ctr_init(a: *mut root::AVAESCTR, key: *const u8) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Release an AVAESCTR context."]
        pub fn av_aes_ctr_free(a: *mut root::AVAESCTR);
    }
    extern "C" {
        #[doc = " Process a buffer using a previously initialized context."]
        #[doc = " @param dst destination array, can be equal to src"]
        #[doc = " @param src source array, can be equal to dst"]
        #[doc = " @param size the size of src and dst"]
        pub fn av_aes_ctr_crypt(
            a: *mut root::AVAESCTR,
            dst: *mut u8,
            src: *const u8,
            size: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Get the current iv"]
        pub fn av_aes_ctr_get_iv(a: *mut root::AVAESCTR) -> *const u8;
    }
    extern "C" {
        #[doc = " Generate a random iv"]
        pub fn av_aes_ctr_set_random_iv(a: *mut root::AVAESCTR);
    }
    extern "C" {
        #[doc = " Forcefully change the 8-byte iv"]
        pub fn av_aes_ctr_set_iv(a: *mut root::AVAESCTR, iv: *const u8);
    }
    extern "C" {
        #[doc = " Forcefully change the \"full\" 16-byte iv, including the counter"]
        pub fn av_aes_ctr_set_full_iv(a: *mut root::AVAESCTR, iv: *const u8);
    }
    extern "C" {
        #[doc = " Increment the top 64 bit of the iv (performed after each frame)"]
        pub fn av_aes_ctr_increment_iv(a: *mut root::AVAESCTR);
    }
    #[doc = "< Not indicated."]
    pub const AVDownmixType_AV_DOWNMIX_TYPE_UNKNOWN: root::AVDownmixType = 0;
    #[doc = "< Lo/Ro 2-channel downmix (Stereo)."]
    pub const AVDownmixType_AV_DOWNMIX_TYPE_LORO: root::AVDownmixType = 1;
    #[doc = "< Lt/Rt 2-channel downmix, Dolby Surround compatible."]
    pub const AVDownmixType_AV_DOWNMIX_TYPE_LTRT: root::AVDownmixType = 2;
    #[doc = "< Lt/Rt 2-channel downmix, Dolby Pro Logic II compatible."]
    pub const AVDownmixType_AV_DOWNMIX_TYPE_DPLII: root::AVDownmixType = 3;
    #[doc = "< Number of downmix types. Not part of ABI."]
    pub const AVDownmixType_AV_DOWNMIX_TYPE_NB: root::AVDownmixType = 4;
    #[doc = " Possible downmix types."]
    pub type AVDownmixType = ::std::os::raw::c_uint;
    #[doc = " This structure describes optional metadata relevant to a downmix procedure."]
    #[doc = ""]
    #[doc = " All fields are set by the decoder to the value indicated in the audio"]
    #[doc = " bitstream (if present), or to a \"sane\" default otherwise."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVDownmixInfo {
        #[doc = " Type of downmix preferred by the mastering engineer."]
        pub preferred_downmix_type: root::AVDownmixType,
        #[doc = " Absolute scale factor representing the nominal level of the center"]
        #[doc = " channel during a regular downmix."]
        pub center_mix_level: f64,
        #[doc = " Absolute scale factor representing the nominal level of the center"]
        #[doc = " channel during an Lt/Rt compatible downmix."]
        pub center_mix_level_ltrt: f64,
        #[doc = " Absolute scale factor representing the nominal level of the surround"]
        #[doc = " channels during a regular downmix."]
        pub surround_mix_level: f64,
        #[doc = " Absolute scale factor representing the nominal level of the surround"]
        #[doc = " channels during an Lt/Rt compatible downmix."]
        pub surround_mix_level_ltrt: f64,
        #[doc = " Absolute scale factor representing the level at which the LFE data is"]
        #[doc = " mixed into L/R channels during downmixing."]
        pub lfe_mix_level: f64,
    }
    impl Default for AVDownmixInfo {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing."]
        #[doc = ""]
        #[doc = " If the side data is absent, it is created and added to the frame."]
        #[doc = ""]
        #[doc = " @param frame the frame for which the side data is to be obtained or created"]
        #[doc = ""]
        #[doc = " @return the AVDownmixInfo structure to be edited by the caller, or NULL if"]
        #[doc = "         the structure cannot be allocated."]
        pub fn av_downmix_info_update_side_data(
            frame: *mut root::AVFrame,
        ) -> *mut root::AVDownmixInfo;
    }
    #[doc = " @example ffhash.c"]
    #[doc = " This example is a simple command line application that takes one or more"]
    #[doc = " arguments. It demonstrates a typical use of the hashing API with allocation,"]
    #[doc = " initialization, updating, and finalizing."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVHashContext {
        _unused: [u8; 0],
    }
    extern "C" {
        #[doc = " Allocate a hash context for the algorithm specified by name."]
        #[doc = ""]
        #[doc = " @return  >= 0 for success, a negative error code for failure"]
        #[doc = ""]
        #[doc = " @note The context is not initialized after a call to this function; you must"]
        #[doc = " call av_hash_init() to do so."]
        pub fn av_hash_alloc(
            ctx: *mut *mut root::AVHashContext,
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the names of available hash algorithms."]
        #[doc = ""]
        #[doc = " This function can be used to enumerate the algorithms."]
        #[doc = ""]
        #[doc = " @param[in] i  Index of the hash algorithm, starting from 0"]
        #[doc = " @return       Pointer to a static string or `NULL` if `i` is out of range"]
        pub fn av_hash_names(i: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the name of the algorithm corresponding to the given hash context."]
        pub fn av_hash_get_name(ctx: *const root::AVHashContext) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the size of the resulting hash value in bytes."]
        #[doc = ""]
        #[doc = " The maximum value this function will currently return is available as macro"]
        #[doc = " #AV_HASH_MAX_SIZE."]
        #[doc = ""]
        #[doc = " @param[in]     ctx Hash context"]
        #[doc = " @return            Size of the hash value in bytes"]
        pub fn av_hash_get_size(ctx: *const root::AVHashContext) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Initialize or reset a hash context."]
        #[doc = ""]
        #[doc = " @param[in,out] ctx Hash context"]
        pub fn av_hash_init(ctx: *mut root::AVHashContext);
    }
    extern "C" {
        #[doc = " Update a hash context with additional data."]
        #[doc = ""]
        #[doc = " @param[in,out] ctx Hash context"]
        #[doc = " @param[in]     src Data to be added to the hash context"]
        #[doc = " @param[in]     len Size of the additional data"]
        pub fn av_hash_update(ctx: *mut root::AVHashContext, src: *const u8, len: root::size_t);
    }
    extern "C" {
        #[doc = " Finalize a hash context and compute the actual hash value."]
        #[doc = ""]
        #[doc = " The minimum size of `dst` buffer is given by av_hash_get_size() or"]
        #[doc = " #AV_HASH_MAX_SIZE. The use of the latter macro is discouraged."]
        #[doc = ""]
        #[doc = " It is not safe to update or finalize a hash context again, if it has already"]
        #[doc = " been finalized."]
        #[doc = ""]
        #[doc = " @param[in,out] ctx Hash context"]
        #[doc = " @param[out]    dst Where the final hash value will be stored"]
        #[doc = ""]
        #[doc = " @see av_hash_final_bin() provides an alternative API"]
        pub fn av_hash_final(ctx: *mut root::AVHashContext, dst: *mut u8);
    }
    extern "C" {
        #[doc = " Finalize a hash context and store the actual hash value in a buffer."]
        #[doc = ""]
        #[doc = " It is not safe to update or finalize a hash context again, if it has already"]
        #[doc = " been finalized."]
        #[doc = ""]
        #[doc = " If `size` is smaller than the hash size (given by av_hash_get_size()), the"]
        #[doc = " hash is truncated; if size is larger, the buffer is padded with 0."]
        #[doc = ""]
        #[doc = " @param[in,out] ctx  Hash context"]
        #[doc = " @param[out]    dst  Where the final hash value will be stored"]
        #[doc = " @param[in]     size Number of bytes to write to `dst`"]
        pub fn av_hash_final_bin(
            ctx: *mut root::AVHashContext,
            dst: *mut u8,
            size: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Finalize a hash context and store the hexadecimal representation of the"]
        #[doc = " actual hash value as a string."]
        #[doc = ""]
        #[doc = " It is not safe to update or finalize a hash context again, if it has already"]
        #[doc = " been finalized."]
        #[doc = ""]
        #[doc = " The string is always 0-terminated."]
        #[doc = ""]
        #[doc = " If `size` is smaller than `2 * hash_size + 1`, where `hash_size` is the"]
        #[doc = " value returned by av_hash_get_size(), the string will be truncated."]
        #[doc = ""]
        #[doc = " @param[in,out] ctx  Hash context"]
        #[doc = " @param[out]    dst  Where the string will be stored"]
        #[doc = " @param[in]     size Maximum number of bytes to write to `dst`"]
        pub fn av_hash_final_hex(
            ctx: *mut root::AVHashContext,
            dst: *mut u8,
            size: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Finalize a hash context and store the Base64 representation of the"]
        #[doc = " actual hash value as a string."]
        #[doc = ""]
        #[doc = " It is not safe to update or finalize a hash context again, if it has already"]
        #[doc = " been finalized."]
        #[doc = ""]
        #[doc = " The string is always 0-terminated."]
        #[doc = ""]
        #[doc = " If `size` is smaller than AV_BASE64_SIZE(hash_size), where `hash_size` is"]
        #[doc = " the value returned by av_hash_get_size(), the string will be truncated."]
        #[doc = ""]
        #[doc = " @param[in,out] ctx  Hash context"]
        #[doc = " @param[out]    dst  Where the final hash value will be stored"]
        #[doc = " @param[in]     size Maximum number of bytes to write to `dst`"]
        pub fn av_hash_final_b64(
            ctx: *mut root::AVHashContext,
            dst: *mut u8,
            size: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Free hash context and set hash context pointer to `NULL`."]
        #[doc = ""]
        #[doc = " @param[in,out] ctx  Pointer to hash context"]
        pub fn av_hash_freep(ctx: *mut *mut root::AVHashContext);
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union av_alias64 {
        pub u64_: u64,
        pub u32_: [u32; 2usize],
        pub u16_: [u16; 4usize],
        pub u8_: [u8; 8usize],
        pub f64_: f64,
        pub f32_: [f32; 2usize],
    }
    impl Default for av_alias64 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union av_alias32 {
        pub u32_: u32,
        pub u16_: [u16; 2usize],
        pub u8_: [u8; 4usize],
        pub f32_: f32,
    }
    impl Default for av_alias32 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union av_alias16 {
        pub u16_: u16,
        pub u8_: [u8; 2usize],
    }
    impl Default for av_alias16 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C, packed)]
    #[derive(Copy, Clone)]
    pub union unaligned_64 {
        pub l: u64,
    }
    impl Default for unaligned_64 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C, packed)]
    #[derive(Copy, Clone)]
    pub union unaligned_32 {
        pub l: u32,
    }
    impl Default for unaligned_32 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C, packed)]
    #[derive(Copy, Clone)]
    pub union unaligned_16 {
        pub l: u16,
    }
    impl Default for unaligned_16 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    pub const AVFilmGrainParamsType_AV_FILM_GRAIN_PARAMS_NONE: root::AVFilmGrainParamsType = 0;
    #[doc = " The union is valid when interpreted as AVFilmGrainAOMParams (codec.aom)"]
    pub const AVFilmGrainParamsType_AV_FILM_GRAIN_PARAMS_AV1: root::AVFilmGrainParamsType = 1;
    #[doc = " The union is valid when interpreted as AVFilmGrainH274Params (codec.h274)"]
    pub const AVFilmGrainParamsType_AV_FILM_GRAIN_PARAMS_H274: root::AVFilmGrainParamsType = 2;
    pub type AVFilmGrainParamsType = ::std::os::raw::c_uint;
    #[doc = " This structure describes how to handle film grain synthesis for AOM codecs."]
    #[doc = ""]
    #[doc = " @note The struct must be allocated as part of AVFilmGrainParams using"]
    #[doc = "       av_film_grain_params_alloc(). Its size is not a part of the public ABI."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct AVFilmGrainAOMParams {
        #[doc = " Number of points, and the scale and value for each point of the"]
        #[doc = " piecewise linear scaling function for the uma plane."]
        pub num_y_points: ::std::os::raw::c_int,
        pub y_points: [[u8; 2usize]; 14usize],
        #[doc = " Signals whether to derive the chroma scaling function from the luma."]
        #[doc = " Not equivalent to copying the luma values and scales."]
        pub chroma_scaling_from_luma: ::std::os::raw::c_int,
        #[doc = " If chroma_scaling_from_luma is set to 0, signals the chroma scaling"]
        #[doc = " function parameters."]
        pub num_uv_points: [::std::os::raw::c_int; 2usize],
        pub uv_points: [[[u8; 2usize]; 10usize]; 2usize],
        #[doc = " Specifies the shift applied to the chroma components. For AV1, its within"]
        #[doc = " [8; 11] and determines the range and quantization of the film grain."]
        pub scaling_shift: ::std::os::raw::c_int,
        #[doc = " Specifies the auto-regression lag."]
        pub ar_coeff_lag: ::std::os::raw::c_int,
        #[doc = " Luma auto-regression coefficients. The number of coefficients is given by"]
        #[doc = " 2 * ar_coeff_lag * (ar_coeff_lag + 1)."]
        pub ar_coeffs_y: [i8; 24usize],
        #[doc = " Chroma auto-regression coefficients. The number of coefficients is given by"]
        #[doc = " 2 * ar_coeff_lag * (ar_coeff_lag + 1) + !!num_y_points."]
        pub ar_coeffs_uv: [[i8; 25usize]; 2usize],
        #[doc = " Specifies the range of the auto-regressive coefficients. Values of 6,"]
        #[doc = " 7, 8 and so on represent a range of [-2, 2), [-1, 1), [-0.5, 0.5) and"]
        #[doc = " so on. For AV1 must be between 6 and 9."]
        pub ar_coeff_shift: ::std::os::raw::c_int,
        #[doc = " Signals the down shift applied to the generated gaussian numbers during"]
        #[doc = " synthesis."]
        pub grain_scale_shift: ::std::os::raw::c_int,
        #[doc = " Specifies the luma/chroma multipliers for the index to the component"]
        #[doc = " scaling function."]
        pub uv_mult: [::std::os::raw::c_int; 2usize],
        pub uv_mult_luma: [::std::os::raw::c_int; 2usize],
        #[doc = " Offset used for component scaling function. For AV1 its a 9-bit value"]
        #[doc = " with a range [-256, 255]"]
        pub uv_offset: [::std::os::raw::c_int; 2usize],
        #[doc = " Signals whether to overlap film grain blocks."]
        pub overlap_flag: ::std::os::raw::c_int,
        #[doc = " Signals to clip to limited color levels after film grain application."]
        pub limit_output_range: ::std::os::raw::c_int,
    }
    #[doc = " This structure describes how to handle film grain synthesis for codecs using"]
    #[doc = " the ITU-T H.274 Versatile suplemental enhancement information message."]
    #[doc = ""]
    #[doc = " @note The struct must be allocated as part of AVFilmGrainParams using"]
    #[doc = "       av_film_grain_params_alloc(). Its size is not a part of the public ABI."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AVFilmGrainH274Params {
        #[doc = " Specifies the film grain simulation mode."]
        #[doc = " 0 = Frequency filtering, 1 = Auto-regression"]
        pub model_id: ::std::os::raw::c_int,
        #[doc = " Specifies the bit depth used for the luma component."]
        pub bit_depth_luma: ::std::os::raw::c_int,
        #[doc = " Specifies the bit depth used for the chroma components."]
        pub bit_depth_chroma: ::std::os::raw::c_int,
        pub color_range: root::AVColorRange,
        pub color_primaries: root::AVColorPrimaries,
        pub color_trc: root::AVColorTransferCharacteristic,
        pub color_space: root::AVColorSpace,
        #[doc = " Specifies the blending mode used to blend the simulated film grain"]
        #[doc = " with the decoded images."]
        #[doc = ""]
        #[doc = " 0 = Additive, 1 = Multiplicative"]
        pub blending_mode_id: ::std::os::raw::c_int,
        #[doc = " Specifies a scale factor used in the film grain characterization equations."]
        pub log2_scale_factor: ::std::os::raw::c_int,
        #[doc = " Indicates if the modelling of film grain for a given component is present."]
        pub component_model_present: [::std::os::raw::c_int; 3usize],
        #[doc = " Specifies the number of intensity intervals for which a specific set of"]
        #[doc = " model values has been estimated, with a range of [1, 256]."]
        pub num_intensity_intervals: [u16; 3usize],
        #[doc = " Specifies the number of model values present for each intensity interval"]
        #[doc = " in which the film grain has been modelled, with a range of [1, 6]."]
        pub num_model_values: [u8; 3usize],
        #[doc = " Specifies the lower ounds of each intensity interval for whichthe set of"]
        #[doc = " model values applies for the component."]
        pub intensity_interval_lower_bound: [[u8; 256usize]; 3usize],
        #[doc = " Specifies the upper bound of each intensity interval for which the set of"]
        #[doc = " model values applies for the component."]
        pub intensity_interval_upper_bound: [[u8; 256usize]; 3usize],
        #[doc = " Specifies the model values for the component for each intensity interval."]
        #[doc = " - When model_id == 0, the following applies:"]
        #[doc = "     For comp_model_value[y], the range of values is [0, 2^bit_depth_luma - 1]"]
        #[doc = "     For comp_model_value[cb..cr], the range of values is [0, 2^bit_depth_chroma - 1]"]
        #[doc = " - Otherwise, the following applies:"]
        #[doc = "     For comp_model_value[y], the range of values is [-2^(bit_depth_luma - 1), 2^(bit_depth_luma - 1) - 1]"]
        #[doc = "     For comp_model_value[cb..cr], the range of values is [-2^(bit_depth_chroma - 1), 2^(bit_depth_chroma - 1) - 1]"]
        pub comp_model_value: [[[i16; 6usize]; 256usize]; 3usize],
    }
    impl Default for AVFilmGrainH274Params {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = " This structure describes how to handle film grain synthesis in video"]
    #[doc = " for specific codecs. Must be present on every frame where film grain is"]
    #[doc = " meant to be synthesised for correct presentation."]
    #[doc = ""]
    #[doc = " @note The struct must be allocated with av_film_grain_params_alloc() and"]
    #[doc = "       its size is not a part of the public ABI."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct AVFilmGrainParams {
        #[doc = " Specifies the codec for which this structure is valid."]
        pub type_: root::AVFilmGrainParamsType,
        #[doc = " Seed to use for the synthesis process, if the codec allows for it."]
        #[doc = ""]
        #[doc = " @note For H.264, this refers to `pic_offset` as defined in"]
        #[doc = "       SMPTE RDD 5-2006."]
        pub seed: u64,
        pub codec: root::AVFilmGrainParams__bindgen_ty_1,
    }
    #[doc = " Additional fields may be added both here and in any structure included."]
    #[doc = " If a codec's film grain structure differs slightly over another"]
    #[doc = " codec's, fields within may change meaning depending on the type."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union AVFilmGrainParams__bindgen_ty_1 {
        pub aom: root::AVFilmGrainAOMParams,
        pub h274: root::AVFilmGrainH274Params,
    }
    impl Default for AVFilmGrainParams__bindgen_ty_1 {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    impl Default for AVFilmGrainParams {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    extern "C" {
        #[doc = " Allocate an AVFilmGrainParams structure and set its fields to"]
        #[doc = " default values. The resulting struct can be freed using av_freep()."]
        #[doc = " If size is not NULL it will be set to the number of bytes allocated."]
        #[doc = ""]
        #[doc = " @return An AVFilmGrainParams filled with default values or NULL"]
        #[doc = "         on failure."]
        pub fn av_film_grain_params_alloc(size: *mut root::size_t) -> *mut root::AVFilmGrainParams;
    }
    extern "C" {
        #[doc = " Allocate a complete AVFilmGrainParams and add it to the frame."]
        #[doc = ""]
        #[doc = " @param frame The frame which side data is added to."]
        #[doc = ""]
        #[doc = " @return The AVFilmGrainParams structure to be filled by caller."]
        pub fn av_film_grain_params_create_side_data(
            frame: *mut root::AVFrame,
        ) -> *mut root::AVFilmGrainParams;
    }
    pub type __builtin_va_list = *mut ::std::os::raw::c_char;
    pub type __uint128_t = u128;
}
